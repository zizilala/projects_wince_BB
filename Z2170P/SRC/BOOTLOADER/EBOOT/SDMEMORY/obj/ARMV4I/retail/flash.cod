; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\EBOOT\SDMEMORY\flash.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|g_ulFlashBase| [ DATA ]
	EXPORT	|g_ulFlashLengthBytes| [ DATA ]
	EXPORT	|g_ulBPartBase| [ DATA ]
	EXPORT	|g_ulBPartLengthBytes| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_bpartBuffer| % 0x20a00

  00000			 AREA	 |.data|, DATA
	 COMMON	|s_binDio|, 0x10

|g_ulFlashBase| DCD 0x8000000
|g_ulFlashLengthBytes| DCD 0x2
|g_ulBPartBase| DCD |g_bpartBuffer|
|g_ulBPartLengthBytes| DCD 0x20a00

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|BLFlashDownload|
; File c:\wince600\platform\z2170p\src\bootloader\eboot\sdmemory\flash.c

  00000			 AREA	 |.pdata|, PDATA
|$T47772| DCD	|$LN5@BLFlashDow|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLFlashDownload| PROC

; 125  : {

  00000		 |$LN5@BLFlashDow|
  00000		 |$M47769|

; 126  :     UINT32 rc = (UINT32) BL_ERROR;
; 127  : 
; 128  :     UNREFERENCED_PARAMETER(pBootDevices);
; 129  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 130  :     // We have do device initialization for some devices
; 131  :     switch (pConfig->bootDevLoc.IfcType)
; 132  :         {
; 133  :         case Internal:
; 134  :             switch (pConfig->bootDevLoc.LogicalLoc)
; 135  :                 {
; 136  :                 case BSP_NAND_REGS_PA + 0x20:
; 137  :                 rc = ReadFlashNK();
; 138  :                 break;
; 139  :                 }
; 140  :             break;
; 141  :         }
; 142  : #else
; 143  :     UNREFERENCED_PARAMETER(pConfig);
; 144  : #endif
; 145  :     return rc;

  00000	e3e00000	 mvn         r0, #0

; 146  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47770|

			 ENDP  ; |BLFlashDownload|

	EXPORT	|OEMStartEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47781| DCD	|$LN5@OEMStartEr|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMStartEraseFlash| PROC

; 160  : {

  00000		 |$LN5@OEMStartEr|
  00000		 |$M47778|

; 161  :     BOOL rc;
; 162  :     
; 163  :     UNREFERENCED_PARAMETER(address);
; 164  :     UNREFERENCED_PARAMETER(size);
; 165  :     
; 166  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 167  :     rc = TRUE;
; 168  : 
; 169  :     OALMSG(OAL_FUNC, (
; 170  :         L"+OEMStartEraseFlash(0x%08x, 0x%08x)\r\n", address, size
; 171  :         ));
; 172  :     
; 173  :     OALMSG(OAL_FUNC, (L"-OEMStartEraseFlash(rc = %d)\r\n", rc));   
; 174  :     
; 175  : #else   
; 176  :     rc = FALSE;    
; 177  : #endif	
; 178  : 
; 179  :     return rc;

  00000	e3a00000	 mov         r0, #0

; 180  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47779|

			 ENDP  ; |OEMStartEraseFlash|

	EXPORT	|OEMContinueEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47788| DCD	|$LN5@OEMContinu|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMContinueEraseFlash| PROC

; 193  : {

  00000		 |$LN5@OEMContinu|
  00000		 |$M47785|

; 194  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47786|

			 ENDP  ; |OEMContinueEraseFlash|

	EXPORT	|OEMFinishEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47797| DCD	|$LN5@OEMFinishE|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMFinishEraseFlash| PROC

; 207  : {

  00000		 |$LN5@OEMFinishE|
  00000		 |$M47794|

; 208  :     BOOL rc = TRUE;
; 209  : 
; 210  :     return rc;

  00000	e3a00001	 mov         r0, #1

; 211  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47795|

			 ENDP  ; |OEMFinishEraseFlash|

	EXPORT	|OEMWriteFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47806| DCD	|$LN5@OEMWriteFl|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMWriteFlash| PROC

; 226  : {

  00000		 |$LN5@OEMWriteFl|
  00000		 |$M47803|

; 227  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 228  :     BOOL rc;
; 229  : 
; 230  :     switch (g_eboot.type)
; 231  :         {
; 232  :         case DOWNLOAD_TYPE_XLDR:
; 233  :             rc = WriteFlashXLDR(address, size);
; 234  :             break;
; 235  :         case DOWNLOAD_TYPE_EBOOT:
; 236  :             rc = WriteFlashEBOOT(address, size);
; 237  :             break;
; 238  : 		case DOWNLOAD_TYPE_LOGO:
; 239  :             rc = WriteFlashLogo(address, size);
; 240  : 			break;
; 241  :         case DOWNLOAD_TYPE_FLASHNAND:
; 242  :             rc = WriteFlashNK(address, size);
; 243  :             break;
; 244  : #ifdef IMGMULTIXIP
; 245  :         case DOWNLOAD_TYPE_EXT:
; 246  :             rc = WriteFlashEXT(address, size);
; 247  :             break;
; 248  : #endif			
; 249  :         default:
; 250  :             rc = FALSE;
; 251  :             break;
; 252  :         }
; 253  :     return rc;
; 254  : 	
; 255  : #else
; 256  :     UNREFERENCED_PARAMETER(address);
; 257  :     UNREFERENCED_PARAMETER(size);
; 258  :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 259  : #endif
; 260  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47804|

			 ENDP  ; |OEMWriteFlash|

	EXPORT	|WriteFlashNK|

  00000			 AREA	 |.pdata|, PDATA
|$T47815| DCD	|$LN5@WriteFlash|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteFlashNK| PROC

; 269  : {

  00000		 |$LN5@WriteFlash|
  00000		 |$M47812|

; 270  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 271  :     BOOL rc = FALSE;
; 272  :     BOOL bExt = FALSE;
; 273  :     HANDLE hPartition;
; 274  :     UCHAR *pData;
; 275  :     PCI_REG_INFO regInfo;
; 276  : 
; 277  :     memset(&regInfo, 0, sizeof(PCI_REG_INFO));
; 278  :     regInfo.MemBase.Num    = 1;
; 279  :     regInfo.MemLen.Num     = 1;
; 280  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 281  :     regInfo.MemLen.Reg[0]  = g_ulFlashLengthBytes;
; 282  : 
; 283  : 
; 284  :     // Get data location
; 285  :     pData = OEMMapMemAddr(address, address);
; 286  : #ifdef IMGMULTIXIP
; 287  :     // Checking if this is an EXT region
; 288  :     if((address == (IMAGE_WINCE_EXT_CA + NAND_ROMOFFSET)) || (address == IMAGE_WINCE_EXT_CA) )
; 289  :     {
; 290  :         bExt = TRUE;
; 291  :         OALLog(L"\r\nWriting EXT image to OS partition, address=%x, SIZE=%x\r\n", address, size);
; 292  :     }
; 293  :     else if ((address == (IMAGE_WINCE_CODE_CA + NAND_ROMOFFSET) )|| (address == IMAGE_WINCE_CODE_CA))
; 294  :     {
; 295  :         OALLog(L"\r\nWriting NK image to OS partition address=%x, SIZE=%x\r\n", address, size);
; 296  :     }
; 297  : #endif
; 298  : 
; 299  :     // Verify that we get CE image.
; 300  :     if (!VerifyImage(pData, NULL))
; 301  :         {
; 302  :         OALMSG(OAL_ERROR, (L"ERROR: OEMWriteFlash: "
; 303  :             L"NK image signature not found\r\n"
; 304  :             ));
; 305  :         rc = TRUE;
; 306  :         goto cleanUp;
; 307  :         }
; 308  : 
; 309  :     // Initialize boot partition library
; 310  :     if (!BP_Init((LPBYTE)g_ulBPartBase, g_ulBPartLengthBytes, NULL, &regInfo, NULL))
; 311  :     {
; 312  :         OALLog(L"WriteFlashNK: Error initializing bootpart library!!\r\n");
; 313  :         goto cleanUp;
; 314  :     }
; 315  :     
; 316  :     // Open partition based on region type 
; 317  :     hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, bExt ? PART_BINFS : PART_BOOTSECTION, FALSE, PART_OPEN_EXISTING);
; 318  :     if (hPartition == INVALID_HANDLE_VALUE)
; 319  :     {
; 320  :         OALMSG(OAL_ERROR, (L"ERROR: OS partition not found!\r\n"));
; 321  :         goto cleanUp;
; 322  :     }
; 323  :     
; 324  :     // Check length against size of partition
; 325  :     if (!BP_SetDataPointer(hPartition, size))
; 326  :     {
; 327  :         OALMSG(OAL_ERROR, (L"ERROR: OS partition too small!  Aborting...\r\n"));
; 328  :         goto cleanUp;
; 329  :     }
; 330  :     
; 331  :     // Write image to partition
; 332  :     BP_SetDataPointer(hPartition, 0);
; 333  :     if (!BP_WriteData(hPartition, pData, size))
; 334  :     {
; 335  :         OALMSG(OAL_ERROR, (L"ERROR: Failed writing to OS partition!\r\n"));
; 336  :         goto cleanUp;
; 337  :     }
; 338  :     
; 339  :     //OALLog(L"%s image written\r\n", bExt ? L"EXT" :L"nk");
; 340  : 
; 341  :     // Change boot device to NAND
; 342  :     g_bootCfg.bootDevLoc.IfcType = Internal;
; 343  :     g_bootCfg.bootDevLoc.LogicalLoc = BSP_NAND_REGS_PA + 0x20;
; 344  : 
; 345  :     // Done
; 346  :     rc = TRUE;
; 347  : 
; 348  : cleanUp:
; 349  :     return rc;
; 350  : #else
; 351  :     UNREFERENCED_PARAMETER(address);
; 352  :     UNREFERENCED_PARAMETER(size);
; 353  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 354  : #endif
; 355  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47813|

			 ENDP  ; |WriteFlashNK|

	EXPORT	|BLConfigureFlashPartitions|

  00000			 AREA	 |.pdata|, PDATA
|$T47824| DCD	|$LN5@BLConfigur|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLConfigureFlashPartitions| PROC

; 865  : {

  00000		 |$LN5@BLConfigur|
  00000		 |$M47821|

; 866  :     BOOL rc = FALSE;
; 867  : 	
; 868  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 869  : 	
; 870  :     HANDLE hFMD;
; 871  :     PCI_REG_INFO regInfo;
; 872  :     FlashInfo flashInfo;
; 873  :     HANDLE hPartition;
; 874  :     PPARTENTRY pPartitionEntry;
; 875  :     DWORD dwBootPartitionSectorCount;
; 876  : 
; 877  : #ifdef IMGMULTIXIP
; 878  :     // Variable for sector count for the new BinFS region (EXT) 
; 879  :     DWORD dwExtPartitionSectorCount;
; 880  : #endif
; 881  : 
; 882  :     memset(&regInfo, 0, sizeof(PCI_REG_INFO));
; 883  :     regInfo.MemBase.Num    = 1;
; 884  :     regInfo.MemLen.Num     = 1;
; 885  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 886  :     
; 887  :     // Get flash info
; 888  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 889  :     if (hFMD == NULL)
; 890  :         goto cleanUp;
; 891  : 
; 892  :     if (!FMD_GetInfo(&flashInfo))
; 893  :         goto cleanUp;
; 894  :     
; 895  :     FMD_Deinit(hFMD);
; 896  :     
; 897  :     // Initialize boot partition library
; 898  :     if (!BP_Init((LPBYTE)g_ulBPartBase, g_ulBPartLengthBytes, NULL, &regInfo, NULL))
; 899  :     {
; 900  :         OALLog(L"BLConfigureFlashPartitions: Error initializing bootpart library!!\r\n");
; 901  :         goto cleanUp;
; 902  :     }
; 903  :     
; 904  :     // Get boot partition size
; 905  :     // Ensure boot partition uses entire blocks with no space left over
; 906  :     // Round up to an even block size
; 907  :     dwBootPartitionSectorCount = ((g_bootCfg.osPartitionSize + (flashInfo.dwBytesPerBlock - 1))/ flashInfo.dwBytesPerBlock) * flashInfo.wSectorsPerBlock;
; 908  : 
; 909  :     // Reduce by one to account for MBR, which will be the first sector in non reserved area.
; 910  :     // This causes boot partition to end on a block boundary
; 911  :     dwBootPartitionSectorCount -= 1;
; 912  : 
; 913  : #ifdef IMGMULTIXIP
; 914  :     
; 915  :     // Calculation of the size for the EXT region
; 916  :     dwExtPartitionSectorCount = ((IMAGE_WINCE_EXT_SIZE + (flashInfo.dwBytesPerBlock - 1))/ flashInfo.dwBytesPerBlock) * flashInfo.wSectorsPerBlock;
; 917  : 
; 918  :     dwExtPartitionSectorCount -= 1;
; 919  : #endif
; 920  : 
; 921  :     // Check for existence and size of OS boot partition
; 922  :     hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, PART_BOOTSECTION, FALSE, PART_OPEN_EXISTING);
; 923  :     if (hPartition == INVALID_HANDLE_VALUE)
; 924  :         OALLog(L"OS partition does not exist!!\r\n");
; 925  :     else
; 926  :     {
; 927  :         pPartitionEntry = BP_GetPartitionInfo(hPartition);
; 928  :         if (dwBootPartitionSectorCount != pPartitionEntry->Part_TotalSectors)
; 929  :         {
; 930  :             OALLog(L"OS partition does not match configured size!!  Sector count expected: 0x%x, actual 0x%x\r\n", dwBootPartitionSectorCount, pPartitionEntry->Part_TotalSectors);
; 931  :             // Mark handle invalid to kick us into formatting code
; 932  :             hPartition = INVALID_HANDLE_VALUE;
; 933  :         }
; 934  :     }
; 935  :         
; 936  :     if ((hPartition == INVALID_HANDLE_VALUE) || (bForceEnable == TRUE))
; 937  :     {
; 938  :         // OS binary partition either does not exist or does not match configured size
; 939  :         OALLog(L"Formatting flash...\r\n");
; 940  :         // Create a new partion
; 941  :         // Can't just call BP_OpenPartition with PART_OPEN_ALWAYS because it will erase reserved 
; 942  :         // blocks (bootloader) if MBR doesn't exist.  Also, we want to ensure the boot partition
; 943  :         // is actually the first partition on the flash.  So do low level format here (note that 
; 944  :         // this destroys all other partitions on the device)
; 945  :         // Note, we're skipping the block check for speed reasons. Might not want this in a production device...
; 946  :         BP_LowLevelFormat (0, flashInfo.dwNumBlocks, FORMAT_SKIP_RESERVED|FORMAT_SKIP_BLOCK_CHECK);
; 947  :         // Create the OS partition
; 948  :         hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, dwBootPartitionSectorCount, PART_BOOTSECTION, FALSE, PART_CREATE_NEW);
; 949  :         if (hPartition == INVALID_HANDLE_VALUE)
; 950  :         {
; 951  :             OALLog(L"Error creating OS partition!!\r\n");
; 952  :             goto cleanUp;
; 953  :         }
; 954  :         OALLog(L"NK partition created\r\n");
; 955  : 		
; 956  : #ifdef IMGMULTIXIP
; 957  : 
; 958  :        // Creation of the BinFS partition
; 959  :        hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, dwExtPartitionSectorCount, PART_BINFS, FALSE, PART_CREATE_NEW);
; 960  :        if (hPartition == INVALID_HANDLE_VALUE)
; 961  :        {
; 962  :            OALLog(L"Error creating OS partition!!\r\n");
; 963  :            goto cleanUp;
; 964  :        }
; 965  :        OALLog(L"EXT partition created\r\n");
; 966  : #endif
; 967  : 
; 968  :         // Create FAT partition on remaining flash (can be automatically mounted)
; 969  :         hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, PART_DOS32, FALSE, PART_CREATE_NEW);
; 970  :         if (hPartition == INVALID_HANDLE_VALUE)
; 971  :         {
; 972  :             OALLog(L"Error creating file partition!!\r\n");
; 973  :             goto cleanUp;
; 974  :         }
; 975  :         OALLog(L"Flash format complete!\r\n");
; 976  :     }
; 977  :     
; 978  :     // Done
; 979  :     rc = TRUE;
; 980  : 
; 981  : cleanUp:
; 982  : #else
; 983  :     UNREFERENCED_PARAMETER(bForceEnable);
; 984  : #endif
; 985  :     return rc;

  00000	e3a00000	 mov         r0, #0

; 986  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47822|

			 ENDP  ; |BLConfigureFlashPartitions|

	END

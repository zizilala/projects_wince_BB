; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\TPS659XX\DRIVER\tps659xx.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19IAPNKDAH@?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|?_rgKeypadMatrixQueue@@3PAY07EA| [ DATA ] ; _rgKeypadMatrixQueue
	EXPORT	|DEVICE_IFC_TWL_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]
	EXPORT	|?_SIHEntry_GPIO@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_GPIO
	EXPORT	|?_SIHEntry_Keypad@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_Keypad
	EXPORT	|?_SIHEntry_BCI@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_BCI
	EXPORT	|?_SIHEntry_MADC@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_MADC
	EXPORT	|?_SIHEntry_USB@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_USB
	EXPORT	|?_SIHEntry_Power@@3USIHEntry_t@@A| [ DATA ] ; _SIHEntry_Power
	EXPORT	|?_nKeypadMatrixQueueHead@@3KA| [ DATA ] ; _nKeypadMatrixQueueHead
	EXPORT	|?_nKeypadMatrixQueueTail@@3KA| [ DATA ] ; _nKeypadMatrixQueueTail
	EXPORT	|?_nKeypadMatrixQueueCount@@3JA| [ DATA ] ; _nKeypadMatrixQueueCount

  00000			 AREA	 |.bss|, NOINIT
|?_rgKeypadMatrixQueue@@3PAY07EA| % 0x80		; _rgKeypadMatrixQueue
|?_nKeypadMatrixQueueHead@@3KA| % 0x4			; _nKeypadMatrixQueueHead
|?_nKeypadMatrixQueueTail@@3KA| % 0x4			; _nKeypadMatrixQueueTail
|?_nKeypadMatrixQueueCount@@3JA| % 0x4			; _nKeypadMatrixQueueCount

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19IAPNKDAH@?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "G", 0x0, "p", 0x0, "i"
	DCB	0x0, "o", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "T", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "o", 0x0, "n", 0x0
	DCB	" ", 0x0, "(", 0x0, "T", 0x0, "W", 0x0, "L", 0x0, ")", 0x0
	DCB	0x0, 0x0
	%	38
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"R", 0x0, "T", 0x0, "C", 0x0, 0x0, 0x0
	%	56
	DCD	0x8003
|?_SIHEntry_Keypad@@3USIHEntry_t@@A| DCD 0x200e9	; _SIHEntry_Keypad
	DCD	0x200e3
	DCD	0x200e4
	DCB	0xf
	DCB	0xf
	%	2
	DCD	0x4
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	DCD	0x0
|?_SIHEntry_GPIO@@3USIHEntry_t@@A| DCD 0x100c5		; _SIHEntry_GPIO
	DCD	0x100b1
	DCD	0x100b4
	DCB	0xff
	DCB	0xff
	%	2
	DCD	0x8
	DCD	0x100b2
	DCD	0x100b5
	DCB	0xff
	DCB	0xff
	%	2
	DCD	0x8
	DCD	0x100b3
	DCD	0x100b6
	DCB	0x3
	DCB	0x3
	%	2
	DCD	0x2
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	%	4
|?_SIHEntry_BCI@@3USIHEntry_t@@A| DCD 0x200c6		; _SIHEntry_BCI
	DCD	0x200b9
	DCD	0x200bb
	DCB	0xff
	DCB	0xff
	%	2
	DCD	0x8
	DCD	0x200ba
	DCD	0x200bc
	DCB	0xf
	DCB	0xf
	%	2
	DCD	0x4
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	%	4
|?_SIHEntry_MADC@@3USIHEntry_t@@A| DCD 0x20067		; _SIHEntry_MADC
	DCD	0x20061
	DCD	0x20062
	DCB	0xf
	DCB	0xf
	%	2
	DCD	0x4
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	DCD	0x0
|?_SIHEntry_Power@@3USIHEntry_t@@A| DCD 0x30035		; _SIHEntry_Power
	DCD	0x3002e
	DCD	0x3002f
	DCB	0xff
	DCB	0xff
	%	2
	DCD	0x8
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	%	4
|?_SIHEntry_USB@@3USIHEntry_t@@A| DCD 0x0		; _SIHEntry_USB
	DCD	0x13
	DCD	0xd
	DCB	0x1e
	DCB	0x0
	%	2
	DCD	0x8
	DCD	0x13
	DCD	0x10
	DCB	0x1e
	DCB	0x0
	%	2
	DCD	0x8
	DCD	0x8c
	DCD	0x86
	DCB	0x0
	DCB	0x0
	%	2
	DCD	0x8
	DCD	0x8c
	DCD	0x89
	DCB	0x0
	DCB	0x0
	%	2
	DCD	0x8
	DCD	0x0
	DCD	0x0
	DCB	0x0
	DCB	0x0
	%	2
	DCD	0x0
|s_pSIHEntries| DCD |?_SIHEntry_GPIO@@3USIHEntry_t@@A|
	DCD	|?_SIHEntry_Keypad@@3USIHEntry_t@@A|
	DCD	|?_SIHEntry_BCI@@3USIHEntry_t@@A|
	DCD	|?_SIHEntry_MADC@@3USIHEntry_t@@A|
	DCD	|?_SIHEntry_USB@@3USIHEntry_t@@A|
	DCD	|?_SIHEntry_Power@@3USIHEntry_t@@A|
	DCD	0x0

  00000			 AREA	 |.rdata|, DATA, READONLY
|DEVICE_IFC_TWL_GUID| DCD 0xdef0a04b
	DCW	0xb967
	DCW	0x43db
	DCB	0x95
	DCB	0x9e
	DCB	0xd9
	DCB	0xfc
	DCB	0x62
	DCB	0x25
	DCB	0xcd
	DCB	0xeb
|s_deviceRegParams| DCD |??_C@_19IAPNKDAH@?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x64
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37138| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37135|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37136|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentProcess|

  00000			 AREA	 |.pdata|, PDATA
|$T37147| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcess| PROC

; 361  : _inline HANDLE GetCurrentProcess(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M37144|

; 362  : 	return ((HANDLE)(SH_CURPROC+SYS_HANDLE_BASE));

  00000	e3a00042	 mov         r0, #0x42

; 363  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37145|

			 ENDP  ; |GetCurrentProcess|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|

  00000			 AREA	 |.pdata|, PDATA
|$T37156| DCD	|$LN5@GetCurrent@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37153|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37154|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|?IsEqualGUID@@YAHABU_GUID@@0@Z|	; IsEqualGUID
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\objbase.h

  00000			 AREA	 |.pdata|, PDATA
|$T37170| DCD	|$LN7@IsEqualGUI|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsEqualGUID@@YAHABU_GUID@@0@Z| PROC	; IsEqualGUID

; 493  : {

  00000		 |$LN7@IsEqualGUI|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37167|

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00004	e3a02010	 mov         r2, #0x10
  00008	eb000000	 bl          memcmp
  0000c	e3500000	 cmp         r0, #0
  00010	03a00001	 moveq       r0, #1

; 495  : }

  00014	049de004	 ldreq       lr, [sp], #4

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00018	13a00000	 movne       r0, #0

; 495  : }

  0001c	149de004	 ldrne       lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M37168|

			 ENDP  ; |?IsEqualGUID@@YAHABU_GUID@@0@Z|, IsEqualGUID

	EXPORT	|?GetFirstEventByGroup@@YAPAPAXPAUDevice_t@@K@Z| ; GetFirstEventByGroup
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37182| DCD	|$LN13@GetFirstEv|
	DCD	0x40001a00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFirstEventByGroup@@YAPAPAXPAUDevice_t@@K@Z| PROC ; GetFirstEventByGroup

; 248  : {

  00000		 |$LN13@GetFirstEv|
  00000		 |$M37179|
  00000	e3510000	 cmp         r1, #0
  00004	e1a03000	 mov         r3, r0

; 249  :     HANDLE *pEvent = NULL;

  00008	e3a00000	 mov         r0, #0

; 250  :     switch (group)

  0000c	0a000013	 beq         |$LN6@GetFirstEv|
  00010	e3510001	 cmp         r1, #1
  00014	0a00000f	 beq         |$LN5@GetFirstEv|
  00018	e3510002	 cmp         r1, #2
  0001c	0a00000b	 beq         |$LN4@GetFirstEv|
  00020	e3510003	 cmp         r1, #3
  00024	0a000007	 beq         |$LN3@GetFirstEv|
  00028	e3510004	 cmp         r1, #4
  0002c	0a000003	 beq         |$LN2@GetFirstEv|
  00030	e3510005	 cmp         r1, #5
  00034	1a00000a	 bne         |$LN7@GetFirstEv|

; 266  :             break;
; 267  :         case 5:
; 268  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_PWRON);

  00038	e2830048	 add         r0, r3, #0x48

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  0003c	e12fff1e	 bx          lr
  00040		 |$LN2@GetFirstEv|

; 263  :             break;
; 264  :         case 4:
; 265  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_USB_RISE_IDGND);

  00040	e2830c01	 add         r0, r3, #1, 24

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  00044	e12fff1e	 bx          lr
  00048		 |$LN3@GetFirstEv|

; 260  :             break;
; 261  :         case 3:
; 262  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_MADC_RT);

  00048	e2830098	 add         r0, r3, #0x98

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  0004c	e12fff1e	 bx          lr
  00050		 |$LN4@GetFirstEv|

; 257  :             break;
; 258  :         case 2:
; 259  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_WOVF);

  00050	e2830068	 add         r0, r3, #0x68

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  00054	e12fff1e	 bx          lr
  00058		 |$LN5@GetFirstEv|

; 254  :             break;
; 255  :         case 1:
; 256  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_ITKPI);

  00058	e28300f0	 add         r0, r3, #0xF0

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@GetFirstEv|

; 251  :         {
; 252  :         case 0:
; 253  :             pEvent = pDevice->hSetIntrEvent + TWL_ARRAYINDEX(TWL_INTR_GPIO_0);

  00060	e28300a8	 add         r0, r3, #0xA8
  00064		 |$LN7@GetFirstEv|

; 269  :             break;
; 270  :         }
; 271  :     
; 272  :     return pEvent;
; 273  : }

  00064	e12fff1e	 bx          lr
  00068		 |$M37180|

			 ENDP  ; |?GetFirstEventByGroup@@YAPAPAXPAUDevice_t@@K@Z|, GetFirstEventByGroup

	EXPORT	|?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|	; ReadRegs
	IMPORT	|LeaveCriticalSection|
	IMPORT	|I2CRead|
	IMPORT	|I2CSetSlaveAddress|
	IMPORT	|BSPGetTritonSlaveAddress|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37196| DCD	|$LN8@ReadRegs|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z| PROC ; ReadRegs

; 289  : {

  00000		 |$LN8@ReadRegs|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37193|
  00004	e1a07003	 mov         r7, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a04000	 mov         r4, r0

; 290  :     BOOL rc = FALSE;
; 291  : 
; 292  :     EnterCriticalSection(&pDevice->cs);

  00014	e2840018	 add         r0, r4, #0x18
  00018	e3a05000	 mov         r5, #0
  0001c	eb000000	 bl          EnterCriticalSection

; 293  :     // set slave address if necessary
; 294  :     if (pDevice->slaveAddress != HIWORD(address))

  00020	e594e02c	 ldr         lr, [r4, #0x2C]
  00024	e1a06828	 mov         r6, r8, lsr #16
  00028	e15e0006	 cmp         lr, r6
  0002c	0a000006	 beq         |$LN3@ReadRegs|

; 295  :         {
; 296  :         I2CSetSlaveAddress(pDevice->hI2C, BSPGetTritonSlaveAddress() | HIWORD(address));        

  00030	eb000000	 bl          BSPGetTritonSlaveAddress
  00034	e180e006	 orr         lr, r0, r6
  00038	e5940010	 ldr         r0, [r4, #0x10]
  0003c	e1a0180e	 mov         r1, lr, lsl #16
  00040	e1a01821	 mov         r1, r1, lsr #16
  00044	eb000000	 bl          I2CSetSlaveAddress

; 297  :         pDevice->slaveAddress = HIWORD(address);

  00048	e584602c	 str         r6, [r4, #0x2C]
  0004c		 |$LN3@ReadRegs|

; 298  :         }
; 299  : 
; 300  :     if (I2CRead(pDevice->hI2C, (UCHAR)address, pBuffer, size) != size)

  0004c	e5940010	 ldr         r0, [r4, #0x10]
  00050	e1a03007	 mov         r3, r7
  00054	e1a02009	 mov         r2, r9
  00058	e20810ff	 and         r1, r8, #0xFF
  0005c	eb000000	 bl          I2CRead
  00060	e1500007	 cmp         r0, r7

; 301  :         {
; 302  :         goto cleanUp;
; 303  :         }
; 304  :     
; 305  :     // We succceded
; 306  :     rc = TRUE;

  00064	03a05001	 moveq       r5, #1
  00068		 |$cleanUp$36430|

; 307  : 
; 308  : cleanUp:    
; 309  :     LeaveCriticalSection(&pDevice->cs);

  00068	e2840018	 add         r0, r4, #0x18
  0006c	eb000000	 bl          LeaveCriticalSection

; 310  :     return rc;
; 311  : }

  00070	e1a00005	 mov         r0, r5
  00074	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M37194|

			 ENDP  ; |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|, ReadRegs

	EXPORT	|?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|	; WriteRegs
	IMPORT	|I2CWrite|

  00000			 AREA	 |.pdata|, PDATA
|$T37210| DCD	|$LN8@WriteRegs|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z| PROC ; WriteRegs

; 327  : {

  00000		 |$LN8@WriteRegs|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37207|
  00004	e1a07003	 mov         r7, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a04000	 mov         r4, r0

; 328  :     BOOL rc = FALSE;
; 329  : 
; 330  :     EnterCriticalSection(&pDevice->cs);

  00014	e2840018	 add         r0, r4, #0x18
  00018	e3a05000	 mov         r5, #0
  0001c	eb000000	 bl          EnterCriticalSection

; 331  : 
; 332  :     // set slave address if necessary
; 333  :     if (pDevice->slaveAddress != HIWORD(address))

  00020	e594e02c	 ldr         lr, [r4, #0x2C]
  00024	e1a06828	 mov         r6, r8, lsr #16
  00028	e15e0006	 cmp         lr, r6
  0002c	0a000006	 beq         |$LN3@WriteRegs|

; 334  :         {
; 335  :         I2CSetSlaveAddress(pDevice->hI2C, BSPGetTritonSlaveAddress() | HIWORD(address));        

  00030	eb000000	 bl          BSPGetTritonSlaveAddress
  00034	e180e006	 orr         lr, r0, r6
  00038	e5940010	 ldr         r0, [r4, #0x10]
  0003c	e1a0180e	 mov         r1, lr, lsl #16
  00040	e1a01821	 mov         r1, r1, lsr #16
  00044	eb000000	 bl          I2CSetSlaveAddress

; 336  :         pDevice->slaveAddress = HIWORD(address);

  00048	e584602c	 str         r6, [r4, #0x2C]
  0004c		 |$LN3@WriteRegs|

; 337  :         }
; 338  : 
; 339  :     if (I2CWrite(pDevice->hI2C, (UCHAR)address, pBuffer, size) != size)

  0004c	e5940010	 ldr         r0, [r4, #0x10]
  00050	e1a03007	 mov         r3, r7
  00054	e1a02009	 mov         r2, r9
  00058	e20810ff	 and         r1, r8, #0xFF
  0005c	eb000000	 bl          I2CWrite
  00060	e1500007	 cmp         r0, r7

; 340  :         {
; 341  :         goto cleanUp;
; 342  :         }   
; 343  : 
; 344  :     // We succceded
; 345  :     rc = TRUE;

  00064	03a05001	 moveq       r5, #1
  00068		 |$cleanUp$36448|

; 346  : 
; 347  : cleanUp:  
; 348  :     LeaveCriticalSection(&pDevice->cs);

  00068	e2840018	 add         r0, r4, #0x18
  0006c	eb000000	 bl          LeaveCriticalSection

; 349  :     return rc;
; 350  : }

  00070	e1a00005	 mov         r0, r5
  00074	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M37208|

			 ENDP  ; |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|, WriteRegs

	EXPORT	|?WriteKeypadMatrixQueue@@YAHQAEPAX@Z|	; WriteKeypadMatrixQueue
	IMPORT	|InterlockedIncrement|
	IMPORT	|memcpy|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37229| DCD	|$LN13@WriteKeypa|
	DCD	0x40001c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteKeypadMatrixQueue@@YAHQAEPAX@Z| PROC ; WriteKeypadMatrixQueue

; 363  : {    

  00000		 |$LN13@WriteKeypa|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37226|
  00004	e1a05001	 mov         r5, r1

; 364  :     DEBUGMSG(ZONE_INFO, 
; 365  :         (L"WriteKeypadMatrixQueue:_nKeypadMatrixQueueCount=%d, "
; 366  :          L"0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\r\n",
; 367  :          _nKeypadMatrixQueueCount, matrix[0], matrix[1], matrix[2], 
; 368  :          matrix[3], matrix[4], matrix[5], matrix[6], matrix[7]
; 369  :         ));
; 370  :     
; 371  :     if (_nKeypadMatrixQueueCount < MATRIX_QUEUE_SIZE)

  00008	e59f605c	 ldr         r6, [pc, #0x5C]
  0000c	e5963088	 ldr         r3, [r6, #0x88]
  00010	e3530010	 cmp         r3, #0x10
  00014	aa00000f	 bge         |$LN3@WriteKeypa|

; 372  :         {
; 373  :         memcpy(_rgKeypadMatrixQueue[_nKeypadMatrixQueueTail], matrix,  TWL_KEYPAD_ROWS);

  00018	e5964084	 ldr         r4, [r6, #0x84]
  0001c	e1a01000	 mov         r1, r0
  00020	e3a02008	 mov         r2, #8
  00024	e0860184	 add         r0, r6, r4, lsl #3
  00028	eb000000	 bl          memcpy

; 374  :         _nKeypadMatrixQueueTail = (_nKeypadMatrixQueueTail + 1) % MATRIX_QUEUE_SIZE;

  0002c	e2843001	 add         r3, r4, #1
  00030	e203300f	 and         r3, r3, #0xF

; 375  :         
; 376  :         InterlockedIncrement(&_nKeypadMatrixQueueCount);

  00034	e2860088	 add         r0, r6, #0x88
  00038	e5863084	 str         r3, [r6, #0x84]
  0003c	eb000000	 bl          InterlockedIncrement
  00040		 |$LN10@WriteKeypa|

; 377  :         
; 378  :         SetEvent(hKeypadEvent);

  00040	e3a01003	 mov         r1, #3
  00044	e1a00005	 mov         r0, r5
  00048	eb000000	 bl          EventModify

; 379  :         return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 391  : }

  00050	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN3@WriteKeypa|

; 380  :         }
; 381  :     else if (hKeypadEvent != NULL)

  00058	e3550000	 cmp         r5, #0

; 382  :         {
; 383  :         // keypad matrix queue is full so just signal keypad listener
; 384  :         // and throw-away the character
; 385  :         SetEvent(hKeypadEvent);
; 386  :         return TRUE;

  0005c	1afffff7	 bne         |$LN10@WriteKeypa|

; 387  :         }
; 388  : 
; 389  :     
; 390  :     return FALSE;

  00060	e3a00000	 mov         r0, #0

; 391  : }

  00064	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN14@WriteKeypa|
  0006c		 |$LN15@WriteKeypa|
  0006c	00000000	 DCD         |?_rgKeypadMatrixQueue@@3PAY07EA|
  00070		 |$M37227|

			 ENDP  ; |?WriteKeypadMatrixQueue@@YAHQAEPAX@Z|, WriteKeypadMatrixQueue

	EXPORT	|?ReadKeypadMatrixQueue@@YAHQAEPAX@Z|	; ReadKeypadMatrixQueue
	IMPORT	|InterlockedDecrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37245| DCD	|$LN9@ReadKeypad|
	DCD	0x40001c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadKeypadMatrixQueue@@YAHQAEPAX@Z| PROC ; ReadKeypadMatrixQueue

; 404  : {

  00000		 |$LN9@ReadKeypad|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37242|
  00004	e1a05001	 mov         r5, r1

; 405  :     DEBUGMSG(ZONE_INFO, 
; 406  :         (L"ReadKeypadMatrixQueue:_nKeypadMatrixQueueCount=%d, "
; 407  :          L"0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\r\n",
; 408  :          _nKeypadMatrixQueueCount, matrix[0], matrix[1], matrix[2], 
; 409  :          matrix[3], matrix[4], matrix[5], matrix[6], matrix[7]
; 410  :         ));
; 411  :     
; 412  :     if (_nKeypadMatrixQueueCount > 0)

  00008	e59f405c	 ldr         r4, [pc, #0x5C]
  0000c	e5943088	 ldr         r3, [r4, #0x88]
  00010	e3530000	 cmp         r3, #0
  00014	da000011	 ble         |$LN2@ReadKeypad|

; 413  :         {
; 414  :         memcpy(matrix, _rgKeypadMatrixQueue[_nKeypadMatrixQueueHead], TWL_KEYPAD_ROWS);

  00018	e5943080	 ldr         r3, [r4, #0x80]
  0001c	e3a02008	 mov         r2, #8
  00020	e0841183	 add         r1, r4, r3, lsl #3
  00024	eb000000	 bl          memcpy

; 415  :         _nKeypadMatrixQueueHead = (_nKeypadMatrixQueueHead + 1) % MATRIX_QUEUE_SIZE;

  00028	e5943080	 ldr         r3, [r4, #0x80]

; 416  :         
; 417  :         InterlockedDecrement(&_nKeypadMatrixQueueCount);

  0002c	e2840088	 add         r0, r4, #0x88
  00030	e2833001	 add         r3, r3, #1
  00034	e203300f	 and         r3, r3, #0xF
  00038	e5843080	 str         r3, [r4, #0x80]
  0003c	eb000000	 bl          InterlockedDecrement

; 418  : 
; 419  :         // indicate more data is available
; 420  :         if (_nKeypadMatrixQueueCount > 0) SetEvent(hKeypadEvent);

  00040	e5943088	 ldr         r3, [r4, #0x88]
  00044	e3530000	 cmp         r3, #0
  00048	c3a01003	 movgt       r1, #3
  0004c	c1a00005	 movgt       r0, r5
  00050	cb000000	 blgt        EventModify

; 421  :         return TRUE;

  00054	e3a00001	 mov         r0, #1

; 426  : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN2@ReadKeypad|

; 422  :         }
; 423  :     
; 424  :     // return number of items in the queue
; 425  :     return FALSE;

  00060	e3a00000	 mov         r0, #0

; 426  : }

  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN10@ReadKeypad|
  0006c		 |$LN11@ReadKeypad|
  0006c	00000000	 DCD         |?_rgKeypadMatrixQueue@@3PAY07EA|
  00070		 |$M37243|

			 ENDP  ; |?ReadKeypadMatrixQueue@@YAHQAEPAX@Z|, ReadKeypadMatrixQueue

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SendPBMessage@@YAHPAUDevice_t@@EE@Z|	; SendPBMessage
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T37267| DCD	|$LN11@SendPBMess|
	DCD	0xc0003102

  00000			 AREA	 |.xdata|, DATA
|$T37263| DCD	0xffffffec
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37263|

  00008		 |?SendPBMessage@@YAHPAUDevice_t@@EE@Z| PROC ; SendPBMessage

; 439  : {

  00008		 |$LN11@SendPBMess|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M37264|
  00010	e1a04002	 mov         r4, r2
  00014	e1a06001	 mov         r6, r1
  00018	e1a05000	 mov         r5, r0
  0001c	e59f30a4	 ldr         r3, [pc, #0xA4]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3008	 str         r3, [sp, #8]
  00028	e3a03803	 mov         r3, #3, 16

; 440  :     UINT16 pb_message;
; 441  :     UINT8 data[5];
; 442  :     
; 443  :     data[0] = 0x02; // Enable I2C access to the Power Bus 
; 444  :     if(!WriteRegs(pDevice, TWL_PB_CFG, data, 1))

  0002c	e383104a	 orr         r1, r3, #0x4A
  00030	e3a0e002	 mov         lr, #2
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e5cde000	 strb        lr, [sp]
  00040	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00044	e3500000	 cmp         r0, #0
  00048	0a000018	 beq         |$cleanUp$36474|

; 445  :         goto cleanUp;
; 446  :     
; 447  :     // Form the message for VDAC 
; 448  :     pb_message = TwlTargetMessage(TWL_PROCESSOR_GRP1, power_res_id, res_state);

  0004c	e3863c02	 orr         r3, r6, #2, 24
  00050	e1844203	 orr         r4, r4, r3, lsl #4

; 449  :     
; 450  :     // Extract the Message MSB 
; 451  :     data[0] = (UINT8) (pb_message >> 8);

  00054	e1a03424	 mov         r3, r4, lsr #8
  00058	e3a01803	 mov         r1, #3, 16
  0005c	e5cd3000	 strb        r3, [sp]

; 452  :     if(!WriteRegs(pDevice, TWL_PB_WORD_MSB, data, 1))

  00060	e3a03001	 mov         r3, #1
  00064	e28d2000	 add         r2, sp, #0
  00068	e381104b	 orr         r1, r1, #0x4B
  0006c	e1a00005	 mov         r0, r5
  00070	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00074	e3500000	 cmp         r0, #0
  00078	0a00000c	 beq         |$cleanUp$36474|
  0007c	e3a03803	 mov         r3, #3, 16

; 453  :         goto cleanUp;
; 454  :     
; 455  :     // Extract the Message LSB 
; 456  :     data[0] = (UINT8) (pb_message & 0x00FF);
; 457  :     if(!WriteRegs(pDevice, TWL_PB_WORD_LSB, data, 1))

  00080	e383104c	 orr         r1, r3, #0x4C
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	e1a00005	 mov         r0, r5
  00090	e5cd4000	 strb        r4, [sp]
  00094	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00098	e3500000	 cmp         r0, #0
  0009c	0a000003	 beq         |$cleanUp$36474|

; 458  :         goto cleanUp;
; 459  :     
; 460  :     return (TRUE);

  000a0	e59d0008	 ldr         r0, [sp, #8]
  000a4	eb000000	 bl          __security_check_cookie
  000a8	e3a00001	 mov         r0, #1
  000ac	ea000002	 b           |$LN7@SendPBMess|
  000b0		 |$cleanUp$36474|

; 461  :     
; 462  : cleanUp:
; 463  :     return FALSE;    

  000b0	e59d0008	 ldr         r0, [sp, #8]
  000b4	eb000000	 bl          __security_check_cookie
  000b8	e3a00000	 mov         r0, #0
  000bc		 |$LN7@SendPBMess|

; 464  : }

  000bc	e28dd00c	 add         sp, sp, #0xC
  000c0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$LN12@SendPBMess|
  000c8		 |$LN13@SendPBMess|
  000c8	00000000	 DCD         |__security_cookie|
  000cc		 |$M37265|

			 ENDP  ; |?SendPBMessage@@YAHPAUDevice_t@@EE@Z|, SendPBMessage

	EXPORT	|?InitializeHardware@@YAHPAUDevice_t@@@Z| ; InitializeHardware

  00000			 AREA	 |.pdata|, PDATA
|$T37280| DCD	|$LN5@Initialize|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializeHardware@@YAHPAUDevice_t@@@Z| PROC ; InitializeHardware

; 477  : {

  00000		 |$LN5@Initialize|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37277|
  00004	e1a04000	 mov         r4, r0

; 478  :     // Enable LDO for T2 PHY
; 479  :     SendPBMessage(pDevice, TWL_VUSB_3V1_RES_ID, TWL_RES_ACTIVE);

  00008	e3a0200e	 mov         r2, #0xE
  0000c	e3a01013	 mov         r1, #0x13
  00010	eb000000	 bl          |?SendPBMessage@@YAHPAUDevice_t@@EE@Z|

; 480  :     SendPBMessage(pDevice, TWL_VUSB_1V5_RES_ID, TWL_RES_ACTIVE);

  00014	e3a0200e	 mov         r2, #0xE
  00018	e3a01011	 mov         r1, #0x11
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?SendPBMessage@@YAHPAUDevice_t@@EE@Z|

; 481  :     SendPBMessage(pDevice, TWL_VUSB_1V8_RES_ID, TWL_RES_ACTIVE);

  00024	e3a0200e	 mov         r2, #0xE
  00028	e3a01012	 mov         r1, #0x12
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          |?SendPBMessage@@YAHPAUDevice_t@@EE@Z|

; 482  : 
; 483  :     return TRUE;

  00034	e3a00001	 mov         r0, #1

; 484  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M37278|

			 ENDP  ; |?InitializeHardware@@YAHPAUDevice_t@@@Z|, InitializeHardware

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?ProcessSecondaryInterrupts_USB@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| ; ProcessSecondaryInterrupts_USB
	IMPORT	|SetEventData|
	IMPORT	|Sleep|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37301| DCD	|$LN9@ProcessSec|
	DCD	0xc0004602

  00000			 AREA	 |.xdata|, DATA
|$T37297| DCD	0xffffffec
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37297|

  00008		 |?ProcessSecondaryInterrupts_USB@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| PROC ; ProcessSecondaryInterrupts_USB

; 498  : {    

  00008		 |$LN9@ProcessSec|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M37298|
  00010	e1a05001	 mov         r5, r1
  00014	e1a04000	 mov         r4, r0
  00018	e59f30fc	 ldr         r3, [pc, #0xFC]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3008	 str         r3, [sp, #8]

; 499  :     // PIH and SIH will be cleared by reading the LATCH registers.
; 500  :     // Since USB driver will handle all the possible interrupts,
; 501  :     // the interrupts bits are passed to usb driver by event data.
; 502  :     BYTE data[] = {0, 0, 0, 0, 0, 0};

  00024	e3a00000	 mov         r0, #0
  00028	e5cd0003	 strb        r0, [sp, #3]
  0002c	e3a03000	 mov         r3, #0
  00030	e3a02000	 mov         r2, #0
  00034	e3a01000	 mov         r1, #0
  00038	e3a0e000	 mov         lr, #0
  0003c	e3a06000	 mov         r6, #0

; 503  : 
; 504  :     UNREFERENCED_PARAMETER(pSIHEntry);
; 505  : 
; 506  :     // Debounce for 5 ms
; 507  :     Sleep(5);

  00040	e3a00005	 mov         r0, #5
  00044	e5cd3000	 strb        r3, [sp]
  00048	e5cd2001	 strb        r2, [sp, #1]
  0004c	e5cd1002	 strb        r1, [sp, #2]
  00050	e5cde004	 strb        lr, [sp, #4]
  00054	e5cd6005	 strb        r6, [sp, #5]
  00058	eb000000	 bl          Sleep

; 508  :     DWORD ed = 0;
; 509  : 
; 510  :     // Clear all intrrupts
; 511  :     ReadRegs(pDevice, TWL_USB_INT_LATCH, &data[0], 1);

  0005c	e3a03001	 mov         r3, #1
  00060	e28d2000	 add         r2, sp, #0
  00064	e3a01014	 mov         r1, #0x14
  00068	e1a00004	 mov         r0, r4
  0006c	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 512  :     ReadRegs(pDevice, TWL_OTHER_INT_LATCH, &data[1], 1);

  00070	e3a03001	 mov         r3, #1
  00074	e28d2001	 add         r2, sp, #1
  00078	e3a0108d	 mov         r1, #0x8D
  0007c	e1a00004	 mov         r0, r4
  00080	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 513  :     ReadRegs(pDevice, TWL_CARKIT_INT_LATCH, &data[2], 1);

  00084	e3a03001	 mov         r3, #1
  00088	e28d2002	 add         r2, sp, #2
  0008c	e3a01021	 mov         r1, #0x21
  00090	e1a00004	 mov         r0, r4
  00094	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 514  :     ReadRegs(pDevice, TWL_CARKIT_SM_1_INT_LATCH, &data[3], 1);

  00098	e3a03001	 mov         r3, #1
  0009c	e28d2003	 add         r2, sp, #3
  000a0	e3a0109b	 mov         r1, #0x9B
  000a4	e1a00004	 mov         r0, r4
  000a8	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 515  :     ReadRegs(pDevice, TWL_CARKIT_SM_2_INT_LATCH, &data[4], 1);

  000ac	e3a03001	 mov         r3, #1
  000b0	e28d2004	 add         r2, sp, #4
  000b4	e3a010a0	 mov         r1, #0xA0
  000b8	e1a00004	 mov         r0, r4
  000bc	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 516  :     ReadRegs(pDevice, TWL_REG_CTRL_ERROR, &data[5], 1);

  000c0	e3a03001	 mov         r3, #1
  000c4	e28d2005	 add         r2, sp, #5
  000c8	e3a010b5	 mov         r1, #0xB5
  000cc	e1a00004	 mov         r0, r4
  000d0	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 517  : 
; 518  :     //RETAILMSG(1, (TEXT("ProcessSecondaryInterrupts USB_INT (0x%x), OTHER_INT (0x%x)\r\n"),
; 519  :     //    data[0], data[1]));
; 520  :     // Currently only USB and OTHER intrs are handled
; 521  :     ed = (data[1] << 8) + data[0];
; 522  :     if ((*rgEvents != NULL) && (*rgEvents != INVALID_HANDLE_VALUE))

  000d4	e5953000	 ldr         r3, [r5]
  000d8	e1b00003	 movs        r0, r3
  000dc	0a000008	 beq         |$LN2@ProcessSec|
  000e0	e3700001	 cmn         r0, #1
  000e4	0a000006	 beq         |$LN2@ProcessSec|
  000e8	e5dd2001	 ldrb        r2, [sp, #1]
  000ec	e5dd3000	 ldrb        r3, [sp]

; 523  :         {
; 524  :         SetEventData(*rgEvents, ed);

  000f0	e0831402	 add         r1, r3, r2, lsl #8
  000f4	eb000000	 bl          SetEventData

; 525  :         SetEvent(*rgEvents);

  000f8	e5950000	 ldr         r0, [r5]
  000fc	e3a01003	 mov         r1, #3
  00100	eb000000	 bl          EventModify
  00104		 |$LN2@ProcessSec|

; 526  :         }
; 527  :     else
; 528  :         {
; 529  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: ProcessSecondaryInterrupts_USB: "
; 530  :             L"Invalid event handle."
; 531  :             ));
; 532  :         }
; 533  : 
; 534  :     return TRUE;

  00104	e59d0008	 ldr         r0, [sp, #8]
  00108	eb000000	 bl          __security_check_cookie
  0010c	e3a00001	 mov         r0, #1

; 535  : }

  00110	e28dd00c	 add         sp, sp, #0xC
  00114	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$LN10@ProcessSec|
  0011c		 |$LN11@ProcessSec|
  0011c	00000000	 DCD         |__security_cookie|
  00120		 |$M37299|

			 ENDP  ; |?ProcessSecondaryInterrupts_USB@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|, ProcessSecondaryInterrupts_USB

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?ProcessSecondaryInterrupts_Keypad@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| ; ProcessSecondaryInterrupts_Keypad
	EXPORT	|??_C@_1JE@MPDFOMGM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAS?$AAe?$AAc?$AAo?$AAn?$AAd?$AAa?$AAr?$AAy?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T37327| DCD	|$LN8@ProcessSec@2|
	DCD	0xc0002f02

  00000			 AREA	 |.xdata|, DATA
|$T37323| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JE@MPDFOMGM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAS?$AAe?$AAc?$AAo?$AAn?$AAd?$AAa?$AAr?$AAy?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "P", 0x0, "r", 0x0, "o", 0x0, "c", 0x0, "e", 0x0, "s"
	DCB	0x0, "s", 0x0, "S", 0x0, "e", 0x0, "c", 0x0, "o", 0x0, "n"
	DCB	0x0, "d", 0x0, "a", 0x0, "r", 0x0, "y", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p"
	DCB	0x0, "t", 0x0, "s", 0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t"
	DCB	0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d"
	DCB	0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u"
	DCB	0x0, "s", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i"
	DCB	0x0, "s", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "(", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, ")"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37323|

  00008		 |?ProcessSecondaryInterrupts_Keypad@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| PROC ; ProcessSecondaryInterrupts_Keypad

; 550  : {

  00008		 |$LN8@ProcessSec@2|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M37324|
  00010	e1a04002	 mov         r4, r2
  00014	e1a06001	 mov         r6, r1
  00018	e1a05000	 mov         r5, r0
  0001c	e59f309c	 ldr         r3, [pc, #0x9C]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d300c	 str         r3, [sp, #0xC]

; 551  :     UINT8 status;
; 552  :     UINT8 matrix[TWL_KEYPAD_ROWS];
; 553  :     
; 554  :     // loop through all status registers for the secondary interrupt handler
; 555  :     StatusRegister_t const* pStatusRegister = &pSIHEntry->StatusRegisters[0];
; 556  :     
; 557  :     // get status of secondary interrupt
; 558  :     if (ReadRegs(pDevice, pStatusRegister->statusSubaddress, &status, 
; 559  :         sizeof(status)) == FALSE)

  00028	e5b41004	 ldr         r1, [r4, #4]!
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2000	 add         r2, sp, #0
  00034	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|
  00038	e3500000	 cmp         r0, #0
  0003c	1a000009	 bne         |$LN1@ProcessSec@2|

; 560  :         {
; 561  :         RETAILMSG(ZONE_ERROR, (L"ERROR: ProcessSecondaryInterrupts: "
; 562  :             L"Failed to read status register(0x%08X)",
; 563  :             pStatusRegister->statusSubaddress
; 564  :             ));

  00040	e59f3074	 ldr         r3, [pc, #0x74]
  00044	e5933440	 ldr         r3, [r3, #0x440]
  00048	e3130001	 tst         r3, #1
  0004c	15941000	 ldrne       r1, [r4]
  00050	159f0060	 ldrne       r0, [pc, #0x60]
  00054	1b000000	 blne        NKDbgPrintfW

; 565  :         return FALSE;

  00058	e59d000c	 ldr         r0, [sp, #0xC]
  0005c	eb000000	 bl          __security_check_cookie
  00060	e3a00000	 mov         r0, #0
  00064	ea000010	 b           |$LN2@ProcessSec@2|
  00068		 |$LN1@ProcessSec@2|
  00068	e3a03802	 mov         r3, #2, 16

; 566  :         };
; 567  : 
; 568  :     DEBUGMSG(ZONE_INFO | ZONE_IST, (L"INFO: ProcessSecondaryInterrupts "
; 569  :         L"secondary status=0x%02X; tick=%d\r\n", status, GetTickCount()
; 570  :         ));
; 571  : 
; 572  :     // read TWL_KEYPAD_ROWS amount of rows...
; 573  :     ReadRegs(pDevice, TWL_FULL_CODE_7_0, matrix, TWL_KEYPAD_ROWS);

  0006c	e38310db	 orr         r1, r3, #0xDB
  00070	e3a03008	 mov         r3, #8
  00074	e28d2004	 add         r2, sp, #4
  00078	e1a00005	 mov         r0, r5
  0007c	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 574  :     WriteKeypadMatrixQueue(matrix, *rgEvents);

  00080	e5961000	 ldr         r1, [r6]
  00084	e28d0004	 add         r0, sp, #4
  00088	eb000000	 bl          |?WriteKeypadMatrixQueue@@YAHQAEPAX@Z|

; 575  :     WriteRegs(pDevice, pStatusRegister->statusSubaddress, &status, sizeof(status));

  0008c	e5941000	 ldr         r1, [r4]
  00090	e3a03001	 mov         r3, #1
  00094	e28d2000	 add         r2, sp, #0
  00098	e1a00005	 mov         r0, r5
  0009c	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 576  : 
; 577  :     return TRUE;

  000a0	e59d000c	 ldr         r0, [sp, #0xC]
  000a4	eb000000	 bl          __security_check_cookie
  000a8	e3a00001	 mov         r0, #1
  000ac		 |$LN2@ProcessSec@2|

; 578  : }

  000ac	e28dd010	 add         sp, sp, #0x10
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN9@ProcessSec@2|
  000b8		 |$LN10@ProcessSec@2|
  000b8	00000000	 DCD         |??_C@_1JE@MPDFOMGM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAS?$AAe?$AAc?$AAo?$AAn?$AAd?$AAa?$AAr?$AAy?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@|
  000bc		 |$LN11@ProcessSec@2|
  000bc	00000000	 DCD         |dpCurSettings|
  000c0		 |$LN12@ProcessSec@2|
  000c0	00000000	 DCD         |__security_cookie|
  000c4		 |$M37325|

			 ENDP  ; |?ProcessSecondaryInterrupts_Keypad@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|, ProcessSecondaryInterrupts_Keypad

	EXPORT	|?ProcessSecondaryInterrupts@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| ; ProcessSecondaryInterrupts
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37361| DCD	|$LN23@ProcessSec@3|
	DCD	0x40004002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProcessSecondaryInterrupts@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z| PROC ; ProcessSecondaryInterrupts

; 593  : {

  00000		 |$LN23@ProcessSec@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37358|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a08000	 mov         r8, r0

; 594  :     UINT8 status;
; 595  :     UINT8 clearMask;    
; 596  :     int interruptCount;
; 597  :     int statusRegisterIndex = 0;
; 598  :     StatusRegister_t const* pStatusRegister;
; 599  :     
; 600  :     // loop through all status registers for the secondary interrupt handler
; 601  :     pStatusRegister = &pSIHEntry->StatusRegisters[statusRegisterIndex];

  00010	e2824004	 add         r4, r2, #4

; 602  :     while (pStatusRegister->interruptCount > 0)

  00014	e594300c	 ldr         r3, [r4, #0xC]
  00018	e3530000	 cmp         r3, #0
  0001c	9a000031	 bls         |$LN10@ProcessSec@3|
  00020	e1a05004	 mov         r5, r4
  00024		 |$LL7@ProcessSec@3|

; 603  :         {
; 604  :         // get status of secondary interrupt
; 605  :         if (ReadRegs(pDevice, pStatusRegister->statusSubaddress, &status, 
; 606  :             sizeof(status)) == FALSE)

  00024	e5941000	 ldr         r1, [r4]
  00028	e3a03001	 mov         r3, #1
  0002c	e28d2000	 add         r2, sp, #0
  00030	e1a00008	 mov         r0, r8
  00034	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|
  00038	e3500000	 cmp         r0, #0
  0003c	0a000023	 beq         |$LN16@ProcessSec@3|

; 612  :             break;
; 613  :             };
; 614  : 
; 615  :         DEBUGMSG(ZONE_INFO | ZONE_IST, (L"INFO: ProcessSecondaryInterrupts "
; 616  :             L"secondary status=0x%02X; tick=%d\r\n", status, GetTickCount()
; 617  :             ));
; 618  : 
; 619  :         // loop through and signal relevant events
; 620  :         clearMask = status;
; 621  :         interruptCount = pStatusRegister->interruptCount;

  00040	e594300c	 ldr         r3, [r4, #0xC]
  00044	e5dd2000	 ldrb        r2, [sp]
  00048	e1b06003	 movs        r6, r3
  0004c	e5cd2001	 strb        r2, [sp, #1]

; 622  :         while (interruptCount-- && status != 0)

  00050	0a000012	 beq         |$LN17@ProcessSec@3|
  00054		 |$LL4@ProcessSec@3|
  00054	e2466001	 sub         r6, r6, #1
  00058	e1b03002	 movs        r3, r2
  0005c	0a00000e	 beq         |$LN20@ProcessSec@3|

; 623  :         {
; 624  :             if ((status & 0x01) && *rgEvents)

  00060	e3130001	 tst         r3, #1
  00064	0a000006	 beq         |$LN12@ProcessSec@3|
  00068	e5973000	 ldr         r3, [r7]
  0006c	e3530000	 cmp         r3, #0
  00070	0a000003	 beq         |$LN12@ProcessSec@3|

; 625  :             {
; 626  :                 SetEvent(*rgEvents);

  00074	e3a01003	 mov         r1, #3
  00078	e1a00003	 mov         r0, r3
  0007c	eb000000	 bl          EventModify
  00080	e5dd2000	 ldrb        r2, [sp]
  00084		 |$LN12@ProcessSec@3|

; 627  :             }
; 628  :             status >>= 1;

  00084	e1a030a2	 mov         r3, r2, lsr #1
  00088	e20320ff	 and         r2, r3, #0xFF
  0008c	e5cd2000	 strb        r2, [sp]

; 629  :             ++rgEvents;

  00090	e2877004	 add         r7, r7, #4
  00094	e3560000	 cmp         r6, #0
  00098	1affffed	 bne         |$LL4@ProcessSec@3|
  0009c		 |$LN20@ProcessSec@3|

; 622  :         while (interruptCount-- && status != 0)

  0009c	e5dd2001	 ldrb        r2, [sp, #1]
  000a0		 |$LN17@ProcessSec@3|

; 630  :         }
; 631  :         
; 632  :         // clear secondary interrupt handler for more events
; 633  :         if(clearMask)

  000a0	e3520000	 cmp         r2, #0

; 634  :             {
; 635  :             WriteRegs(pDevice, pStatusRegister->statusSubaddress, 
; 636  :                 &clearMask, sizeof(clearMask)
; 637  :                 );

  000a4	15941000	 ldrne       r1, [r4]
  000a8	13a03001	 movne       r3, #1
  000ac	128d2001	 addne       r2, sp, #1
  000b0	11a00008	 movne       r0, r8
  000b4	1b000000	 blne        |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 638  :             }
; 639  : 
; 640  :         // next status register
; 641  :         ++statusRegisterIndex;

  000b8	e2855010	 add         r5, r5, #0x10
  000bc	e595300c	 ldr         r3, [r5, #0xC]

; 642  :         pStatusRegister = &pSIHEntry->StatusRegisters[statusRegisterIndex];

  000c0	e1a04005	 mov         r4, r5
  000c4	e3530000	 cmp         r3, #0
  000c8	8affffd5	 bhi         |$LL7@ProcessSec@3|

; 603  :         {
; 604  :         // get status of secondary interrupt
; 605  :         if (ReadRegs(pDevice, pStatusRegister->statusSubaddress, &status, 
; 606  :             sizeof(status)) == FALSE)

  000cc	ea000005	 b           |$LN10@ProcessSec@3|
  000d0		 |$LN16@ProcessSec@3|

; 607  :             {
; 608  :             RETAILMSG(ZONE_ERROR, (L"ERROR: ProcessSecondaryInterrupts: "
; 609  :                 L"Failed to read status register(0x%08X)",
; 610  :                 pStatusRegister->statusSubaddress
; 611  :                 ));

  000d0	e59f3024	 ldr         r3, [pc, #0x24]
  000d4	e5933440	 ldr         r3, [r3, #0x440]
  000d8	e3130001	 tst         r3, #1
  000dc	15941000	 ldrne       r1, [r4]
  000e0	159f0010	 ldrne       r0, [pc, #0x10]
  000e4	1b000000	 blne        NKDbgPrintfW
  000e8		 |$LN10@ProcessSec@3|

; 643  :         }
; 644  : 
; 645  :     return TRUE;

  000e8	e3a00001	 mov         r0, #1

; 646  : }

  000ec	e28dd004	 add         sp, sp, #4
  000f0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN24@ProcessSec@3|
  000f8		 |$LN25@ProcessSec@3|
  000f8	00000000	 DCD         |??_C@_1JE@MPDFOMGM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAS?$AAe?$AAc?$AAo?$AAn?$AAd?$AAa?$AAr?$AAy?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@|
  000fc		 |$LN26@ProcessSec@3|
  000fc	00000000	 DCD         |dpCurSettings|
  00100		 |$M37359|

			 ENDP  ; |?ProcessSecondaryInterrupts@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|, ProcessSecondaryInterrupts

	EXPORT	|?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z| ; SetInterruptMode

  00000			 AREA	 |.pdata|, PDATA
|$T37412| DCD	|$LN61@SetInterru|
	DCD	0x40007602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z| PROC ; SetInterruptMode

; 660  : {  

  00000		 |$LN61@SetInterru|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37409|
  00008	e3510000	 cmp         r1, #0
  0000c	e1a07000	 mov         r7, r0

; 661  :     int i = 0;
; 662  :     int offset = 0;
; 663  :     UINT8 mask = 0xFF;
; 664  :     StatusRegister_t const *pStatusReg;
; 665  :     SIHEntry_t const *pEntry = s_pSIHEntries[0];

  00010	e59f61bc	 ldr         r6, [pc, #0x1BC]
  00014	e3a030ff	 mov         r3, #0xFF
  00018	e5cd3000	 strb        r3, [sp]
  0001c	e5964000	 ldr         r4, [r6]

; 666  :     switch (intrMode)

  00020	0a000040	 beq         |$LL23@SetInterru|
  00024	e3510001	 cmp         r1, #1
  00028	0a000016	 beq         |$LL14@SetInterru|
  0002c	e3510002	 cmp         r1, #2
  00030	1a000063	 bne         |$LN25@SetInterru|
  00034		 |$LL5@SetInterru|

; 753  : 
; 754  :         case kTritonIntrDisabled:
; 755  :             do
; 756  :                 {
; 757  :                 pStatusReg = pEntry->StatusRegisters;
; 758  :                 
; 759  :                 // USB has specific set/clr registers
; 760  :                 offset = (pEntry->ctrlSubaddress == 0) ? 2 : 0;

  00034	e5943000	 ldr         r3, [r4]
  00038	e2844004	 add         r4, r4, #4
  0003c	e3530000	 cmp         r3, #0
  00040	03a05002	 moveq       r5, #2
  00044	0a000008	 beq         |$LN34@SetInterru|
  00048	e3a05000	 mov         r5, #0

; 761  :                 while (pStatusReg->interruptCount)

  0004c	ea000006	 b           |$LN34@SetInterru|
  00050		 |$LL2@SetInterru|

; 762  :                     {
; 763  :                     WriteRegs(pDevice, pStatusReg->maskSubaddress + offset, 
; 764  :                         &mask, sizeof(UINT8)
; 765  :                         );

  00050	e5941004	 ldr         r1, [r4, #4]
  00054	e3a03001	 mov         r3, #1
  00058	e28d2000	 add         r2, sp, #0
  0005c	e0811005	 add         r1, r1, r5
  00060	e1a00007	 mov         r0, r7
  00064	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 766  :                     pStatusReg++;

  00068	e2844010	 add         r4, r4, #0x10
  0006c		 |$LN34@SetInterru|
  0006c	e594300c	 ldr         r3, [r4, #0xC]
  00070	e3530000	 cmp         r3, #0
  00074	1afffff5	 bne         |$LL2@SetInterru|

; 767  :                     }
; 768  :                 pEntry = s_pSIHEntries[++i];

  00078	e5b63004	 ldr         r3, [r6, #4]!
  0007c	e1b04003	 movs        r4, r3

; 769  :                 }
; 770  :                 while(pEntry);

  00080	1affffeb	 bne         |$LL5@SetInterru|

; 771  :             break;

  00084	ea00004e	 b           |$LN25@SetInterru|

; 706  :             break;
; 707  :             
; 708  :         case kTritonIntrWakeup:
; 709  :             do
; 710  :                 {
; 711  :                 pStatusReg = pEntry->StatusRegisters;

  00088		 |$LL14@SetInterru|

; 712  : 
; 713  :                 // For USB, there are separate set/clr registers.
; 714  :                 // So we need to make sure all interrupts which
; 715  :                 // aren't part of the wakeup interrupts are
; 716  :                 // in fact disabled before we start enabling wakeup
; 717  :                 // interrupts 
; 718  :                 if (pEntry->ctrlSubaddress == 0)

  00088	e5943000	 ldr         r3, [r4]
  0008c	e2845004	 add         r5, r4, #4
  00090	e3530000	 cmp         r3, #0
  00094	1a000013	 bne         |$LN31@SetInterru|

; 719  :                     {
; 720  :                     while (pStatusReg->interruptCount)

  00098	e5943010	 ldr         r3, [r4, #0x10]
  0009c	ea00000a	 b           |$LN55@SetInterru|
  000a0		 |$LL10@SetInterru|

; 721  :                         {
; 722  :                         // first clear interrupts which isn't part of wakeup
; 723  :                         mask = 0xFF & ~(pStatusReg->ffWakeupEnable);

  000a0	e5d51009	 ldrb        r1, [r5, #9]

; 724  :                         WriteRegs(pDevice, pStatusReg->maskSubaddress + 2,
; 725  :                             &mask, sizeof(UINT8));

  000a4	e3a03001	 mov         r3, #1
  000a8	e28d2000	 add         r2, sp, #0
  000ac	e1e01001	 mvn         r1, r1
  000b0	e5cd1000	 strb        r1, [sp]
  000b4	e5951004	 ldr         r1, [r5, #4]
  000b8	e1a00007	 mov         r0, r7
  000bc	e2811002	 add         r1, r1, #2
  000c0	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 726  :                         pStatusReg++;

  000c4	e2855010	 add         r5, r5, #0x10
  000c8	e595300c	 ldr         r3, [r5, #0xC]
  000cc		 |$LN55@SetInterru|
  000cc	e3530000	 cmp         r3, #0
  000d0	1afffff2	 bne         |$LL10@SetInterru|

; 727  :                         }
; 728  : 
; 729  :                     // point back to beginning of status register array
; 730  :                     // to start enabling wakeup interrupts
; 731  :                     pStatusReg = pEntry->StatusRegisters;
; 732  :                     }
; 733  : 
; 734  :                 // USB has specific set/clr registers
; 735  :                 offset = (pEntry->ctrlSubaddress == 0) ? 1 : 0;

  000d4	e5943000	 ldr         r3, [r4]
  000d8	e2845004	 add         r5, r4, #4
  000dc	e3530000	 cmp         r3, #0
  000e0	03a04001	 moveq       r4, #1
  000e4	0a000008	 beq         |$LN32@SetInterru|
  000e8		 |$LN31@SetInterru|
  000e8	e3a04000	 mov         r4, #0

; 736  :                 while (pStatusReg->interruptCount)

  000ec	ea000006	 b           |$LN32@SetInterru|
  000f0		 |$LL8@SetInterru|

; 737  :                     {
; 738  :                     DEBUGMSG(ZONE_INFO, (L"TWL:Setting Interrupt mode: "
; 739  :                         L"0x%02X, 0x%02X\r\n", 
; 740  :                         pStatusReg->maskSubaddress, pStatusReg->ffWakeupEnable
; 741  :                         ));
; 742  :                     
; 743  :                     WriteRegs(pDevice, pStatusReg->maskSubaddress + offset, 
; 744  :                         &pStatusReg->ffWakeupEnable, sizeof(UINT8)
; 745  :                         );

  000f0	e5951004	 ldr         r1, [r5, #4]
  000f4	e3a03001	 mov         r3, #1
  000f8	e2852009	 add         r2, r5, #9
  000fc	e0811004	 add         r1, r1, r4
  00100	e1a00007	 mov         r0, r7
  00104	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 746  :                     pStatusReg++;

  00108	e2855010	 add         r5, r5, #0x10
  0010c		 |$LN32@SetInterru|
  0010c	e595300c	 ldr         r3, [r5, #0xC]
  00110	e3530000	 cmp         r3, #0
  00114	1afffff5	 bne         |$LL8@SetInterru|

; 747  :                     }
; 748  :                 
; 749  :                 pEntry = s_pSIHEntries[++i];

  00118	e5b63004	 ldr         r3, [r6, #4]!
  0011c	e1b04003	 movs        r4, r3

; 750  :                 }
; 751  :                 while(pEntry);

  00120	1affffd8	 bne         |$LL14@SetInterru|

; 752  :             break;

  00124	ea000026	 b           |$LN25@SetInterru|

; 667  :         {
; 668  :         case kTritonIntrEnabled:
; 669  :             do
; 670  :                 {
; 671  :                 pStatusReg = pEntry->StatusRegisters;

  00128		 |$LL23@SetInterru|

; 672  : 
; 673  :                 // For USB, there are separate set/clr registers.
; 674  :                 // So we need to make sure all interrupts which
; 675  :                 // aren't part of the interrupts being enabled are
; 676  :                 // in fact disabled before we start enabling interrupts
; 677  :                 // which need to be enabled
; 678  :                 if (pEntry->ctrlSubaddress == 0)

  00128	e5943000	 ldr         r3, [r4]
  0012c	e2845004	 add         r5, r4, #4
  00130	e3530000	 cmp         r3, #0
  00134	1a000013	 bne         |$LN29@SetInterru|

; 679  :                     {
; 680  :                     while (pStatusReg->interruptCount)

  00138	e5943010	 ldr         r3, [r4, #0x10]
  0013c	ea00000a	 b           |$LN57@SetInterru|
  00140		 |$LL19@SetInterru|

; 681  :                         {
; 682  :                         mask = 0xFF & ~(pStatusReg->ffEnable);

  00140	e5d51008	 ldrb        r1, [r5, #8]

; 683  :                         WriteRegs(pDevice, pStatusReg->maskSubaddress + 2,
; 684  :                             &mask, sizeof(UINT8));

  00144	e3a03001	 mov         r3, #1
  00148	e28d2000	 add         r2, sp, #0
  0014c	e1e01001	 mvn         r1, r1
  00150	e5cd1000	 strb        r1, [sp]
  00154	e5951004	 ldr         r1, [r5, #4]
  00158	e1a00007	 mov         r0, r7
  0015c	e2811002	 add         r1, r1, #2
  00160	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 685  :                         pStatusReg++;

  00164	e2855010	 add         r5, r5, #0x10
  00168	e595300c	 ldr         r3, [r5, #0xC]
  0016c		 |$LN57@SetInterru|
  0016c	e3530000	 cmp         r3, #0
  00170	1afffff2	 bne         |$LL19@SetInterru|

; 686  :                         }
; 687  : 
; 688  :                     // point back to beginning of status register array
; 689  :                     // to start enabling interrupts
; 690  :                     pStatusReg = pEntry->StatusRegisters;
; 691  :                     }
; 692  : 
; 693  :                 // USB has specific set/clr registers
; 694  :                 offset = (pEntry->ctrlSubaddress == 0) ? 1 : 0; 

  00174	e5943000	 ldr         r3, [r4]
  00178	e2845004	 add         r5, r4, #4
  0017c	e3530000	 cmp         r3, #0
  00180	03a04001	 moveq       r4, #1
  00184	0a000008	 beq         |$LN30@SetInterru|
  00188		 |$LN29@SetInterru|
  00188	e3a04000	 mov         r4, #0

; 695  :                 while (pStatusReg->interruptCount)

  0018c	ea000006	 b           |$LN30@SetInterru|
  00190		 |$LL17@SetInterru|

; 696  :                     {
; 697  :                     WriteRegs(pDevice, pStatusReg->maskSubaddress + offset, 
; 698  :                         &pStatusReg->ffEnable, sizeof(UINT8)
; 699  :                         );

  00190	e5951004	 ldr         r1, [r5, #4]
  00194	e3a03001	 mov         r3, #1
  00198	e2852008	 add         r2, r5, #8
  0019c	e0811004	 add         r1, r1, r4
  001a0	e1a00007	 mov         r0, r7
  001a4	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 700  :                     pStatusReg++;

  001a8	e2855010	 add         r5, r5, #0x10
  001ac		 |$LN30@SetInterru|
  001ac	e595300c	 ldr         r3, [r5, #0xC]
  001b0	e3530000	 cmp         r3, #0
  001b4	1afffff5	 bne         |$LL17@SetInterru|

; 701  :                     }
; 702  :                 pEntry = s_pSIHEntries[++i];

  001b8	e5b63004	 ldr         r3, [r6, #4]!
  001bc	e1b04003	 movs        r4, r3

; 703  :                 }
; 704  :                 
; 705  :                 while(pEntry);        

  001c0	1affffd8	 bne         |$LL23@SetInterru|
  001c4		 |$LN25@SetInterru|

; 772  :         }
; 773  :     return TRUE;

  001c4	e3a00001	 mov         r0, #1

; 774  : }

  001c8	e28dd004	 add         sp, sp, #4
  001cc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  001d0	e12fff1e	 bx          lr
  001d4		 |$LN62@SetInterru|
  001d4		 |$LN63@SetInterru|
  001d4	00000000	 DCD         |s_pSIHEntries|
  001d8		 |$M37410|

			 ENDP  ; |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z|, SetInterruptMode

	EXPORT	|?TWL_Deinit@@YAHK@Z|			; TWL_Deinit
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|GPIOClose|
	IMPORT	|I2CClose|
	IMPORT	|GPIOInterruptDisable|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37429| DCD	|$LN15@TWL_Deinit|
	DCD	0x40002f01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Deinit@@YAHK@Z| PROC		; TWL_Deinit

; 929  : {

  00000		 |$LN15@TWL_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37426|
  00004	e1b04000	 movs        r4, r0

; 930  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 931  :     Device_t *pDevice = (Device_t*)context;
; 932  : 
; 933  : 
; 934  :     DEBUGMSG(ZONE_FUNCTION, (L"+TWL_Deinit(0x%08x)\r\n", context));
; 935  : 
; 936  :     // Check if we get correct context
; 937  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  0000c	0a000027	 beq         |$cleanUp$36626|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f309c	 ldr         r3, [pc, #0x9C]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000023	 bne         |$cleanUp$36626|

; 938  :         {
; 939  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Deinit: "
; 940  :             L"Incorrect context paramer\r\n"
; 941  :             ));
; 942  :         goto cleanUp;
; 943  :         }
; 944  : 
; 945  :     // Close interrupt thread
; 946  :     if (pDevice->hIntrThread != NULL)

  00020	e594303c	 ldr         r3, [r4, #0x3C]
  00024	e3530000	 cmp         r3, #0
  00028	0a000009	 beq         |$LN5@TWL_Deinit|

; 947  :         {
; 948  :         // Signal stop to thread
; 949  :         pDevice->intrThreadExit = TRUE;
; 950  :         // Set event to wake it
; 951  :         SetEvent(pDevice->hIntrEvent);

  0002c	e5940038	 ldr         r0, [r4, #0x38]
  00030	e3a03001	 mov         r3, #1
  00034	e3a01003	 mov         r1, #3
  00038	e5843040	 str         r3, [r4, #0x40]
  0003c	eb000000	 bl          EventModify

; 952  :         // Wait until thread exits
; 953  :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  00040	e594003c	 ldr         r0, [r4, #0x3C]
  00044	e3e01000	 mvn         r1, #0
  00048	eb000000	 bl          WaitForSingleObject

; 954  :         // Close handle
; 955  :         CloseHandle(pDevice->hIntrThread);

  0004c	e594003c	 ldr         r0, [r4, #0x3C]
  00050	eb000000	 bl          CloseHandle
  00054		 |$LN5@TWL_Deinit|

; 956  :         }
; 957  : 
; 958  :     // Disable interrupt
; 959  :     if (pDevice->sysIntr != 0)

  00054	e5943030	 ldr         r3, [r4, #0x30]
  00058	e3530000	 cmp         r3, #0

; 960  :         {
; 961  :         GPIOInterruptDisable(pDevice->hGpio, pDevice->gpio, pDevice->sysIntr);

  0005c	15941008	 ldrne       r1, [r4, #8]
  00060	15940014	 ldrne       r0, [r4, #0x14]
  00064	11a02003	 movne       r2, r3
  00068	1b000000	 blne        GPIOInterruptDisable

; 962  :         }
; 963  : 
; 964  :     // Close interrupt handler
; 965  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  0006c	e5943038	 ldr         r3, [r4, #0x38]
  00070	e3530000	 cmp         r3, #0
  00074	11a00003	 movne       r0, r3
  00078	1b000000	 blne        CloseHandle

; 966  : 
; 967  :     // Close I2C bus
; 968  :     if (pDevice->hI2C != NULL) I2CClose(pDevice->hI2C);

  0007c	e5943010	 ldr         r3, [r4, #0x10]
  00080	e3530000	 cmp         r3, #0
  00084	11a00003	 movne       r0, r3
  00088	1b000000	 blne        I2CClose

; 969  : 
; 970  :     // close Gpio 
; 971  :     if (pDevice->hGpio != NULL) GPIOClose(pDevice->hGpio);

  0008c	e5943014	 ldr         r3, [r4, #0x14]
  00090	e3530000	 cmp         r3, #0
  00094	11a00003	 movne       r0, r3
  00098	1b000000	 blne        GPIOClose

; 972  : 
; 973  :     // Delete critical section
; 974  :     DeleteCriticalSection(&pDevice->cs);

  0009c	e2840018	 add         r0, r4, #0x18
  000a0	eb000000	 bl          DeleteCriticalSection

; 975  : 
; 976  :     // Free device structure
; 977  :     LocalFree(pDevice);

  000a4	e1a00004	 mov         r0, r4
  000a8	eb000000	 bl          LocalFree

; 978  : 
; 979  :     // Done
; 980  :     rc = TRUE;

  000ac	e3a00001	 mov         r0, #1
  000b0		 |$cleanUp$36626|

; 981  : 
; 982  : cleanUp:
; 983  :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_Deinit(rc = %d)\r\n", rc));
; 984  :     return rc;
; 985  : }

  000b0	e8bd4010	 ldmia       sp!, {r4, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN16@TWL_Deinit|
  000b8		 |$LN17@TWL_Deinit|
  000b8	74776c44	 DCD         0x74776c44
  000bc		 |$M37427|

			 ENDP  ; |?TWL_Deinit@@YAHK@Z|, TWL_Deinit

	EXPORT	|?TWL_Open@@YAKKKK@Z|			; TWL_Open
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T37442| DCD	|$LN6@TWL_Open|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Open@@YAKKKK@Z| PROC		; TWL_Open

; 999  : {

  00000		 |$LN6@TWL_Open|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37439|
  00004	e1a04000	 mov         r4, r0

; 1000 :     Instance_t *pInstance = (Instance_t*)LocalAlloc(LPTR, sizeof(Instance_t));

  00008	e3a0100c	 mov         r1, #0xC
  0000c	e3a00040	 mov         r0, #0x40
  00010	eb000000	 bl          LocalAlloc
  00014	e3500000	 cmp         r0, #0

; 1001 : 
; 1002 :     UNREFERENCED_PARAMETER(accessCode);
; 1003 :     UNREFERENCED_PARAMETER(shareMode);
; 1004 : 
; 1005 :     if (pInstance == NULL)
; 1006 :     {
; 1007 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Open: "
; 1008 :             L"Failed allocate TWL instance structure\r\n"
; 1009 :             ));
; 1010 :         return NULL;

  00018	03a00000	 moveq       r0, #0

; 1016 : 
; 1017 :     return (DWORD)pInstance;
; 1018 : }

  0001c	08bd4010	 ldmeqia     sp!, {r4, lr}

; 1011 :     }
; 1012 : 
; 1013 :     pInstance->cookie = TWL_INSTANCE_COOKIE;

  00020	159f3014	 ldrne       r3, [pc, #0x14]

; 1014 :     pInstance->pDevice = (Device_t*)context;
; 1015 :     pInstance->address = 0;

  00024	13a02000	 movne       r2, #0
  00028	15804008	 strne       r4, [r0, #8]
  0002c	15803000	 strne       r3, [r0]
  00030	15802004	 strne       r2, [r0, #4]

; 1016 : 
; 1017 :     return (DWORD)pInstance;
; 1018 : }

  00034	18bd4010	 ldmneia     sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN7@TWL_Open|
  0003c		 |$LN8@TWL_Open|
  0003c	74776c49	 DCD         0x74776c49
  00040		 |$M37440|

			 ENDP  ; |?TWL_Open@@YAKKKK@Z|, TWL_Open

	EXPORT	|?TWL_Close@@YAHK@Z|			; TWL_Close

  00000			 AREA	 |.pdata|, PDATA
|$T37455| DCD	|$LN6@TWL_Close|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Close@@YAHK@Z| PROC		; TWL_Close

; 1030 : {

  00000		 |$LN6@TWL_Close|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37452|
  00004	e1b01000	 movs        r1, r0

; 1031 :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 1032 :     Instance_t *pInstance = (Instance_t*)context;
; 1033 : 
; 1034 :     if (pInstance != NULL && pInstance->cookie == TWL_INSTANCE_COOKIE)

  0000c	0a000006	 beq         |$LN1@TWL_Close|
  00010	e5912000	 ldr         r2, [r1]
  00014	e59f3018	 ldr         r3, [pc, #0x18]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000002	 bne         |$LN1@TWL_Close|

; 1035 :         {
; 1036 :         LocalFree(pInstance);

  00020	e1a00001	 mov         r0, r1
  00024	eb000000	 bl          LocalFree

; 1037 :         rc = TRUE;

  00028	e3a00001	 mov         r0, #1
  0002c		 |$LN1@TWL_Close|

; 1038 :         }
; 1039 :     
; 1040 :     return rc;
; 1041 : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$LN7@TWL_Close|
  00034		 |$LN8@TWL_Close|
  00034	74776c49	 DCD         0x74776c49
  00038		 |$M37453|

			 ENDP  ; |?TWL_Close@@YAHK@Z|, TWL_Close

	EXPORT	|?TWL_Seek@@YAHKJG@Z|			; TWL_Seek

  00000			 AREA	 |.pdata|, PDATA
|$T37469| DCD	|$LN8@TWL_Seek|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Seek@@YAHKJG@Z| PROC		; TWL_Seek

; 1112 : {

  00000		 |$LN8@TWL_Seek|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37466|
  00004	e1b0e000	 movs        lr, r0

; 1113 :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 1114 :     Instance_t *pInstance = (Instance_t*)context;
; 1115 : 
; 1116 :     UNREFERENCED_PARAMETER(type);
; 1117 : 
; 1118 :     if (pInstance == NULL || pInstance->cookie != TWL_INSTANCE_COOKIE)

  0000c	0a000004	 beq         |$cleanUp$36686|
  00010	e59e2000	 ldr         r2, [lr]
  00014	e59f3010	 ldr         r3, [pc, #0x10]
  00018	e1520003	 cmp         r2, r3

; 1119 :         {
; 1120 :         goto cleanUp;
; 1121 :         }
; 1122 : 
; 1123 :     pInstance->address = amount;

  0001c	058e1004	 streq       r1, [lr, #4]

; 1124 :     
; 1125 :     rc = TRUE;

  00020	03a00001	 moveq       r0, #1
  00024		 |$cleanUp$36686|

; 1126 : 
; 1127 : cleanUp:
; 1128 :     return rc;
; 1129 : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@TWL_Seek|
  0002c		 |$LN10@TWL_Seek|
  0002c	74776c49	 DCD         0x74776c49
  00030		 |$M37467|

			 ENDP  ; |?TWL_Seek@@YAHKJG@Z|, TWL_Seek

	EXPORT	|?TWL_PowerUp@@YAXK@Z|			; TWL_PowerUp
	IMPORT	|GPIOSetMode|

  00000			 AREA	 |.pdata|, PDATA
|$T37479| DCD	|$LN7@TWL_PowerU|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_PowerUp@@YAXK@Z| PROC		; TWL_PowerUp

; 1141 : {

  00000		 |$LN7@TWL_PowerU|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37476|
  00004	e3500000	 cmp         r0, #0

; 1142 :     Device_t *pDevice = (Device_t*)context;
; 1143 : 
; 1144 :     // Check if we get correct context
; 1145 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  00008	0a000006	 beq         |$LN1@TWL_PowerU|
  0000c	e5902000	 ldr         r2, [r0]
  00010	e59f3018	 ldr         r3, [pc, #0x18]
  00014	e1520003	 cmp         r2, r3

; 1146 :         {
; 1147 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Deinit: "
; 1148 :             L"Incorrect context paramer\r\n"
; 1149 :             ));
; 1150 :         return;
; 1151 :         }
; 1152 :     
; 1153 :     GPIOSetMode(pDevice->hGpio, pDevice->gpio, GPIO_DIR_INPUT | GPIO_INT_LOW);

  00018	05901008	 ldreq       r1, [r0, #8]
  0001c	05900014	 ldreq       r0, [r0, #0x14]
  00020	03a02009	 moveq       r2, #9
  00024	0b000000	 bleq        GPIOSetMode
  00028		 |$LN1@TWL_PowerU|

; 1154 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@TWL_PowerU|
  00030		 |$LN9@TWL_PowerU|
  00030	74776c44	 DCD         0x74776c44
  00034		 |$M37477|

			 ENDP  ; |?TWL_PowerUp@@YAXK@Z|, TWL_PowerUp

	EXPORT	|?TWL_PowerDown@@YAXK@Z|		; TWL_PowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T37489| DCD	|$LN7@TWL_PowerD|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_PowerDown@@YAXK@Z| PROC		; TWL_PowerDown

; 1166 : {

  00000		 |$LN7@TWL_PowerD|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37486|
  00004	e3500000	 cmp         r0, #0

; 1167 :     Device_t *pDevice = (Device_t*)context;
; 1168 : 
; 1169 :     // Check if we get correct context
; 1170 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  00008	0a000006	 beq         |$LN1@TWL_PowerD|
  0000c	e5902000	 ldr         r2, [r0]
  00010	e59f3018	 ldr         r3, [pc, #0x18]
  00014	e1520003	 cmp         r2, r3

; 1171 :         {
; 1172 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Deinit: "
; 1173 :             L"Incorrect context paramer\r\n"
; 1174 :             ));
; 1175 :         return;
; 1176 :         }
; 1177 : 
; 1178 :     // OMAP only wakes-up from edge detections but we enable both edge and 
; 1179 :     // level to make sure we don't drop an interrupt
; 1180 :     GPIOSetMode(pDevice->hGpio, pDevice->gpio, 
; 1181 :         GPIO_DIR_INPUT | GPIO_INT_HIGH_LOW | GPIO_INT_LOW
; 1182 :         );

  00018	05901008	 ldreq       r1, [r0, #8]
  0001c	05900014	 ldreq       r0, [r0, #0x14]
  00020	03a0200d	 moveq       r2, #0xD
  00024	0b000000	 bleq        GPIOSetMode
  00028		 |$LN1@TWL_PowerD|

; 1183 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@TWL_PowerD|
  00030		 |$LN9@TWL_PowerD|
  00030	74776c44	 DCD         0x74776c44
  00034		 |$M37487|

			 ENDP  ; |?TWL_PowerDown@@YAXK@Z|, TWL_PowerDown

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T37528| DCD	|$LN24@TWL_ReadRe|
	DCD	0xc0003002

  00000			 AREA	 |.xdata|, DATA
|$T37524| DCD	0xffffffec
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37524|

  00008		 |?TWL_ReadRegs@@YAHKKPAXK@Z| PROC	; TWL_ReadRegs

; 1195 : {

  00008		 |$LN24@TWL_ReadRe|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M37525|
  00010	e1a05003	 mov         r5, r3
  00014	e1a06002	 mov         r6, r2
  00018	e59fe0a4	 ldr         lr, [pc, #0xA4]
  0001c	e59ee000	 ldr         lr, [lr]
  00020	e58de008	 str         lr, [sp, #8]

; 1196 :     BOOL rc = FALSE;
; 1197 :     UINT8 matrix[TWL_KEYPAD_ROWS];
; 1198 :     Device_t *pDevice = ((Instance_t*)context)->pDevice;

  00024	e590e008	 ldr         lr, [r0, #8]
  00028	e3a04000	 mov         r4, #0

; 1199 : /*
; 1200 :     // Check if we get correct context
; 1201 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))
; 1202 :         {
; 1203 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_ReadRegs: "
; 1204 :             L"Incorrect context parameter\r\n"
; 1205 :             ));
; 1206 :         goto cleanUp;
; 1207 :         }
; 1208 : */
; 1209 :     if (size > 0xFF) goto cleanUp;

  0002c	e35500ff	 cmp         r5, #0xFF
  00030	8a00001c	 bhi         |$cleanUp$36715|
  00034	e3a030db	 mov         r3, #0xDB

; 1210 : 
; 1211 :     // check for cached keypad state values
; 1212 :     if (address == TWL_LOGADDR_FULL_CODE_7_0)

  00038	e24308fe	 sub         r0, r3, #0xFE, 16
  0003c	e1510000	 cmp         r1, r0
  00040	1a000013	 bne         |$LN5@TWL_ReadRe|

; 1213 :         {
; 1214 :         // if null buffer or zero count return back number of bytes
; 1215 :         // in queue which needs to be read out
; 1216 :         if (pBuffer == NULL)

  00044	e3560000	 cmp         r6, #0

; 1217 :             {
; 1218 :             rc = _nKeypadMatrixQueueCount;

  00048	059f3070	 ldreq       r3, [pc, #0x70]
  0004c	05934000	 ldreq       r4, [r3]
  00050	0a000014	 beq         |$cleanUp$36715|

; 1219 :             goto cleanUp;
; 1220 :             }
; 1221 : 
; 1222 :         // get cached keypad scan keys from internal queue
; 1223 :         size = min(size, TWL_KEYPAD_ROWS);

  00054	e3550008	 cmp         r5, #8

; 1224 :         if (ReadKeypadMatrixQueue(matrix, GetFirstEventByGroup(pDevice, 1)) == FALSE)

  00058	e28e10f0	 add         r1, lr, #0xF0
  0005c	e28d0000	 add         r0, sp, #0
  00060	23a05008	 movcs       r5, #8
  00064	eb000000	 bl          |?ReadKeypadMatrixQueue@@YAHQAEPAX@Z|
  00068	e3500000	 cmp         r0, #0

; 1225 :             {
; 1226 :             // read TWL_KEYPAD_ROWS amount of rows...
; 1227 :             memset(matrix, 0, sizeof(matrix));

  0006c	03a02008	 moveq       r2, #8
  00070	03a01000	 moveq       r1, #0
  00074	028d0000	 addeq       r0, sp, #0
  00078	0b000000	 bleq        memset

; 1228 :             }
; 1229 :         memcpy(pBuffer, matrix, size);

  0007c	e1a02005	 mov         r2, r5
  00080	e28d1000	 add         r1, sp, #0
  00084	e1a00006	 mov         r0, r6
  00088	eb000000	 bl          memcpy

; 1230 :         rc = TRUE;

  0008c	e3a04001	 mov         r4, #1

; 1231 :         }
; 1232 :     else

  00090	ea000004	 b           |$cleanUp$36715|
  00094		 |$LN5@TWL_ReadRe|

; 1233 :         {
; 1234 :         rc = ReadRegs(pDevice, address, pBuffer, size);

  00094	e1a03005	 mov         r3, r5
  00098	e1a02006	 mov         r2, r6
  0009c	e1a0000e	 mov         r0, lr
  000a0	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|
  000a4	e1a04000	 mov         r4, r0
  000a8		 |$cleanUp$36715|

; 1235 :         }
; 1236 : 
; 1237 : cleanUp:
; 1238 :     return rc;

  000a8	e59d0008	 ldr         r0, [sp, #8]
  000ac	eb000000	 bl          __security_check_cookie

; 1239 : }

  000b0	e1a00004	 mov         r0, r4
  000b4	e28dd00c	 add         sp, sp, #0xC
  000b8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN25@TWL_ReadRe|
  000c0		 |$LN26@TWL_ReadRe|
  000c0	00000000	 DCD         |?_nKeypadMatrixQueueCount@@3JA|
  000c4		 |$LN27@TWL_ReadRe|
  000c4	00000000	 DCD         |__security_cookie|
  000c8		 |$M37526|

			 ENDP  ; |?TWL_ReadRegs@@YAHKKPAXK@Z|, TWL_ReadRegs


  00000			 AREA	 |.pdata|, PDATA
|$T37547| DCD	|$LN9@TWL_WriteR|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_WriteRegs@@YAHKKPBXK@Z| PROC	; TWL_WriteRegs

; 1251 : {

  00000		 |$LN9@TWL_WriteR|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37544|

; 1252 :     BOOL rc = FALSE;
; 1253 :     Device_t *pDevice = ((Instance_t*)context)->pDevice;

  00004	e590e008	 ldr         lr, [r0, #8]
  00008	e3a00000	 mov         r0, #0

; 1254 : /*
; 1255 :     // Check if we get correct context
; 1256 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))
; 1257 :         {
; 1258 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_WriteRegs: "
; 1259 :             L"Incorrect context parameter\r\n"
; 1260 :             ));
; 1261 :         goto cleanUp;
; 1262 :         }
; 1263 : */
; 1264 :     if (size > 0xFF) goto cleanUp;

  0000c	e35300ff	 cmp         r3, #0xFF
  00010	8a000002	 bhi         |$cleanUp$36732|

; 1265 :     if (address & 0xFF000000) goto cleanUp;

  00014	e31104ff	 tst         r1, #0xFF, 8

; 1266 : 
; 1267 :     rc = WriteRegs(pDevice, address, pBuffer, size);

  00018	01a0000e	 moveq       r0, lr
  0001c	0b000000	 bleq        |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00020		 |$cleanUp$36732|

; 1268 :     
; 1269 : cleanUp:
; 1270 :     return rc;
; 1271 : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M37545|

			 ENDP  ; |?TWL_WriteRegs@@YAHKKPBXK@Z|, TWL_WriteRegs

	EXPORT	|?TWL_InterruptThread@@YAKPAX@Z|	; TWL_InterruptThread
	IMPORT	|GPIOInterruptDone|

  0008c			 AREA	 |.bss|, NOINIT
|s_pSIHRoutines| % 0x18
|s_pSIHRoutines| % 0x18

  00000			 AREA	 |.pdata|, PDATA
|$T37568| DCD	|$LN18@TWL_Interr|
	DCD	0x40003702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptThread@@YAKPAX@Z| PROC	; TWL_InterruptThread

; 1284 : {

  00000		 |$LN18@TWL_Interr|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37565|
  00008	e1a04000	 mov         r4, r0

; 1285 :     Device_t *pDevice = (Device_t*)pContext;
; 1286 :     DWORD timeout = INFINITE;
; 1287 :     UINT8 status;
; 1288 :     DWORD id;
; 1289 :     HANDLE *pEvents = NULL;
; 1290 : 
; 1291 : 
; 1292 :     // Loop until we are not stopped...
; 1293 :     while (!pDevice->intrThreadExit)

  0000c	e5943040	 ldr         r3, [r4, #0x40]
  00010	e3530000	 cmp         r3, #0
  00014	1a00002a	 bne         |$LN14@TWL_Interr|
  00018	e59f60b8	 ldr         r6, [pc, #0xB8]
  0001c	e59f70b0	 ldr         r7, [pc, #0xB0]
  00020	e3a08801	 mov         r8, #1, 16
  00024		 |$LL6@TWL_Interr|

; 1294 :         {
; 1295 :         // Wait for event
; 1296 :         WaitForSingleObject(pDevice->hIntrEvent, timeout);

  00024	e5940038	 ldr         r0, [r4, #0x38]
  00028	e3e01000	 mvn         r1, #0
  0002c	eb000000	 bl          WaitForSingleObject

; 1297 :         if (pDevice->intrThreadExit) break;

  00030	e5943040	 ldr         r3, [r4, #0x40]
  00034	e3530000	 cmp         r3, #0
  00038	1a000021	 bne         |$LN14@TWL_Interr|

; 1298 : 
; 1299 :         // NOTE:
; 1300 :         //   We can't encapsulate this here since the clients may
; 1301 :         // call into the triton driver causing a deadlock
; 1302 :         //
; 1303 :         //EnterCriticalSection(&pDevice->cs);
; 1304 :         // Get and clear interrupt status register
; 1305 :         ReadRegs(pDevice, TWL_PIH_ISR_P1, &status, sizeof(status));

  0003c	e3a03001	 mov         r3, #1
  00040	e28d2000	 add         r2, sp, #0
  00044	e3881081	 orr         r1, r8, #0x81
  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 1306 : 
; 1307 :         DEBUGMSG(ZONE_IST, (L"INFO: TWL_InterruptThread "
; 1308 :             L"Triton2 interrupt status=0x%02X\r\n", status
; 1309 :             ));
; 1310 : 
; 1311 :         // Process each interrupt
; 1312 :         id = 0;
; 1313 :         status &= 0x3F;

  00050	e5dd3000	 ldrb        r3, [sp]

; 1314 :         while (status != 0)

  00054	e3a05000	 mov         r5, #0
  00058	e203203f	 and         r2, r3, #0x3F
  0005c	ea00000e	 b           |$LN15@TWL_Interr|
  00060		 |$LL3@TWL_Interr|

; 1315 :             {
; 1316 :             if ((status & 0x1) != 0)

  00060	e3130001	 tst         r3, #1
  00064	0a000009	 beq         |$LN1@TWL_Interr|

; 1317 :                 {
; 1318 :                 pEvents = GetFirstEventByGroup(pDevice, id);

  00068	e1a01005	 mov         r1, r5
  0006c	e1a00004	 mov         r0, r4
  00070	eb000000	 bl          |?GetFirstEventByGroup@@YAPAPAXPAUDevice_t@@K@Z|

; 1319 :                 s_pSIHRoutines[id](pDevice, pEvents, s_pSIHEntries[id]); 

  00074	e7962105	 ldr         r2, [r6, +r5, lsl #2]
  00078	e7973105	 ldr         r3, [r7, +r5, lsl #2]
  0007c	e1a01000	 mov         r1, r0
  00080	e1a00004	 mov         r0, r4
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3
  0008c	e5dd2000	 ldrb        r2, [sp]
  00090		 |$LN1@TWL_Interr|

; 1320 :                 }
; 1321 :             status >>= 1;

  00090	e1a030a2	 mov         r3, r2, lsr #1
  00094	e20320ff	 and         r2, r3, #0xFF

; 1322 :             id++;

  00098	e2855001	 add         r5, r5, #1
  0009c		 |$LN15@TWL_Interr|
  0009c	e1b03002	 movs        r3, r2
  000a0	e5cd2000	 strb        r2, [sp]
  000a4	1affffed	 bne         |$LL3@TWL_Interr|

; 1323 :             }
; 1324 :         
; 1325 : 
; 1326 :         //LeaveCriticalSection(&pDevice->cs);
; 1327 :         
; 1328 :         GPIOInterruptDone(pDevice->hGpio, pDevice->gpio, pDevice->sysIntr);

  000a8	e5942030	 ldr         r2, [r4, #0x30]
  000ac	e5941008	 ldr         r1, [r4, #8]
  000b0	e5940014	 ldr         r0, [r4, #0x14]
  000b4	eb000000	 bl          GPIOInterruptDone
  000b8	e5943040	 ldr         r3, [r4, #0x40]
  000bc	e3530000	 cmp         r3, #0
  000c0	0affffd7	 beq         |$LL6@TWL_Interr|
  000c4		 |$LN14@TWL_Interr|

; 1329 :         }
; 1330 : 
; 1331 :     return ERROR_SUCCESS;

  000c4	e3a00000	 mov         r0, #0

; 1332 : }

  000c8	e28dd004	 add         sp, sp, #4
  000cc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN19@TWL_Interr|
  000d4		 |$LN20@TWL_Interr|
  000d4	00000000	 DCD         |s_pSIHRoutines|
  000d8		 |$LN21@TWL_Interr|
  000d8	00000000	 DCD         |s_pSIHEntries|
  000dc		 |$M37566|

			 ENDP  ; |?TWL_InterruptThread@@YAKPAX@Z|, TWL_InterruptThread


  00000			 AREA	 |.pdata|, PDATA
|$T37594| DCD	|$LN22@TWL_Interr@2|
	DCD	0x40004502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptMask@@YAHKKH@Z| PROC	; TWL_InterruptMask

; 1344 : {

  00000		 |$LN22@TWL_Interr@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37591|
  00008	e1a08002	 mov         r8, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e3a03c0f	 mov         r3, #0xF, 24

; 1345 :     BOOL rc = FALSE;
; 1346 :     BOOL bLocked = FALSE;    
; 1347 :     Device_t *pDevice = ((Instance_t*)context)->pDevice;
; 1348 :     UINT8 mask;
; 1349 :     SIHEntry_t const *pSIHEntry;
; 1350 :     StatusRegister_t const *pStatusRegister;
; 1351 :     int nArrayIndex;
; 1352 : /*
; 1353 :     // Check if we get correct context
; 1354 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))
; 1355 :         {
; 1356 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrEnable: "
; 1357 :             L"Incorrect context parameter\r\n"
; 1358 :             ));
; 1359 :         goto cleanUp;
; 1360 :         }
; 1361 : */
; 1362 :     if (TWL_ARRAYINDEX(intrId) >= TWL_MAX_INTR)

  00014	e38330ff	 orr         r3, r3, #0xFF
  00018	e0043003	 and         r3, r4, r3
  0001c	e5907008	 ldr         r7, [r0, #8]
  00020	e3530056	 cmp         r3, #0x56
  00024	e3a06000	 mov         r6, #0
  00028	2a000034	 bcs         |$LN1@TWL_Interr@2|

; 1363 :         {
; 1364 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptMask: "
; 1365 :             L"Incorrect interrupt Id %d\r\n", intrId
; 1366 :             ));
; 1367 :         goto cleanUp;
; 1368 :         }
; 1369 : 
; 1370 :     // We have take critical section there to avoid concurrent
; 1371 :     // enable register modification
; 1372 :     bLocked = TRUE;
; 1373 :     EnterCriticalSection(&pDevice->cs);

  0002c	e2870018	 add         r0, r7, #0x18
  00030	eb000000	 bl          EnterCriticalSection

; 1374 : 
; 1375 :     // get secondary interrupt handler info
; 1376 :     nArrayIndex = TWL_SIHINDEX(intrId);

  00034	e1a03804	 mov         r3, r4, lsl #16
  00038	e1a01e23	 mov         r1, r3, lsr #28

; 1377 :     if (nArrayIndex >= MAX_SIH_COUNT)

  0003c	e3510006	 cmp         r1, #6
  00040	aa00002c	 bge         |$cleanUp$36769|

; 1378 :         {
; 1379 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptMask: "
; 1380 :             L"Invalid SIH index %d\r\n", nArrayIndex
; 1381 :             ));
; 1382 :         goto cleanUp;
; 1383 :         }
; 1384 :     
; 1385 :     pSIHEntry = s_pSIHEntries[nArrayIndex];
; 1386 : 
; 1387 :     // get mask register value
; 1388 :     pStatusRegister = pSIHEntry->StatusRegisters + TWL_REGISTERINDEX(intrId);

  00044	e59f00c4	 ldr         r0, [pc, #0xC4]
  00048	e1a03404	 mov         r3, r4, lsl #8
  0004c	e1a0ec23	 mov         lr, r3, lsr #24
  00050	e7903101	 ldr         r3, [r0, +r1, lsl #2]

; 1389 :    
; 1390 :     int delta = 0;

  00054	e3a05000	 mov         r5, #0

; 1391 :     // Enable interrupt
; 1392 :     // USB register is an enable register
; 1393 :     if (SIHEntry_USB == TWL_SIHINDEX(intrId))

  00058	e3510004	 cmp         r1, #4
  0005c	e083920e	 add         r9, r3, lr, lsl #4
  00060	1a000009	 bne         |$LN9@TWL_Interr@2|

; 1394 :     {
; 1395 :         mask = (UINT8) ((1 << TWL_MASKBIT(intrId)));

  00064	e1a03204	 mov         r3, r4, lsl #4
  00068	e1a03e23	 mov         r3, r3, lsr #28
  0006c	e3a02001	 mov         r2, #1
  00070	e1a03312	 mov         r3, r2, lsl r3

; 1396 :         // Move to the Set address;
; 1397 :         delta = (bEnable == TRUE) ? 2 : 1;

  00074	e3580001	 cmp         r8, #1
  00078	e5cd3000	 strb        r3, [sp]
  0007c	03a05002	 moveq       r5, #2
  00080	0a000014	 beq         |$LN8@TWL_Interr@2|
  00084	e3a05001	 mov         r5, #1

; 1398 :     }
; 1399 :     else

  00088	ea000012	 b           |$LN8@TWL_Interr@2|
  0008c		 |$LN9@TWL_Interr@2|

; 1400 :     {
; 1401 :         // Get actual mask
; 1402 :         if (!ReadRegs(pDevice, pStatusRegister->maskSubaddress, 
; 1403 :             &mask, sizeof(mask)))

  0008c	e5991008	 ldr         r1, [r9, #8]
  00090	e3a03001	 mov         r3, #1
  00094	e28d2000	 add         r2, sp, #0
  00098	e1a00007	 mov         r0, r7
  0009c	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|
  000a0	e3500000	 cmp         r0, #0
  000a4	0a000013	 beq         |$cleanUp$36769|

; 1404 :             {
; 1405 :             goto cleanUp;
; 1406 :             }
; 1407 :         if (bEnable == TRUE)

  000a8	e3580001	 cmp         r8, #1

; 1408 :             {
; 1409 :             mask |= (1 << TWL_MASKBIT(intrId));

  000ac	05dd2000	 ldreqb      r2, [sp]
  000b0	e1a03204	 mov         r3, r4, lsl #4
  000b4	e3a01001	 mov         r1, #1
  000b8	01a03e23	 moveq       r3, r3, lsr #28
  000bc	01823311	 orreq       r3, r2, r1, lsl r3
  000c0	020330ff	 andeq       r3, r3, #0xFF

; 1410 :             }
; 1411 :         else
; 1412 :             {
; 1413 :             mask &= ~(1 << TWL_MASKBIT(intrId));

  000c4	11a02e23	 movne       r2, r3, lsr #28
  000c8	15dd3000	 ldrneb      r3, [sp]
  000cc	11c33211	 bicne       r3, r3, r1, lsl r2
  000d0	e5cd3000	 strb        r3, [sp]

; 1414 :             }
; 1415 :         ((StatusRegister_t*)pStatusRegister)->ffEnable = mask;

  000d4	e5c9300c	 strb        r3, [r9, #0xC]
  000d8		 |$LN8@TWL_Interr@2|

; 1416 :     }
; 1417 :     
; 1418 :     // Write it back
; 1419 :     if (!WriteRegs(pDevice, pStatusRegister->maskSubaddress + delta, 
; 1420 :         &mask, sizeof(mask)))

  000d8	e5991008	 ldr         r1, [r9, #8]
  000dc	e3a03001	 mov         r3, #1
  000e0	e28d2000	 add         r2, sp, #0
  000e4	e0811005	 add         r1, r1, r5
  000e8	e1a00007	 mov         r0, r7
  000ec	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  000f0	e3500000	 cmp         r0, #0

; 1421 :         {        
; 1422 :         goto cleanUp;
; 1423 :         }
; 1424 :     
; 1425 :     rc = TRUE;

  000f4	13a06001	 movne       r6, #1
  000f8		 |$cleanUp$36769|

; 1426 :     
; 1427 : cleanUp:
; 1428 :     if (bLocked == TRUE) LeaveCriticalSection(&pDevice->cs);

  000f8	e2870018	 add         r0, r7, #0x18
  000fc	eb000000	 bl          LeaveCriticalSection
  00100		 |$LN1@TWL_Interr@2|

; 1429 :     return rc;
; 1430 : }

  00100	e1a00006	 mov         r0, r6
  00104	e28dd004	 add         sp, sp, #4
  00108	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN23@TWL_Interr@2|
  00110		 |$LN24@TWL_Interr@2|
  00110	00000000	 DCD         |s_pSIHEntries|
  00114		 |$M37592|

			 ENDP  ; |?TWL_InterruptMask@@YAHKKH@Z|, TWL_InterruptMask

	IMPORT	|DuplicateHandle|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37617| DCD	|$LN20@TWL_Interr@3|
	DCD	0x40003f02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\driver\tps659xx.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptSetEvent@@YAHKKPAX@Z| PROC ; TWL_InterruptSetEvent

; 1442 : {

  00000		 |$LN20@TWL_Interr@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37614|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a08000	 mov         r8, r0

; 1443 :     BOOL rc = FALSE;
; 1444 :     Device_t *pDevice = ((Instance_t*)context)->pDevice;

  00014	e5984008	 ldr         r4, [r8, #8]
  00018	e3a06000	 mov         r6, #0

; 1445 :     int nArrayIndex;
; 1446 : 
; 1447 :     // We have take critical section there to avoid concurrent
; 1448 :     // enable register modification
; 1449 :     EnterCriticalSection(&pDevice->cs);

  0001c	e2840018	 add         r0, r4, #0x18
  00020	eb000000	 bl          EnterCriticalSection
  00024	e3a03c0f	 mov         r3, #0xF, 24

; 1450 : 
; 1451 : 
; 1452 :     nArrayIndex = TWL_ARRAYINDEX(intrId);

  00028	e38330ff	 orr         r3, r3, #0xFF
  0002c	e007e003	 and         lr, r7, r3

; 1453 : 
; 1454 :     if ((nArrayIndex > TWL_MAX_INTR))

  00030	e35e0056	 cmp         lr, #0x56
  00034	ca000029	 bgt         |$cleanUp$36797|
  00038	e3a03a01	 mov         r3, #1, 20

; 1455 :         {
; 1456 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptSetEvent: "
; 1457 :             L"Incorrect interrupt Id 0x%08X\r\n", intrId
; 1458 :             ));
; 1459 :         goto cleanUp;
; 1460 :         }
; 1461 :     
; 1462 :     // Special caes.  If keypad interrupt clear cached
; 1463 :     // states
; 1464 :     if (intrId == TWL_INTR_ITKPI)

  0003c	e383302a	 orr         r3, r3, #0x2A
  00040	e1570003	 cmp         r7, r3

; 1465 :     {
; 1466 :         _nKeypadMatrixQueueCount = 0;

  00044	059f30ac	 ldreq       r3, [pc, #0xAC]
  00048	03a02000	 moveq       r2, #0

; 1467 :         _nKeypadMatrixQueueHead = 0;

  0004c	03a01000	 moveq       r1, #0

; 1468 :         _nKeypadMatrixQueueTail = 0;

  00050	03a00000	 moveq       r0, #0
  00054	05832008	 streq       r2, [r3, #8]
  00058	05831000	 streq       r1, [r3]
  0005c	05830004	 streq       r0, [r3, #4]

; 1469 :     }
; 1470 : 
; 1471 :     // If handle isn't NULL we set new association, 
; 1472 :     // otherwise we delete it....
; 1473 :     if (hEvent != NULL)

  00060	e3550000	 cmp         r5, #0
  00064	0a000010	 beq         |$LN8@TWL_Interr@3|

; 1474 :     {
; 1475 :         if (pDevice->hSetIntrEvent[nArrayIndex] != NULL)

  00068	e084310e	 add         r3, r4, lr, lsl #2
  0006c	e5933048	 ldr         r3, [r3, #0x48]
  00070	e3530000	 cmp         r3, #0
  00074	1a000019	 bne         |$cleanUp$36797|

; 1476 :             {
; 1477 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptSetEvent: "
; 1478 :                 L"Interrupt Id %d already associated with event\r\n"
; 1479 :                 ));
; 1480 :             goto cleanUp;
; 1481 :             }
; 1482 :         rc = DuplicateHandle(
; 1483 :             GetCurrentProcess(), hEvent, GetCurrentProcess(),
; 1484 :             &pDevice->hSetIntrEvent[nArrayIndex], 0, FALSE, 
; 1485 :             DUPLICATE_SAME_ACCESS
; 1486 :             );

  00078	e28e3012	 add         r3, lr, #0x12
  0007c	e3a0e002	 mov         lr, #2
  00080	e3a06000	 mov         r6, #0
  00084	e0843103	 add         r3, r4, r3, lsl #2
  00088	e3a02042	 mov         r2, #0x42
  0008c	e1a01005	 mov         r1, r5
  00090	e3a00042	 mov         r0, #0x42
  00094	e58de008	 str         lr, [sp, #8]
  00098	e58d6004	 str         r6, [sp, #4]
  0009c	e58d6000	 str         r6, [sp]
  000a0	eb000000	 bl          DuplicateHandle
  000a4	e1a06000	 mov         r6, r0

; 1487 :         if (!rc)
; 1488 :         {        
; 1489 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptSetEvent: "
; 1490 :                 L"Event handler duplication failed\r\n"
; 1491 :                 ));
; 1492 :         goto cleanUp;
; 1493 :         }
; 1494 :         }
; 1495 :     else

  000a8	ea00000c	 b           |$cleanUp$36797|
  000ac		 |$LN8@TWL_Interr@3|

; 1496 :     {
; 1497 :         if (pDevice->hSetIntrEvent[nArrayIndex] == NULL)

  000ac	e084510e	 add         r5, r4, lr, lsl #2
  000b0	e5953048	 ldr         r3, [r5, #0x48]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000008	 beq         |$cleanUp$36797|

; 1498 :             {
; 1499 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_InterruptSetEvent: "
; 1500 :                 L"Interrupt Id 0x%08X isn't associated with event\r\n",
; 1501 :                 intrId
; 1502 :                 ));
; 1503 :             goto cleanUp;
; 1504 :             }
; 1505 :         rc = CloseHandle(pDevice->hSetIntrEvent[nArrayIndex]);

  000bc	e1a00003	 mov         r0, r3
  000c0	eb000000	 bl          CloseHandle
  000c4	e1a06000	 mov         r6, r0

; 1506 :         pDevice->hSetIntrEvent[nArrayIndex] = NULL;

  000c8	e3a03000	 mov         r3, #0

; 1507 :         TWL_InterruptMask(context, intrId, TRUE);

  000cc	e1a00008	 mov         r0, r8
  000d0	e3a02001	 mov         r2, #1
  000d4	e1a01007	 mov         r1, r7
  000d8	e5853048	 str         r3, [r5, #0x48]
  000dc	eb000000	 bl          |?TWL_InterruptMask@@YAHKKH@Z|
  000e0		 |$cleanUp$36797|

; 1508 :     }
; 1509 :     
; 1510 : cleanUp:
; 1511 :     LeaveCriticalSection(&pDevice->cs);

  000e0	e2840018	 add         r0, r4, #0x18
  000e4	eb000000	 bl          LeaveCriticalSection

; 1512 :     return rc;
; 1513 : }

  000e8	e1a00006	 mov         r0, r6
  000ec	e28dd00c	 add         sp, sp, #0xC
  000f0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN21@TWL_Interr@3|
  000f8		 |$LN22@TWL_Interr@3|
  000f8	00000000	 DCD         |?_nKeypadMatrixQueueHead@@3KA|
  000fc		 |$M37615|

			 ENDP  ; |?TWL_InterruptSetEvent@@YAHKKPAX@Z|, TWL_InterruptSetEvent


  00000			 AREA	 |.pdata|, PDATA
|$T37632| DCD	|$LN6@TWL_Interr@4|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptInitialize@@YAHKKPAX@Z| PROC ; TWL_InterruptInitialize

; 1525 : {

  00000		 |$LN6@TWL_Interr@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37629|
  00004	e3520000	 cmp         r2, #0
  00008	e1a03000	 mov         r3, r0

; 1526 :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 1527 :     
; 1528 :     if (hEvent != NULL)
; 1529 :         {
; 1530 :         rc = TWL_InterruptSetEvent(context, intrId, hEvent);

  00010	11a00003	 movne       r0, r3
  00014	1b000000	 blne        |?TWL_InterruptSetEvent@@YAHKKPAX@Z|

; 1531 :         }
; 1532 : 
; 1533 :     return rc;
; 1534 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M37630|

			 ENDP  ; |?TWL_InterruptInitialize@@YAHKKPAX@Z|, TWL_InterruptInitialize


  00000			 AREA	 |.pdata|, PDATA
|$T37643| DCD	|$LN5@TWL_Interr@5|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptDisable@@YAHKK@Z| PROC	; TWL_InterruptDisable

; 1544 :         {

  00000		 |$LN5@TWL_Interr@5|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37640|

; 1545 :     return TWL_InterruptSetEvent(context, intrId, NULL);

  00004	e3a02000	 mov         r2, #0
  00008	eb000000	 bl          |?TWL_InterruptSetEvent@@YAHKKPAX@Z|

; 1546 :         }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37641|

			 ENDP  ; |?TWL_InterruptDisable@@YAHKK@Z|, TWL_InterruptDisable

	EXPORT	|??_C@_1JO@MEKAAHHG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1KC@MMBGIKIK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@| [ DATA ] ; `string'
	IMPORT	|GetLastError|
	IMPORT	|OpenProcess|

  00000			 AREA	 |.pdata|, PDATA
|$T37675| DCD	|$LN21@TWL_Interr@6|
	DCD	0x40004202

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JO@MEKAAHHG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, "!", 0x0, " "
	DCB	0x0, "T", 0x0, "W", 0x0, "L", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p"
	DCB	0x0, "t", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, "P"
	DCB	0x0, "r", 0x0, "o", 0x0, "x", 0x0, "y", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "d", 0x0, "u"
	DCB	0x0, "p", 0x0, "l", 0x0, "i", 0x0, "c", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "h", 0x0, "a", 0x0, "n", 0x0, "d"
	DCB	0x0, "l", 0x0, "e", 0x0, " ", 0x0, "(", 0x0, "e", 0x0, "r"
	DCB	0x0, "r", 0x0, "=", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "X", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KC@MMBGIKIK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, "!", 0x0, " "
	DCB	0x0, "T", 0x0, "W", 0x0, "L", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p"
	DCB	0x0, "t", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, "P"
	DCB	0x0, "r", 0x0, "o", 0x0, "x", 0x0, "y", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "g", 0x0, "e"
	DCB	0x0, "t", 0x0, " ", 0x0, "p", 0x0, "r", 0x0, "o", 0x0, "c"
	DCB	0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "d", 0x0, "l", 0x0, "e", 0x0, " ", 0x0, "("
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "=", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_InterruptInitializeProxy@@YAHKIKPAX@Z| PROC ; TWL_InterruptInitializeProxy

; 1558 : {   

  00000		 |$LN21@TWL_Interr@6|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37672|
  00008	e1b08003	 movs        r8, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a07000	 mov         r7, r0

; 1559 :     HANDLE hProc;
; 1560 :     HANDLE hEvent = NULL;

  00014	e3a00000	 mov         r0, #0
  00018	e58d000c	 str         r0, [sp, #0xC]

; 1561 :     BOOL rc = FALSE;    

  0001c	e3a04000	 mov         r4, #0

; 1562 :     
; 1563 :     // If handle isn't NULL we set new association, 
; 1564 :     // otherwise we delete it....
; 1565 :     if (hEventOrig != NULL)

  00020	0a000027	 beq         |$LN2@TWL_Interr@6|

; 1566 :         {
; 1567 :         hProc = OpenProcess(0, FALSE, procId);

  00024	e1a02001	 mov         r2, r1
  00028	e3a01000	 mov         r1, #0
  0002c	e3a00000	 mov         r0, #0
  00030	eb000000	 bl          OpenProcess
  00034	e1b05000	 movs        r5, r0

; 1568 :         if (hProc == NULL)

  00038	1a000008	 bne         |$LN4@TWL_Interr@6|

; 1569 :             {
; 1570 :             RETAILMSG(ZONE_ERROR, (L"ERROR! TWL_InterruptInitializeProxy: "
; 1571 :                 L"Unable to get process handle (err=0x%08X)\r\n",
; 1572 :                 GetLastError()
; 1573 :                 ));

  0003c	e59f30bc	 ldr         r3, [pc, #0xBC]
  00040	e5933440	 ldr         r3, [r3, #0x440]
  00044	e3130001	 tst         r3, #1
  00048	0a000027	 beq         |$cleanUp$36834|
  0004c	eb000000	 bl          GetLastError
  00050	e1a01000	 mov         r1, r0
  00054	e59f00a8	 ldr         r0, [pc, #0xA8]

; 1587 :         {
; 1588 :             RETAILMSG(ZONE_ERROR, (L"ERROR! TWL_InterruptInitializeProxy: "
; 1589 :                 L"Unable to duplicate handle (err=0x%08X)\r\n",
; 1590 :                 GetLastError()
; 1591 :                 ));

  00058	eb000000	 bl          NKDbgPrintfW

; 1601 :             
; 1602 : cleanUp:

  0005c	ea000022	 b           |$cleanUp$36834|
  00060		 |$LN4@TWL_Interr@6|

; 1574 :             goto cleanUp;
; 1575 :             }
; 1576 :         
; 1577 :         // create a duplicate handle
; 1578 :         rc = DuplicateHandle(
; 1579 :             hProc, hEventOrig, GetCurrentProcess(),
; 1580 :             &hEvent, 0, FALSE, 
; 1581 :             DUPLICATE_SAME_ACCESS
; 1582 :             );

  00060	e3a03002	 mov         r3, #2
  00064	e58d3008	 str         r3, [sp, #8]
  00068	e3a0e000	 mov         lr, #0
  0006c	e28d300c	 add         r3, sp, #0xC
  00070	e3a02042	 mov         r2, #0x42
  00074	e1a01008	 mov         r1, r8
  00078	e1a00005	 mov         r0, r5
  0007c	e58de004	 str         lr, [sp, #4]
  00080	e58de000	 str         lr, [sp]
  00084	eb000000	 bl          DuplicateHandle
  00088	e1a04000	 mov         r4, r0

; 1583 : 
; 1584 :         // release resources
; 1585 :         CloseHandle(hProc);

  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          CloseHandle

; 1586 :         if (rc == FALSE)

  00094	e3540000	 cmp         r4, #0
  00098	1a000008	 bne         |$LN17@TWL_Interr@6|

; 1587 :         {
; 1588 :             RETAILMSG(ZONE_ERROR, (L"ERROR! TWL_InterruptInitializeProxy: "
; 1589 :                 L"Unable to duplicate handle (err=0x%08X)\r\n",
; 1590 :                 GetLastError()
; 1591 :                 ));

  0009c	e59f305c	 ldr         r3, [pc, #0x5C]
  000a0	e5933440	 ldr         r3, [r3, #0x440]
  000a4	e3130001	 tst         r3, #1
  000a8	0a00000f	 beq         |$cleanUp$36834|
  000ac	eb000000	 bl          GetLastError
  000b0	e1a01000	 mov         r1, r0
  000b4	e59f0040	 ldr         r0, [pc, #0x40]
  000b8	eb000000	 bl          NKDbgPrintfW

; 1601 :             
; 1602 : cleanUp:

  000bc	ea00000a	 b           |$cleanUp$36834|
  000c0		 |$LN17@TWL_Interr@6|
  000c0	e59d000c	 ldr         r0, [sp, #0xC]
  000c4		 |$LN2@TWL_Interr@6|

; 1592 :             goto cleanUp;
; 1593 :             }
; 1594 :         }
; 1595 :             
; 1596 :     // call local routine to map event with interrupt
; 1597 :     rc = TWL_InterruptInitialize(context, intrId, hEvent);

  000c4	e3a04000	 mov         r4, #0
  000c8	e3500000	 cmp         r0, #0
  000cc	0a000005	 beq         |$LN14@TWL_Interr@6|
  000d0	e1a02000	 mov         r2, r0
  000d4	e1a00007	 mov         r0, r7
  000d8	e1a01006	 mov         r1, r6
  000dc	eb000000	 bl          |?TWL_InterruptSetEvent@@YAHKKPAX@Z|
  000e0	e1a04000	 mov         r4, r0
  000e4	e59d000c	 ldr         r0, [sp, #0xC]
  000e8		 |$LN14@TWL_Interr@6|

; 1598 :     
; 1599 :     // release this handle
; 1600 :     CloseHandle(hEvent);

  000e8	eb000000	 bl          CloseHandle
  000ec		 |$cleanUp$36834|

; 1603 :     return rc;
; 1604 : }

  000ec	e1a00004	 mov         r0, r4
  000f0	e28dd010	 add         sp, sp, #0x10
  000f4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN22@TWL_Interr@6|
  000fc		 |$LN23@TWL_Interr@6|
  000fc	00000000	 DCD         |??_C@_1JO@MEKAAHHG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@|
  00100		 |$LN24@TWL_Interr@6|
  00100	00000000	 DCD         |dpCurSettings|
  00104		 |$LN25@TWL_Interr@6|
  00104	00000000	 DCD         |??_C@_1KC@MMBGIKIK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?$CB?$AA?5?$AAT?$AAW?$AAL?$AA_?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAP?$AAr@|
  00108		 |$M37673|

			 ENDP  ; |?TWL_InterruptInitializeProxy@@YAHKIKPAX@Z|, TWL_InterruptInitializeProxy

	EXPORT	|?TWL_EnableWakeup@@YAHKKH@Z|		; TWL_EnableWakeup
	IMPORT	|GPIOInterruptWakeUp|

  00000			 AREA	 |.pdata|, PDATA
|$T37702| DCD	|$LN25@TWL_Enable|
	DCD	0x40003d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_EnableWakeup@@YAHKKH@Z| PROC	; TWL_EnableWakeup

; 1614 : {

  00000		 |$LN25@TWL_Enable|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37699|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e3a03c0f	 mov         r3, #0xF, 24

; 1615 :     BOOL rc = FALSE;
; 1616 :     BOOL bLocked = FALSE;    
; 1617 :     Device_t *pDevice = ((Instance_t*)context)->pDevice;
; 1618 :     SIHEntry_t const *pSIHEntry;
; 1619 :     StatusRegister_t const *pStatusRegister;
; 1620 :     int nArrayIndex;
; 1621 : /*
; 1622 :     // Check if we get correct context
; 1623 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))
; 1624 :         {
; 1625 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrEnable: "
; 1626 :             L"Incorrect context parameter\r\n"
; 1627 :             ));
; 1628 :         goto cleanUp;
; 1629 :         }
; 1630 : */
; 1631 :     if (TWL_ARRAYINDEX(intrId) >= TWL_MAX_INTR)

  00010	e38330ff	 orr         r3, r3, #0xFF
  00014	e0063003	 and         r3, r6, r3
  00018	e5904008	 ldr         r4, [r0, #8]
  0001c	e3530056	 cmp         r3, #0x56
  00020	e3a05000	 mov         r5, #0
  00024	2a00002e	 bcs         |$LN1@TWL_Enable|

; 1632 :         {
; 1633 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_EnableWakeup: "
; 1634 :             L"Incorrect interrupt Id %d\r\n", intrId
; 1635 :             ));
; 1636 :         goto cleanUp;
; 1637 :         }
; 1638 : 
; 1639 :     // We have take critical section there to avoid concurrent
; 1640 :     // enable register modification
; 1641 :     bLocked = TRUE;
; 1642 :     EnterCriticalSection(&pDevice->cs);

  00028	e2840018	 add         r0, r4, #0x18
  0002c	eb000000	 bl          EnterCriticalSection

; 1643 : 
; 1644 :     // get secondary interrupt handler info
; 1645 :     nArrayIndex = TWL_SIHINDEX(intrId);

  00030	e1a03806	 mov         r3, r6, lsl #16
  00034	e1a01e23	 mov         r1, r3, lsr #28

; 1646 :     if (nArrayIndex > MAX_SIH_COUNT)

  00038	e3510006	 cmp         r1, #6
  0003c	ca000026	 bgt         |$cleanUp$36853|

; 1647 :         {
; 1648 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_EnableWakeup: "
; 1649 :             L"Invalid SIH index %d\r\n", nArrayIndex
; 1650 :             ));
; 1651 :         goto cleanUp;
; 1652 :         }
; 1653 :     
; 1654 :     pSIHEntry = s_pSIHEntries[nArrayIndex];
; 1655 : 
; 1656 :     // get mask register value
; 1657 :     pStatusRegister = pSIHEntry->StatusRegisters + TWL_REGISTERINDEX(intrId);

  00040	e59f00a8	 ldr         r0, [pc, #0xA8]
  00044	e1a03406	 mov         r3, r6, lsl #8
  00048	e1a0ec23	 mov         lr, r3, lsr #24
  0004c	e7900101	 ldr         r0, [r0, +r1, lsl #2]

; 1658 : 
; 1659 :     // NOTE:
; 1660 :     //  The bit must be cleared to indicate the interrupt is unmasked
; 1661 :     // set enable/disable mask only if the request doesn't match the current state
; 1662 :     if (!!((pStatusRegister->ffWakeupEnable) & (1 << TWL_MASKBIT(intrId))) != !bEnable)

  00050	e1a03206	 mov         r3, r6, lsl #4
  00054	e1a03e23	 mov         r3, r3, lsr #28
  00058	e080120e	 add         r1, r0, lr, lsl #4
  0005c	e5d1000d	 ldrb        r0, [r1, #0xD]
  00060	e3a02001	 mov         r2, #1
  00064	e1a0e312	 mov         lr, r2, lsl r3
  00068	e110000e	 tst         r0, lr
  0006c	13a02001	 movne       r2, #1
  00070	03a02000	 moveq       r2, #0
  00074	e3570000	 cmp         r7, #0
  00078	03a03001	 moveq       r3, #1
  0007c	13a03000	 movne       r3, #0
  00080	e1520003	 cmp         r2, r3
  00084	0a000013	 beq         |$LN2@TWL_Enable|

; 1663 :         {
; 1664 :         if (bEnable)

  00088	e3570000	 cmp         r7, #0

; 1665 :             {
; 1666 :             ((StatusRegister_t*)pStatusRegister)->ffWakeupEnable &= 
; 1667 :                                             ~(1 << TWL_MASKBIT(intrId));

  0008c	11c0300e	 bicne       r3, r0, lr
  00090	15c1300d	 strneb      r3, [r1, #0xD]

; 1668 :             pDevice->wakeupCount++;

  00094	15943034	 ldrne       r3, [r4, #0x34]
  00098	12833001	 addne       r3, r3, #1

; 1669 :             }
; 1670 :         else
; 1671 :             {
; 1672 :             ((StatusRegister_t*)pStatusRegister)->ffWakeupEnable |= 
; 1673 :                                             (1 << TWL_MASKBIT(intrId));

  0009c	0180300e	 orreq       r3, r0, lr
  000a0	05c1300d	 streqb      r3, [r1, #0xD]

; 1674 :             pDevice->wakeupCount--;

  000a4	05943034	 ldreq       r3, [r4, #0x34]
  000a8	02433001	 subeq       r3, r3, #1

; 1675 :             }
; 1676 : 
; 1677 :         // (un)register as wakeup interrupt, as necessary
; 1678 :         if (pDevice->wakeupCount == 1)

  000ac	e3530001	 cmp         r3, #1
  000b0	e5843034	 str         r3, [r4, #0x34]

; 1679 :             {
; 1680 :                 if (!GPIOInterruptWakeUp(pDevice->hGpio, pDevice->gpio, pDevice->sysIntr,TRUE))

  000b4	03a03001	 moveq       r3, #1
  000b8	0a000002	 beq         |$LN22@TWL_Enable|

; 1681 :                 {
; 1682 :                 DEBUGMSG(ZONE_ERROR, (L"WARN: TWL_EnableWakeup: "
; 1683 :                     L"Failed enable as wakeup source\r\n"
; 1684 :                     ));
; 1685 :                 }
; 1686 :             }
; 1687 :         else if (pDevice->wakeupCount == 0)

  000bc	e3530000	 cmp         r3, #0
  000c0	1a000004	 bne         |$LN2@TWL_Enable|

; 1688 :             {
; 1689 :             if (!GPIOInterruptWakeUp(pDevice->hGpio, pDevice->gpio, pDevice->sysIntr,FALSE))

  000c4	e3a03000	 mov         r3, #0
  000c8		 |$LN22@TWL_Enable|
  000c8	e5942030	 ldr         r2, [r4, #0x30]
  000cc	e5941008	 ldr         r1, [r4, #8]
  000d0	e5940014	 ldr         r0, [r4, #0x14]
  000d4	eb000000	 bl          GPIOInterruptWakeUp
  000d8		 |$LN2@TWL_Enable|

; 1690 :                 {
; 1691 :                 DEBUGMSG(ZONE_ERROR, (L"WARN: TWL_EnableWakeup: "
; 1692 :                     L"Failed to disable as wakeup source\r\n"
; 1693 :                     ));
; 1694 :                 }
; 1695 :             }
; 1696 :         }
; 1697 :     
; 1698 :     rc = TRUE;

  000d8	e3a05001	 mov         r5, #1
  000dc		 |$cleanUp$36853|

; 1699 :     
; 1700 : cleanUp:
; 1701 :     if (bLocked == TRUE) LeaveCriticalSection(&pDevice->cs);

  000dc	e2840018	 add         r0, r4, #0x18
  000e0	eb000000	 bl          LeaveCriticalSection
  000e4		 |$LN1@TWL_Enable|

; 1702 :     return rc;
; 1703 : }

  000e4	e1a00005	 mov         r0, r5
  000e8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN26@TWL_Enable|
  000f0		 |$LN27@TWL_Enable|
  000f0	00000000	 DCD         |s_pSIHEntries|
  000f4		 |$M37700|

			 ENDP  ; |?TWL_EnableWakeup@@YAHKKH@Z|, TWL_EnableWakeup

	EXPORT	|?TWL_IOControl@@YAHKKPAEK0KPAK@Z|	; TWL_IOControl
	EXPORT	|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|SetLastError|
	IMPORT	|GetCallerProcess|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T37802| DCD	|$LN110@TWL_IOCont|
	DCD	0xc0011d04

  00000			 AREA	 |.pdata|, PDATA
|$T37804| DCD	|$LN61@TWL_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T37806| DCD	|$LN75@TWL_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T37808| DCD	|$LN68@TWL_IOCont|
	DCD	0x40001601

  00000			 AREA	 |.xdata|, DATA
|$T37800| DCD	0x3
	DCD	|$LN65@TWL_IOCont|
	DCD	|$LN66@TWL_IOCont|
	DCD	|$LN61@TWL_IOCont|
	DCD	|$LN62@TWL_IOCont|
	DCD	|$LN79@TWL_IOCont|
	DCD	|$LN80@TWL_IOCont|
	DCD	|$LN75@TWL_IOCont|
	DCD	|$LN76@TWL_IOCont|
	DCD	|$LN72@TWL_IOCont|
	DCD	|$LN73@TWL_IOCont|
	DCD	|$LN68@TWL_IOCont|
	DCD	|$LN69@TWL_IOCont|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "e"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T37800|

  00008		 |?TWL_IOControl@@YAHKKPAEK0KPAK@Z| PROC ; TWL_IOControl

; 1722 : {

  00008		 |$LN110@TWL_IOCont|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5bf0	 stmdb       sp!, {r4 - r9, r11, r12, lr}
  00010	e28db024	 add         r11, sp, #0x24
  00014	e24dd024	 sub         sp, sp, #0x24
  00018		 |$LN108@TWL_IOCont|
  00018	e1a08003	 mov         r8, r3
  0001c	e1a05002	 mov         r5, r2
  00020	e1b09000	 movs        r9, r0

; 1723 :     DEBUGMSG(ZONE_FUNCTION, (
; 1724 :         L"+TWL_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 1725 :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 1726 :         ));
; 1727 :     
; 1728 :     BOOL rc = FALSE;

  00024	e3a06000	 mov         r6, #0
  00028	e50b6048	 str         r6, [r11, #-0x48]

; 1729 :     const void* pBuffer;
; 1730 :     Device_t *pDevice;
; 1731 :     DEVICE_IFC_TWL ifc;
; 1732 :     DWORD address, size;
; 1733 :     Instance_t *pInstance = (Instance_t*)context;
; 1734 : 
; 1735 :     if (pInstance == NULL || pInstance->cookie != TWL_INSTANCE_COOKIE)

  0002c	0a00010e	 beq         |$cleanUp$36891|
  00030	e5994000	 ldr         r4, [r9]
  00034	e59fe4ac	 ldr         lr, [pc, #0x4AC]
  00038	e154000e	 cmp         r4, lr
  0003c	1a00010a	 bne         |$cleanUp$36891|

; 1736 :         {
; 1737 :         goto cleanUp;
; 1738 :         }
; 1739 : 
; 1740 :     pDevice = pInstance->pDevice;

  00040	e599e008	 ldr         lr, [r9, #8]
  00044	e1b0700e	 movs        r7, lr

; 1741 : 
; 1742 : 
; 1743 :     // Check if we get correct context
; 1744 :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  00048	0a000107	 beq         |$cleanUp$36891|
  0004c	e5974000	 ldr         r4, [r7]
  00050	e59fe48c	 ldr         lr, [pc, #0x48C]
  00054	e154000e	 cmp         r4, lr
  00058	1a000103	 bne         |$cleanUp$36891|

; 1745 :         {
; 1746 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 1747 :             L"Incorrect context paramer\r\n"
; 1748 :             ));
; 1749 :         goto cleanUp;
; 1750 :         }
; 1751 : 
; 1752 :     switch (code)

  0005c	e59f347c	 ldr         r3, [pc, #0x47C]
  00060	e1510003	 cmp         r1, r3
  00064	8a000082	 bhi         |$LN59@TWL_IOCont|
  00068	0a000078	 beq         |$LN4@TWL_IOCont|
  0006c	e3a03822	 mov         r3, #0x22, 16
  00070	e3833b01	 orr         r3, r3, #1, 22
  00074	e1510003	 cmp         r1, r3
  00078	0a000041	 beq         |$LN42@TWL_IOCont|
  0007c	e3a03822	 mov         r3, #0x22, 16
  00080	e3833b03	 orr         r3, r3, #3, 22
  00084	e1510003	 cmp         r1, r3
  00088	0a00001c	 beq         |$LN33@TWL_IOCont|
  0008c	e59f3448	 ldr         r3, [pc, #0x448]
  00090	e1510003	 cmp         r1, r3
  00094	0a00002b	 beq         |$LN27@TWL_IOCont|
  00098	e59f3438	 ldr         r3, [pc, #0x438]
  0009c	e1510003	 cmp         r1, r3
  000a0	0a00000c	 beq         |$LN8@TWL_IOCont|
  000a4	e3a03822	 mov         r3, #0x22, 16
  000a8	e3833ec1	 orr         r3, r3, #0xC1, 28
  000ac	e1510003	 cmp         r1, r3
  000b0	1a0000ed	 bne         |$cleanUp$36891|

; 1959 : 
; 1960 :         case IOCTL_TWL_INTRDISABLE:
; 1961 :             if (pInBuffer != NULL && inSize == sizeof(DWORD))

  000b4	e3550000	 cmp         r5, #0
  000b8	0a0000eb	 beq         |$cleanUp$36891|
  000bc	e3580004	 cmp         r8, #4
  000c0	1a0000e9	 bne         |$cleanUp$36891|

; 1962 :                 {
; 1963 :                 rc = TWL_InterruptDisable(context, *(DWORD*)pInBuffer);

  000c4	e5951000	 ldr         r1, [r5]
  000c8	e3a02000	 mov         r2, #0
  000cc	e1a00009	 mov         r0, r9
  000d0	eb000000	 bl          |?TWL_InterruptSetEvent@@YAHKKPAX@Z|

; 1964 :                 }
; 1965 :             break;

  000d4	ea0000e3	 b           |$LN105@TWL_IOCont|
  000d8		 |$LN8@TWL_IOCont|

; 1932 :                     }
; 1933 :                 }     
; 1934 :             break;
; 1935 : 
; 1936 :         case IOCTL_TWL_INTRINIT:
; 1937 :             if (pInBuffer != NULL && inSize == sizeof(IOCTL_TWL_INTRINIT_IN))

  000d8	e3550000	 cmp         r5, #0
  000dc	0a0000e2	 beq         |$cleanUp$36891|
  000e0	e358000c	 cmp         r8, #0xC
  000e4	1a0000e0	 bne         |$cleanUp$36891|

; 1938 :                 {
; 1939 :                 IOCTL_TWL_INTRINIT_IN *pInParam = (IOCTL_TWL_INTRINIT_IN*)pInBuffer;
; 1940 :                 rc = TWL_InterruptInitializeProxy(context, pInParam->procId, pInParam->intrId, pInParam->hEvent);

  000e8	e5953008	 ldr         r3, [r5, #8]
  000ec	e5952004	 ldr         r2, [r5, #4]
  000f0	e5951000	 ldr         r1, [r5]
  000f4	e1a00009	 mov         r0, r9
  000f8	eb000000	 bl          |?TWL_InterruptInitializeProxy@@YAHKIKPAX@Z|

; 1941 :                 }
; 1942 :             break;

  000fc	ea0000d9	 b           |$LN105@TWL_IOCont|
  00100		 |$LN33@TWL_IOCont|

; 1794 :                 }
; 1795 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1796 :             break;
; 1797 :             
; 1798 :         case IOCTL_TWL_READREGS:
; 1799 :             if ((pInBuffer == NULL) || 
; 1800 :                 (inSize < sizeof(IOCTL_TWL_READREGS_IN)))

  00100	e3550000	 cmp         r5, #0
  00104	0a00004e	 beq         |$LN39@TWL_IOCont|
  00108	e3580008	 cmp         r8, #8
  0010c	3a00004c	 bcc         |$LN39@TWL_IOCont|

; 1801 :                 {
; 1802 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1803 :                 break;
; 1804 :                 }
; 1805 :             address = ((IOCTL_TWL_READREGS_IN*)pInBuffer)->address;
; 1806 :             size = ((IOCTL_TWL_READREGS_IN*)pInBuffer)->size;
; 1807 :             if (pOutSize != NULL) *pOutSize = size;

  00110	e59b2008	 ldr         r2, [r11, #8]
  00114	e5951000	 ldr         r1, [r5]
  00118	e5953004	 ldr         r3, [r5, #4]
  0011c	e3520000	 cmp         r2, #0
  00120	15823000	 strne       r3, [r2]

; 1808 :             if ((pOutBuffer == NULL) || (outSize < size))

  00124	e59b2000	 ldr         r2, [r11]
  00128	e3520000	 cmp         r2, #0
  0012c	0a000044	 beq         |$LN39@TWL_IOCont|
  00130	e59b0004	 ldr         r0, [r11, #4]
  00134	e1500003	 cmp         r0, r3
  00138	3a000041	 bcc         |$LN39@TWL_IOCont|

; 1809 :                 {
; 1810 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1811 :                 break;
; 1812 :                 }
; 1813 :             rc = TWL_ReadRegs(context, address, pOutBuffer, size);

  0013c	e1a00009	 mov         r0, r9
  00140	eb000000	 bl          |?TWL_ReadRegs@@YAHKKPAXK@Z|
  00144	e1a06000	 mov         r6, r0
  00148		 |$LN27@TWL_IOCont|

; 1814 : 
; 1815 :         case IOCTL_TWL_WRITEREGS:
; 1816 :             if ((pInBuffer == NULL) || 
; 1817 :                 (inSize < sizeof(IOCTL_TWL_WRITEREGS_IN)))

  00148	e3550000	 cmp         r5, #0
  0014c	0a00003c	 beq         |$LN39@TWL_IOCont|
  00150	e358000c	 cmp         r8, #0xC
  00154	3a00003a	 bcc         |$LN39@TWL_IOCont|

; 1818 :                 {
; 1819 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1820 :                 break;
; 1821 :                 }
; 1822 :             address = ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)->address;
; 1823 :             pBuffer = ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)->pBuffer;
; 1824 :             size = ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)->size;

  00158	e5953008	 ldr         r3, [r5, #8]
  0015c	e5951000	 ldr         r1, [r5]
  00160	e5952004	 ldr         r2, [r5, #4]

; 1825 :             /*
; 1826 :             if (inSize < (sizeof(IOCTL_TWL_WRITEREGS_IN) + size))
; 1827 :                 {
; 1828 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1829 :                 break;
; 1830 :                 }
; 1831 :             */	
; 1832 :             rc = TWL_WriteRegs(context, address, pBuffer, size);

  00164	e35300ff	 cmp         r3, #0xFF
  00168	e5990008	 ldr         r0, [r9, #8]
  0016c	e3a06000	 mov         r6, #0
  00170	8a0000bd	 bhi         |$cleanUp$36891|
  00174	e31104ff	 tst         r1, #0xFF, 8
  00178	1a0000bb	 bne         |$cleanUp$36891|
  0017c	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00180		 |$cleanUp$37753|

; 1833 :             break;

  00180	ea0000b8	 b           |$LN105@TWL_IOCont|
  00184		 |$LN42@TWL_IOCont|

; 1753 :         {
; 1754 :         case IOCTL_DDK_GET_DRIVER_IFC:
; 1755 :             // We can give interface only to our peer in device process
; 1756 :             if (GetCurrentProcessId() != (DWORD)GetCallerProcess())

  00184	e3a0000c	 mov         r0, #0xC
  00188	eb000000	 bl          __GetUserKData
  0018c	e1a04000	 mov         r4, r0
  00190	eb000000	 bl          GetCallerProcess
  00194	e1540000	 cmp         r4, r0
  00198	0a000002	 beq         |$LN41@TWL_IOCont|

; 1757 :                 {
; 1758 :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 1759 :                     L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 1760 :                     L"device process (caller process id 0x%08x)\r\n",
; 1761 :                     GetCallerProcess()
; 1762 :                     ));
; 1763 :                 SetLastError(ERROR_ACCESS_DENIED);

  0019c	e3a00005	 mov         r0, #5
  001a0	eb000000	 bl          SetLastError

; 1764 :                 break;

  001a4	ea0000b0	 b           |$cleanUp$36891|
  001a8		 |$LN41@TWL_IOCont|

; 1765 :                 }
; 1766 :             // Check input parameters
; 1767 :             if ((pInBuffer == NULL) || (inSize < sizeof(GUID)))

  001a8	e3550000	 cmp         r5, #0
  001ac	0a000024	 beq         |$LN39@TWL_IOCont|
  001b0	e3580010	 cmp         r8, #0x10
  001b4	3a000022	 bcc         |$LN39@TWL_IOCont|

; 1770 :                 break;
; 1771 :                 }
; 1772 :             if (IsEqualGUID(*(GUID*)pInBuffer, DEVICE_IFC_TWL_GUID))

  001b8	e59f1314	 ldr         r1, [pc, #0x314]
  001bc	e3a02010	 mov         r2, #0x10
  001c0	e1a00005	 mov         r0, r5
  001c4	eb000000	 bl          memcmp
  001c8	e3500000	 cmp         r0, #0
  001cc	1a00001c	 bne         |$LN39@TWL_IOCont|

; 1773 :                 {
; 1774 :                 if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_TWL);

  001d0	e59b3008	 ldr         r3, [r11, #8]
  001d4	e3530000	 cmp         r3, #0
  001d8	13a0201c	 movne       r2, #0x1C
  001dc	15832000	 strne       r2, [r3]

; 1775 :                 if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_TWL))

  001e0	e59b0000	 ldr         r0, [r11]
  001e4	e3500000	 cmp         r0, #0
  001e8	0a000015	 beq         |$LN39@TWL_IOCont|
  001ec	e59b3004	 ldr         r3, [r11, #4]
  001f0	e353001c	 cmp         r3, #0x1C
  001f4	3a000012	 bcc         |$LN39@TWL_IOCont|

; 1776 :                     {
; 1777 :                     SetLastError(ERROR_INVALID_PARAMETER);
; 1778 :                     break;
; 1779 :                     }
; 1780 :                 ifc.context = context;
; 1781 :                 ifc.pfnReadRegs = TWL_ReadRegs;

  001f8	e59f32d0	 ldr         r3, [pc, #0x2D0]

; 1782 :                 ifc.pfnWriteRegs = TWL_WriteRegs;

  001fc	e59f22c8	 ldr         r2, [pc, #0x2C8]

; 1783 :                 ifc.pfnInterruptInitialize = TWL_InterruptInitialize;

  00200	e59f12c0	 ldr         r1, [pc, #0x2C0]

; 1784 :                 ifc.pfnInterruptMask = TWL_InterruptMask;

  00204	e59fe2b8	 ldr         lr, [pc, #0x2B8]

; 1785 :                 ifc.pfnInterruptDisable = TWL_InterruptDisable;

  00208	e59f42b0	 ldr         r4, [pc, #0x2B0]

; 1786 :                 ifc.pfnEnableWakeup = TWL_EnableWakeup;

  0020c	e59f52a8	 ldr         r5, [pc, #0x2A8]
  00210	e50b303c	 str         r3, [r11, #-0x3C]
  00214	e50b2038	 str         r2, [r11, #-0x38]
  00218	e50b1034	 str         r1, [r11, #-0x34]
  0021c	e50be02c	 str         lr, [r11, #-0x2C]
  00220	e50b4030	 str         r4, [r11, #-0x30]
  00224	e50b5028	 str         r5, [r11, #-0x28]

; 1787 :                 if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_TWL)))

  00228	e3a0201c	 mov         r2, #0x1C
  0022c	e24b1040	 sub         r1, r11, #0x40
  00230	e50b9040	 str         r9, [r11, #-0x40]
  00234	eb000000	 bl          CeSafeCopyMemory
  00238	e3500000	 cmp         r0, #0

; 1791 :                     }
; 1792 :                 rc = TRUE;

  0023c	13a06001	 movne       r6, #1

; 1788 :                     {
; 1789 :                     SetLastError(ERROR_INVALID_PARAMETER);
; 1790 :                     break;

  00240	1a000089	 bne         |$cleanUp$36891|
  00244		 |$LN39@TWL_IOCont|

; 1768 :                 {
; 1769 :                 SetLastError(ERROR_INVALID_PARAMETER);

  00244	e3a00057	 mov         r0, #0x57

; 1757 :                 {
; 1758 :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 1759 :                     L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 1760 :                     L"device process (caller process id 0x%08x)\r\n",
; 1761 :                     GetCallerProcess()
; 1762 :                     ));
; 1763 :                 SetLastError(ERROR_ACCESS_DENIED);

  00248	eb000000	 bl          SetLastError

; 1764 :                 break;

  0024c	ea000086	 b           |$cleanUp$36891|
  00250		 |$LN4@TWL_IOCont|

; 1949 :                 }
; 1950 :             break;
; 1951 : 
; 1952 :         case IOCTL_TWL_INTRMASK:
; 1953 :             if (pInBuffer != NULL && inSize == sizeof(IOCTL_TWL_INTRMASK_IN))

  00250	e3550000	 cmp         r5, #0
  00254	0a000084	 beq         |$cleanUp$36891|
  00258	e358000c	 cmp         r8, #0xC
  0025c	1a000082	 bne         |$cleanUp$36891|

; 1954 :                 {
; 1955 :                 IOCTL_TWL_INTRMASK_IN *pInParam = (IOCTL_TWL_INTRMASK_IN*)pInBuffer;
; 1956 :                 rc = TWL_InterruptMask(context, pInParam->procId, pInParam->bEnable);

  00260	e5952008	 ldr         r2, [r5, #8]
  00264	e5951000	 ldr         r1, [r5]
  00268	e1a00009	 mov         r0, r9
  0026c	eb000000	 bl          |?TWL_InterruptMask@@YAHKKH@Z|

; 1957 :                 }
; 1958 :             break;

  00270	ea00007c	 b           |$LN105@TWL_IOCont|
  00274		 |$LN59@TWL_IOCont|

; 1745 :         {
; 1746 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 1747 :             L"Incorrect context paramer\r\n"
; 1748 :             ));
; 1749 :         goto cleanUp;
; 1750 :         }
; 1751 : 
; 1752 :     switch (code)

  00274	e59f323c	 ldr         r3, [pc, #0x23C]
  00278	e1510003	 cmp         r1, r3
  0027c	0a000071	 beq         |$LN6@TWL_IOCont|
  00280	e3a03832	 mov         r3, #0x32, 16
  00284	e3833a01	 orr         r3, r3, #1, 20
  00288	e1510003	 cmp         r1, r3
  0028c	0a000050	 beq         |$LN24@TWL_IOCont|
  00290	e59f321c	 ldr         r3, [pc, #0x21C]
  00294	e1510003	 cmp         r1, r3
  00298	0a00003b	 beq         |$LN11@TWL_IOCont|
  0029c	e59f320c	 ldr         r3, [pc, #0x20C]
  002a0	e1510003	 cmp         r1, r3
  002a4	0a000004	 beq         |$LN20@TWL_IOCont|
  002a8	e59f31fc	 ldr         r3, [pc, #0x1FC]
  002ac	e1510003	 cmp         r1, r3
  002b0	1a00006d	 bne         |$cleanUp$36891|

; 1791 :                     }
; 1792 :                 rc = TRUE;

  002b4	e3a06001	 mov         r6, #1

; 1793 :                 break;

  002b8	ea00006b	 b           |$cleanUp$36891|
  002bc		 |$LN20@TWL_IOCont|

; 1857 :                         }
; 1858 :                 }
; 1859 :             break;
; 1860 : 
; 1861 :         // deprecated
; 1862 :         case IOCTL_POWER_QUERY: 
; 1863 :             rc = TRUE;
; 1864 :             DEBUGMSG(ZONE_INFO,(L"TWL: Received IOCTL_POWER_QUERY\r\n"));
; 1865 :             break;
; 1866 : 
; 1867 :         // requests a change from one device power state to another
; 1868 :         case IOCTL_POWER_SET: 
; 1869 :             DEBUGMSG(ZONE_INFO,(L"TWL: Received IOCTL_POWER_SET\r\n"));
; 1870 :             if (pOutBuffer && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  002bc	e59b4000	 ldr         r4, [r11]
  002c0	e3540000	 cmp         r4, #0
  002c4	0a000068	 beq         |$cleanUp$36891|
  002c8	e59b3004	 ldr         r3, [r11, #4]
  002cc	e3530004	 cmp         r3, #4
  002d0	3a000065	 bcc         |$cleanUp$36891|
  002d4		 |$LN72@TWL_IOCont|

; 1871 :                 {
; 1872 :                 __try 
; 1873 :                     {
; 1874 :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pOutBuffer;

  002d4	e5943000	 ldr         r3, [r4]
  002d8	e3530000	 cmp         r3, #0

; 1875 :                     switch (ReqDx)

  002dc	0a000016	 beq         |$LN15@TWL_IOCont|
  002e0	da00001a	 ble         |$LN103@TWL_IOCont|
  002e4	e3530002	 cmp         r3, #2
  002e8	da00000e	 ble         |$LN14@TWL_IOCont|
  002ec	e3530003	 cmp         r3, #3
  002f0	0a000007	 beq         |$LN13@TWL_IOCont|
  002f4	e3530004	 cmp         r3, #4
  002f8	1a000014	 bne         |$LN103@TWL_IOCont|

; 1892 : 
; 1893 :                         case D4:
; 1894 :                             SetInterruptMode(pDevice, kTritonIntrDisabled);

  002fc	e3a01002	 mov         r1, #2
  00300	e1a00007	 mov         r0, r7
  00304	eb000000	 bl          |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z|

; 1895 :                             pDevice->powerState = D4;

  00308	e3a01004	 mov         r1, #4
  0030c	e5871044	 str         r1, [r7, #0x44]

; 1896 :                             break;

  00310	ea00000f	 b           |$LN16@TWL_IOCont|
  00314		 |$LN13@TWL_IOCont|

; 1887 : 
; 1888 :                         case D3:
; 1889 :                             SetInterruptMode(pDevice, kTritonIntrWakeup);

  00314	e3a01001	 mov         r1, #1
  00318	e1a00007	 mov         r0, r7
  0031c	eb000000	 bl          |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z|

; 1890 :                             pDevice->powerState = D3;

  00320	e3a03003	 mov         r3, #3

; 1891 :                             break;

  00324	ea000008	 b           |$LN106@TWL_IOCont|
  00328		 |$LN14@TWL_IOCont|

; 1880 :                             break;
; 1881 :                             
; 1882 :                         case D1:
; 1883 :                         case D2:
; 1884 :                             SetInterruptMode(pDevice, kTritonIntrEnabled);

  00328	e3a01000	 mov         r1, #0
  0032c	e1a00007	 mov         r0, r7
  00330	eb000000	 bl          |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z|

; 1885 :                             pDevice->powerState = D2;

  00334	e3a03002	 mov         r3, #2

; 1886 :                             break;

  00338	ea000003	 b           |$LN106@TWL_IOCont|
  0033c		 |$LN15@TWL_IOCont|

; 1876 :                         {
; 1877 :                         case D0:
; 1878 :                             SetInterruptMode(pDevice, kTritonIntrEnabled);

  0033c	e3a01000	 mov         r1, #0
  00340	e1a00007	 mov         r0, r7
  00344	eb000000	 bl          |?SetInterruptMode@@YAHPAUDevice_t@@W4InterruptMode_e@@@Z|

; 1879 :                             pDevice->powerState = D0;

  00348	e3a03000	 mov         r3, #0
  0034c		 |$LN106@TWL_IOCont|
  0034c	e5873044	 str         r3, [r7, #0x44]
  00350		 |$LN103@TWL_IOCont|
  00350	e3a01004	 mov         r1, #4
  00354		 |$LN16@TWL_IOCont|

; 1897 :                         }
; 1898 :                     *(PCEDEVICE_POWER_STATE)pOutBuffer = pDevice->powerState;

  00354	e5973044	 ldr         r3, [r7, #0x44]

; 1899 :                     *pOutSize = sizeof(CEDEVICE_POWER_STATE);

  00358	e59b2008	 ldr         r2, [r11, #8]
  0035c	e5843000	 str         r3, [r4]
  00360	e5821000	 str         r1, [r2]

; 1900 :                     DEBUGMSG(ZONE_INFO, (L"TWL: IOCTL_POWER_SET to D%u \r\n",
; 1901 :                         pDevice->powerState
; 1902 :                         ));
; 1903 : 
; 1904 :                     rc = TRUE;

  00364	e3a06001	 mov         r6, #1
  00368	e50b6048	 str         r6, [r11, #-0x48]
  0036c		 |$LN73@TWL_IOCont|

; 1905 :                     }

  0036c	ea00003e	 b           |$cleanUp$36891|
  00370		 |$LN69@TWL_IOCont|

; 1907 :                     {
; 1908 :                     RETAILMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));

  00370	e59f312c	 ldr         r3, [pc, #0x12C]
  00374	e5933440	 ldr         r3, [r3, #0x440]
  00378	e3130001	 tst         r3, #1
  0037c	159f0124	 ldrne       r0, [pc, #0x124]
  00380	1b000000	 blne        NKDbgPrintfW
  00384	e51b6048	 ldr         r6, [r11, #-0x48]
  00388	ea000037	 b           |$cleanUp$36891|
  0038c		 |$LN11@TWL_IOCont|

; 1909 :                     }
; 1910 :             }
; 1911 :             break;
; 1912 : 
; 1913 :         // gets the current device power state
; 1914 :         case IOCTL_POWER_GET: 
; 1915 :             DEBUGMSG(ZONE_INFO, (L"TWL: Received IOCTL_POWER_GET\r\n"));
; 1916 :             if (pOutBuffer != NULL && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  0038c	e59b2000	 ldr         r2, [r11]
  00390	e3520000	 cmp         r2, #0
  00394	0a000034	 beq         |$cleanUp$36891|
  00398	e59b3004	 ldr         r3, [r11, #4]
  0039c	e3530004	 cmp         r3, #4
  003a0	3a000031	 bcc         |$cleanUp$36891|
  003a4		 |$LN79@TWL_IOCont|

; 1917 :                 {
; 1918 :                 __try 
; 1919 :                     {
; 1920 :                     *(PCEDEVICE_POWER_STATE)pOutBuffer = pDevice->powerState;

  003a4	e5973044	 ldr         r3, [r7, #0x44]
  003a8	e5823000	 str         r3, [r2]

; 1921 :  
; 1922 :                     rc = TRUE;

  003ac	e3a06001	 mov         r6, #1
  003b0	e50b6048	 str         r6, [r11, #-0x48]
  003b4		 |$LN80@TWL_IOCont|

; 1923 : 
; 1924 :                     DEBUGMSG(ZONE_INFO, (L"TWL: "
; 1925 :                             L"IOCTL_POWER_GET to D%u \r\n",
; 1926 :                             pDevice->powerState
; 1927 :                             ));
; 1928 :                     }

  003b4	ea00002c	 b           |$cleanUp$36891|
  003b8		 |$LN76@TWL_IOCont|

; 1930 :                     {
; 1931 :                     RETAILMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));

  003b8	e59f30e4	 ldr         r3, [pc, #0xE4]
  003bc	e5933440	 ldr         r3, [r3, #0x440]
  003c0	e3130001	 tst         r3, #1
  003c4	159f00dc	 ldrne       r0, [pc, #0xDC]
  003c8	1b000000	 blne        NKDbgPrintfW
  003cc	e51b6048	 ldr         r6, [r11, #-0x48]
  003d0	ea000025	 b           |$cleanUp$36891|
  003d4		 |$LN24@TWL_IOCont|

; 1834 : 
; 1835 :         case IOCTL_POWER_CAPABILITIES: 
; 1836 :             DEBUGMSG(ZONE_INFO, (L"TWL: Received IOCTL_POWER_CAPABILITIES\r\n"));
; 1837 :             if (pOutBuffer && outSize >= sizeof (POWER_CAPABILITIES) && 
; 1838 :                 pOutSize) 

  003d4	e59b4000	 ldr         r4, [r11]
  003d8	e3540000	 cmp         r4, #0
  003dc	0a000022	 beq         |$cleanUp$36891|
  003e0	e59b3004	 ldr         r3, [r11, #4]
  003e4	e3530030	 cmp         r3, #0x30
  003e8	3a00001f	 bcc         |$cleanUp$36891|
  003ec	e59b5008	 ldr         r5, [r11, #8]
  003f0	e3550000	 cmp         r5, #0
  003f4	0a00001c	 beq         |$cleanUp$36891|
  003f8		 |$LN65@TWL_IOCont|

; 1839 :                 {
; 1840 :                     __try 
; 1841 :                         {
; 1842 :                         PPOWER_CAPABILITIES PowerCaps;
; 1843 :                         PowerCaps = (PPOWER_CAPABILITIES)pOutBuffer;
; 1844 :          
; 1845 :                         // Only supports D0 (permanently on) and D4(off.         
; 1846 :                         memset(PowerCaps, 0, sizeof(*PowerCaps));

  003f8	e3a02030	 mov         r2, #0x30
  003fc	e3a01000	 mov         r1, #0
  00400	e1a00004	 mov         r0, r4
  00404	eb000000	 bl          memset

; 1847 :                         PowerCaps->DeviceDx = (DX_MASK(D0) | 
; 1848 :                                                DX_MASK(D2) | 
; 1849 :                                                DX_MASK(D3) | 
; 1850 :                                                DX_MASK(D4));

  00408	e3a0301d	 mov         r3, #0x1D
  0040c	e5c43000	 strb        r3, [r4]

; 1851 :                         *pOutSize = sizeof(*PowerCaps);                        

  00410	e3a03030	 mov         r3, #0x30
  00414	e5853000	 str         r3, [r5]

; 1852 :                         rc = TRUE;

  00418	e3a06001	 mov         r6, #1
  0041c	e50b6048	 str         r6, [r11, #-0x48]
  00420		 |$LN66@TWL_IOCont|

; 1853 :                         }

  00420	ea000011	 b           |$cleanUp$36891|
  00424		 |$LN62@TWL_IOCont|

; 1855 :                         {
; 1856 :                         RETAILMSG(ZONE_ERROR, (L"exception in ioctl\r\n"));

  00424	e59f3078	 ldr         r3, [pc, #0x78]
  00428	e5933440	 ldr         r3, [r3, #0x440]
  0042c	e3130001	 tst         r3, #1
  00430	159f0068	 ldrne       r0, [pc, #0x68]
  00434	1b000000	 blne        NKDbgPrintfW
  00438	e51b6048	 ldr         r6, [r11, #-0x48]
  0043c	ea00000a	 b           |$cleanUp$36891|
  00440		 |$LN104@TWL_IOCont|

; 1966 :         }
; 1967 : 
; 1968 : cleanUp:
; 1969 :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_IOControl(rc = %d)\r\n", rc));
; 1970 :     return rc;

  00440	e51b6044	 ldr         r6, [r11, #-0x44]
  00444	ea000008	 b           |$cleanUp$36891|
  00448		 |$LN6@TWL_IOCont|

; 1943 : 
; 1944 :         case IOCTL_TWL_WAKEENABLE:
; 1945 :             if (pInBuffer != NULL && inSize == sizeof(IOCTL_TWL_WAKEENABLE_IN))

  00448	e3550000	 cmp         r5, #0
  0044c	0a000006	 beq         |$cleanUp$36891|
  00450	e3580008	 cmp         r8, #8
  00454	1a000004	 bne         |$cleanUp$36891|

; 1946 :                 {
; 1947 :                 IOCTL_TWL_WAKEENABLE_IN *pInParam = (IOCTL_TWL_WAKEENABLE_IN*)pInBuffer;
; 1948 :                 rc = TWL_EnableWakeup(context, pInParam->intrId, pInParam->bEnable);

  00458	e5952004	 ldr         r2, [r5, #4]
  0045c	e5951000	 ldr         r1, [r5]
  00460	e1a00009	 mov         r0, r9
  00464	eb000000	 bl          |?TWL_EnableWakeup@@YAHKKH@Z|
  00468		 |$LN105@TWL_IOCont|
  00468	e1a06000	 mov         r6, r0
  0046c		 |$cleanUp$36891|

; 1971 : }

  0046c	e1a00006	 mov         r0, r6
  00470	e24bd024	 sub         sp, r11, #0x24
  00474	e89d6bf0	 ldmia       sp, {r4 - r9, r11, sp, lr}
  00478	e12fff1e	 bx          lr

			 ENDP  ; |?TWL_IOControl@@YAHKKPAEK0KPAK@Z|, TWL_IOControl

  0047c		 |$LN61@TWL_IOCont|
  0047c		 |$LN109@TWL_IOCont|

; 1854 :                     __except(EXCEPTION_EXECUTE_HANDLER) 

  0047c	e52de004	 str         lr, [sp, #-4]!
  00480		 |$LN64@TWL_IOCont|
  00480		 |$LN114@TWL_IOCont|
  00480	e3a00001	 mov         r0, #1
  00484		 |$LN63@TWL_IOCont|
  00484	e49df004	 ldr         pc, [sp], #4
  00488		 |$LN115@TWL_IOCont|
  00488		 |$LN75@TWL_IOCont|
  00488		 |$LN111@TWL_IOCont|

; 1929 :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00488	e52de004	 str         lr, [sp, #-4]!
  0048c		 |$LN78@TWL_IOCont|
  0048c		 |$LN116@TWL_IOCont|
  0048c	e3a00001	 mov         r0, #1
  00490		 |$LN77@TWL_IOCont|
  00490	e49df004	 ldr         pc, [sp], #4
  00494		 |$LN117@TWL_IOCont|
  00494		 |$LN68@TWL_IOCont|
  00494		 |$LN112@TWL_IOCont|

; 1906 :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00494	e52de004	 str         lr, [sp, #-4]!
  00498		 |$LN71@TWL_IOCont|
  00498		 |$LN118@TWL_IOCont|
  00498	e3a00001	 mov         r0, #1
  0049c		 |$LN70@TWL_IOCont|
  0049c	e49df004	 ldr         pc, [sp], #4
  004a0		 |$LN120@TWL_IOCont|
  004a0		 |$LN121@TWL_IOCont|
  004a0	00000000	 DCD         |??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  004a4		 |$LN122@TWL_IOCont|
  004a4	00000000	 DCD         |dpCurSettings|
  004a8		 |$LN123@TWL_IOCont|
  004a8	00000000	 DCD         |??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  004ac		 |$LN124@TWL_IOCont|
  004ac	0032100c	 DCD         0x32100c
  004b0		 |$LN125@TWL_IOCont|
  004b0	00321008	 DCD         0x321008
  004b4		 |$LN126@TWL_IOCont|
  004b4	00321004	 DCD         0x321004
  004b8		 |$LN127@TWL_IOCont|
  004b8	00220c18	 DCD         0x220c18
  004bc		 |$LN128@TWL_IOCont|
  004bc	00000000	 DCD         |?TWL_EnableWakeup@@YAHKKH@Z|
  004c0		 |$LN129@TWL_IOCont|
  004c0	00000000	 DCD         |?TWL_InterruptDisable@@YAHKK@Z|
  004c4		 |$LN130@TWL_IOCont|
  004c4	00000000	 DCD         |?TWL_InterruptMask@@YAHKKH@Z|
  004c8		 |$LN131@TWL_IOCont|
  004c8	00000000	 DCD         |?TWL_InterruptInitialize@@YAHKKPAX@Z|
  004cc		 |$LN132@TWL_IOCont|
  004cc	00000000	 DCD         |?TWL_WriteRegs@@YAHKKPBXK@Z|
  004d0		 |$LN133@TWL_IOCont|
  004d0	00000000	 DCD         |?TWL_ReadRegs@@YAHKKPAXK@Z|
  004d4		 |$LN134@TWL_IOCont|
  004d4	00000000	 DCD         |DEVICE_IFC_TWL_GUID|
  004d8		 |$LN135@TWL_IOCont|
  004d8	00220c0c	 DCD         0x220c0c
  004dc		 |$LN136@TWL_IOCont|
  004dc	00220c04	 DCD         0x220c04
  004e0		 |$LN137@TWL_IOCont|
  004e0	00220c14	 DCD         0x220c14
  004e4		 |$LN138@TWL_IOCont|
  004e4	74776c44	 DCD         0x74776c44
  004e8		 |$LN139@TWL_IOCont|
  004e8	74776c49	 DCD         0x74776c49
  004ec		 |$LN119@TWL_IOCont|
  004ec		 |$LN113@TWL_IOCont|
	EXPORT	|__$ArrayPad$| [ DATA ]

  00000			 AREA	 |.pdata|, PDATA
|$T37852| DCD	|$LN5@Initialize@2|
	DCD	0xc0009a02

  00000			 AREA	 |.xdata|, DATA
|$T37848| DCD	0xffffffe8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37848|

  00008		 |?InitializeInterrupts@@YAHPAUDevice_t@@@Z| PROC ; InitializeInterrupts

; 1984 : {

  00008		 |$LN5@Initialize@2|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M37849|
  00010	e1a04000	 mov         r4, r0
  00014	e59f3250	 ldr         r3, [pc, #0x250]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3008	 str         r3, [sp, #8]
  00020	e3a06803	 mov         r6, #3, 16

; 1985 :     BOOL rc = TRUE;
; 1986 :     UINT8 data[5];
; 1987 : 
; 1988 :     // mask all interrupts
; 1989 :     data[0] = 0xFF;

  00024	e3a0e0ff	 mov         lr, #0xFF

; 1990 :     WriteRegs(pDevice, TWL_PWR_IMR1, data, 1);

  00028	e386102f	 orr         r1, r6, #0x2F
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2000	 add         r2, sp, #0
  00034	e5cde000	 strb        lr, [sp]
  00038	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  0003c	e3a07802	 mov         r7, #2, 16

; 1991 :     WriteRegs(pDevice, TWL_BCIIMR1A, data, 1);

  00040	e38710bb	 orr         r1, r7, #0xBB
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1992 :     WriteRegs(pDevice, TWL_BCIIMR2A, data, 1);

  00054	e3a03001	 mov         r3, #1
  00058	e28d2000	 add         r2, sp, #0
  0005c	e38710bc	 orr         r1, r7, #0xBC
  00060	e1a00004	 mov         r0, r4
  00064	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1993 :     WriteRegs(pDevice, TWL_MADC_IMR1, data, 1);    

  00068	e3a03001	 mov         r3, #1
  0006c	e28d2000	 add         r2, sp, #0
  00070	e3871062	 orr         r1, r7, #0x62
  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1994 :     WriteRegs(pDevice, TWL_KEYP_IMR1, data, 1);

  0007c	e3a03001	 mov         r3, #1
  00080	e28d2000	 add         r2, sp, #0
  00084	e38710e4	 orr         r1, r7, #0xE4
  00088	e1a00004	 mov         r0, r4
  0008c	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00090	e3a05801	 mov         r5, #1, 16

; 1995 :     WriteRegs(pDevice, TWL_GPIO_IMR1A, data, 1);

  00094	e38510b4	 orr         r1, r5, #0xB4
  00098	e3a03001	 mov         r3, #1
  0009c	e28d2000	 add         r2, sp, #0
  000a0	e1a00004	 mov         r0, r4
  000a4	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1996 :     WriteRegs(pDevice, TWL_GPIO_IMR2A, data, 1);

  000a8	e3a03001	 mov         r3, #1
  000ac	e28d2000	 add         r2, sp, #0
  000b0	e38510b5	 orr         r1, r5, #0xB5
  000b4	e1a00004	 mov         r0, r4
  000b8	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1997 :     WriteRegs(pDevice, TWL_GPIO_IMR3A, data, 1);

  000bc	e3a03001	 mov         r3, #1
  000c0	e28d2000	 add         r2, sp, #0
  000c4	e38510b6	 orr         r1, r5, #0xB6
  000c8	e1a00004	 mov         r0, r4
  000cc	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 1998 : 
; 1999 :     // Clear all USB interrupts
; 2000 :     ReadRegs(pDevice, TWL_USB_INT_LATCH, &data[0], 1);

  000d0	e3a03001	 mov         r3, #1
  000d4	e28d2000	 add         r2, sp, #0
  000d8	e3a01014	 mov         r1, #0x14
  000dc	e1a00004	 mov         r0, r4
  000e0	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2001 :     ReadRegs(pDevice, TWL_OTHER_INT_LATCH, &data[0], 1);

  000e4	e3a03001	 mov         r3, #1
  000e8	e28d2000	 add         r2, sp, #0
  000ec	e3a0108d	 mov         r1, #0x8D
  000f0	e1a00004	 mov         r0, r4
  000f4	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2002 :     ReadRegs(pDevice, TWL_CARKIT_INT_LATCH, &data[0], 1);

  000f8	e3a03001	 mov         r3, #1
  000fc	e28d2000	 add         r2, sp, #0
  00100	e3a01021	 mov         r1, #0x21
  00104	e1a00004	 mov         r0, r4
  00108	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2003 :     ReadRegs(pDevice, TWL_CARKIT_SM_1_INT_LATCH, &data[0], 1);

  0010c	e3a03001	 mov         r3, #1
  00110	e28d2000	 add         r2, sp, #0
  00114	e3a0109b	 mov         r1, #0x9B
  00118	e1a00004	 mov         r0, r4
  0011c	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2004 :     ReadRegs(pDevice, TWL_CARKIT_SM_2_INT_LATCH, &data[0], 1);

  00120	e3a03001	 mov         r3, #1
  00124	e28d2000	 add         r2, sp, #0
  00128	e3a010a0	 mov         r1, #0xA0
  0012c	e1a00004	 mov         r0, r4
  00130	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2005 :     ReadRegs(pDevice, TWL_REG_CTRL_ERROR, &data[0], 1);

  00134	e3a03001	 mov         r3, #1
  00138	e28d2000	 add         r2, sp, #0
  0013c	e3a010b5	 mov         r1, #0xB5
  00140	e1a00004	 mov         r0, r4
  00144	eb000000	 bl          |?ReadRegs@@YAHPAUDevice_t@@KPAXK@Z|

; 2006 : 
; 2007 :     // Disable all USB interrupts
; 2008 :     data[0] = 0xFF;

  00148	e3a030ff	 mov         r3, #0xFF
  0014c	e5cd3000	 strb        r3, [sp]

; 2009 :     WriteRegs(pDevice, TWL_USB_INT_EN_FALL_CLR, data, 1);

  00150	e3a03001	 mov         r3, #1
  00154	e28d2000	 add         r2, sp, #0
  00158	e3a01012	 mov         r1, #0x12
  0015c	e1a00004	 mov         r0, r4
  00160	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2010 :     WriteRegs(pDevice, TWL_USB_INT_EN_RISE_CLR, data, 1);

  00164	e3a03001	 mov         r3, #1
  00168	e28d2000	 add         r2, sp, #0
  0016c	e3a0100f	 mov         r1, #0xF
  00170	e1a00004	 mov         r0, r4
  00174	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2011 :     WriteRegs(pDevice, TWL_OTHER_INT_EN_RISE_CLR, data, 1);

  00178	e3a03001	 mov         r3, #1
  0017c	e28d2000	 add         r2, sp, #0
  00180	e3a01088	 mov         r1, #0x88
  00184	e1a00004	 mov         r0, r4
  00188	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2012 :     WriteRegs(pDevice, TWL_OTHER_INT_EN_FALL_CLR, data, 1);

  0018c	e3a03001	 mov         r3, #1
  00190	e28d2000	 add         r2, sp, #0
  00194	e3a0108b	 mov         r1, #0x8B
  00198	e1a00004	 mov         r0, r4
  0019c	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2013 :     WriteRegs(pDevice, TWL_CARKIT_INT_EN_CLR, data, 1);

  001a0	e3a03001	 mov         r3, #1
  001a4	e28d2000	 add         r2, sp, #0
  001a8	e3a0101f	 mov         r1, #0x1F
  001ac	e1a00004	 mov         r0, r4
  001b0	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2014 :     WriteRegs(pDevice, TWL_CARKIT_SM_1_INT_EN_CLR, data, 1);

  001b4	e3a03001	 mov         r3, #1
  001b8	e28d2000	 add         r2, sp, #0
  001bc	e3a01099	 mov         r1, #0x99
  001c0	e1a00004	 mov         r0, r4
  001c4	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2015 :     WriteRegs(pDevice, TWL_CARKIT_SM_2_INT_EN_CLR, data, 1);

  001c8	e3a03001	 mov         r3, #1
  001cc	e28d2000	 add         r2, sp, #0
  001d0	e3a0109e	 mov         r1, #0x9E
  001d4	e1a00004	 mov         r0, r4
  001d8	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2016 :     WriteRegs(pDevice, TWL_REG_CTRL_EN_CLR, data, 1);

  001dc	e3a03001	 mov         r3, #1
  001e0	e28d2000	 add         r2, sp, #0
  001e4	e3a010b4	 mov         r1, #0xB4
  001e8	e1a00004	 mov         r0, r4
  001ec	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2017 : 
; 2018 :     // put power and rtc interrupts in exclusive mode
; 2019 :     data[0] = TWL_SIH_CTRL_EXCLEN;

  001f0	e3a03001	 mov         r3, #1
  001f4	e5cd3000	 strb        r3, [sp]

; 2020 :     WriteRegs(pDevice, TWL_PWR_SIH_CTRL, data, 1);

  001f8	e3a03001	 mov         r3, #1
  001fc	e28d2000	 add         r2, sp, #0
  00200	e3861035	 orr         r1, r6, #0x35
  00204	e1a00004	 mov         r0, r4
  00208	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2021 : 
; 2022 :     // set edge interrupt and ctrl for power
; 2023 : 
; 2024 :     // RTC_IT_RISING
; 2025 :     // USB_PRES_RISING | USB_PRES_FALLING
; 2026 :     // CHG_PRES_RISING | CHG_PRES_FALLING
; 2027 :     data[0] = TWL_RTC_IT_RISING | TWL_USB_PRES_RISING | TWL_USB_PRES_FALLING |
; 2028 :               TWL_CHG_PRES_RISING | TWL_CHG_PRES_FALLING;

  0020c	e3a030bc	 mov         r3, #0xBC
  00210	e5cd3000	 strb        r3, [sp]

; 2029 :     
; 2030 :     WriteRegs(pDevice, TWL_PWR_EDR1, data, 1);

  00214	e3a03001	 mov         r3, #1
  00218	e28d2000	 add         r2, sp, #0
  0021c	e3861033	 orr         r1, r6, #0x33
  00220	e1a00004	 mov         r0, r4
  00224	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2031 : 
; 2032 :     // set edge interrupt and ctrl for keypad
; 2033 : 
; 2034 :     // set edge interrupt and ctrl for bci
; 2035 : 
; 2036 :     // interrupt on both edges for all interrupts
; 2037 :     data[0] = 0xFF;

  00228	e3a030ff	 mov         r3, #0xFF

; 2038 :     data[1] = 0xFF;

  0022c	e3a020ff	 mov         r2, #0xFF

; 2039 :     data[2] = 0xFF;

  00230	e3a010ff	 mov         r1, #0xFF
  00234	e5cd3000	 strb        r3, [sp]
  00238	e5cd2001	 strb        r2, [sp, #1]
  0023c	e5cd1002	 strb        r1, [sp, #2]

; 2040 :     WriteRegs(pDevice, TWL_BCIEDR1, data, 3);

  00240	e3a03003	 mov         r3, #3
  00244	e28d2000	 add         r2, sp, #0
  00248	e38710c3	 orr         r1, r7, #0xC3
  0024c	e1a00004	 mov         r0, r4
  00250	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|

; 2041 : 
; 2042 :     // set edge interrupt and ctrl for madc
; 2043 : 
; 2044 :     // set edge interrupt and ctrl for gpio
; 2045 : 
; 2046 :     // set interrupts for USB
; 2047 : 
; 2048 :     return rc;

  00254	e59d0008	 ldr         r0, [sp, #8]
  00258	eb000000	 bl          __security_check_cookie
  0025c	e3a00001	 mov         r0, #1

; 2049 : }

  00260	e28dd00c	 add         sp, sp, #0xC
  00264	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00268	e12fff1e	 bx          lr
  0026c		 |$LN6@Initialize@2|
  0026c		 |$LN7@Initialize@2|
  0026c	00000000	 DCD         |__security_cookie|
  00270		 |$M37850|

			 ENDP  ; |?InitializeInterrupts@@YAHPAUDevice_t@@@Z|, InitializeInterrupts

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T37866| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 2064 : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37863|
  00004	e1a04000	 mov         r4, r0

; 2065 :     UNREFERENCED_PARAMETER(pReserved);
; 2066 :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 2067 :         {
; 2068 :         case DLL_PROCESS_ATTACH:
; 2069 :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 2070 :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 2071 :             break;
; 2072 :         }
; 2073 :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 2074 : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M37864|

			 ENDP  ; |DllMain|

	EXPORT	|?TWL_Init@@YAKPBGPBX@Z|		; TWL_Init
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|GPIOInterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|GPIOOpen|
	IMPORT	|I2COpen|
	IMPORT	|BSPGetTritonBusID|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37881| DCD	|$LN23@TWL_Init|
	DCD	0x40006802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Init@@YAKPBGPBX@Z| PROC		; TWL_Init

; 788  : {

  00000		 |$LN23@TWL_Init|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37878|
  00008	e1a04000	 mov         r4, r0

; 789  :     DWORD rc = (DWORD)NULL;
; 790  :     Device_t *pDevice = NULL;
; 791  : 
; 792  :     UNREFERENCED_PARAMETER(pBusContext);
; 793  : 
; 794  :     DEBUGMSG(ZONE_FUNCTION, (
; 795  :         L"+TWL_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 796  :         ));
; 797  : 
; 798  :     // Create device structure
; 799  :     pDevice = (Device_t *)LocalAlloc(LPTR, sizeof(Device_t));

  0000c	e3a01e1a	 mov         r1, #0x1A, 28
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b05000	 movs        r5, r0

; 800  :     if (pDevice == NULL)

  00020	0a000051	 beq         |$LN20@TWL_Init|

; 801  :         {
; 802  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 803  :             L"Failed allocate TWL controller structure\r\n"
; 804  :             ));
; 805  :         goto cleanUp;
; 806  :         }
; 807  : 
; 808  :     // clear memory
; 809  :     memset(pDevice, 0, sizeof(Device_t));

  00024	e3a02e1a	 mov         r2, #0x1A, 28
  00028	e3a01000	 mov         r1, #0
  0002c	e1a00005	 mov         r0, r5
  00030	eb000000	 bl          memset

; 810  : 
; 811  :     // Set cookie and initial power state
; 812  :     pDevice->cookie = TWL_DEVICE_COOKIE;

  00034	e59f3160	 ldr         r3, [pc, #0x160]

; 813  :     pDevice->powerState = D0;

  00038	e3a07000	 mov         r7, #0

; 814  : 
; 815  :     // Initalize critical section
; 816  :     InitializeCriticalSection(&pDevice->cs);

  0003c	e2850018	 add         r0, r5, #0x18
  00040	e5853000	 str         r3, [r5]
  00044	e5857044	 str         r7, [r5, #0x44]
  00048	eb000000	 bl          InitializeCriticalSection

; 817  : 
; 818  :     // Read device parameters
; 819  :     if (GetDeviceRegistryParams(
; 820  :             szContext, pDevice, dimof(s_deviceRegParams), s_deviceRegParams
; 821  :             ) != ERROR_SUCCESS)

  0004c	e59f3144	 ldr         r3, [pc, #0x144]
  00050	e3a02002	 mov         r2, #2
  00054	e1a01005	 mov         r1, r5
  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          GetDeviceRegistryParams
  00060	e3500000	 cmp         r0, #0
  00064	1a000040	 bne         |$LN20@TWL_Init|

; 822  :         {
; 823  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 824  :             L"Failed read TWL driver registry parameters\r\n"
; 825  :             ));
; 826  :         goto cleanUp;
; 827  :         }
; 828  : 
; 829  :     // Open i2c bus
; 830  :     pDevice->hI2C = I2COpen(BSPGetTritonBusID());

  00068	eb000000	 bl          BSPGetTritonBusID
  0006c	eb000000	 bl          I2COpen
  00070	e3500000	 cmp         r0, #0
  00074	e5850010	 str         r0, [r5, #0x10]

; 831  :     if (pDevice->hI2C == NULL)

  00078	0a00003b	 beq         |$LN20@TWL_Init|

; 832  :         {
; 833  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 834  :             L"Failed open I2C bus driver\r\n"
; 835  :             ));
; 836  :         goto cleanUp;
; 837  :         }
; 838  :     I2CSetSlaveAddress(pDevice->hI2C, BSPGetTritonSlaveAddress());

  0007c	eb000000	 bl          BSPGetTritonSlaveAddress
  00080	e1a01800	 mov         r1, r0, lsl #16
  00084	e5950010	 ldr         r0, [r5, #0x10]
  00088	e1a01821	 mov         r1, r1, lsr #16
  0008c	eb000000	 bl          I2CSetSlaveAddress

; 839  : 
; 840  :     // Open gpio driver
; 841  :     pDevice->hGpio = GPIOOpen();

  00090	eb000000	 bl          GPIOOpen
  00094	e3500000	 cmp         r0, #0
  00098	e5850014	 str         r0, [r5, #0x14]

; 842  :     if (pDevice->hGpio == NULL)

  0009c	0a000032	 beq         |$LN20@TWL_Init|

; 843  :         {
; 844  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 845  :             L"Failed to open Gpio driver \r\n"
; 846  :             ));
; 847  :         goto cleanUp;
; 848  :         }
; 849  : 
; 850  :     InitializeHardware(pDevice);   

  000a0	e1a00005	 mov         r0, r5
  000a4	eb000000	 bl          |?InitializeHardware@@YAHPAUDevice_t@@@Z|

; 851  : 
; 852  :     // initialze callback arrays
; 853  :     s_pSIHRoutines[0] = ProcessSecondaryInterrupts;

  000a8	e59f40e4	 ldr         r4, [pc, #0xE4]
  000ac	e59f30dc	 ldr         r3, [pc, #0xDC]

; 854  :     s_pSIHRoutines[1] = ProcessSecondaryInterrupts_Keypad;

  000b0	e59f20d4	 ldr         r2, [pc, #0xD4]

; 855  :     s_pSIHRoutines[2] = ProcessSecondaryInterrupts;
; 856  :     s_pSIHRoutines[3] = ProcessSecondaryInterrupts;
; 857  :     s_pSIHRoutines[4] = ProcessSecondaryInterrupts_USB;

  000b4	e59f10cc	 ldr         r1, [pc, #0xCC]
  000b8	e1a00003	 mov         r0, r3
  000bc	e5843000	 str         r3, [r4]
  000c0	e5842004	 str         r2, [r4, #4]
  000c4	e1a0e003	 mov         lr, r3

; 858  :     s_pSIHRoutines[5] = ProcessSecondaryInterrupts;

  000c8	e5840008	 str         r0, [r4, #8]
  000cc	e584e00c	 str         lr, [r4, #0xC]
  000d0	e5841010	 str         r1, [r4, #0x10]

; 859  : 
; 860  :     // set triton interrupts to initial settings
; 861  :     if (!InitializeInterrupts(pDevice))

  000d4	e1a00005	 mov         r0, r5
  000d8	e5843014	 str         r3, [r4, #0x14]
  000dc	eb000000	 bl          |?InitializeInterrupts@@YAHPAUDevice_t@@@Z|
  000e0	e3500000	 cmp         r0, #0
  000e4	0a000020	 beq         |$LN20@TWL_Init|

; 862  :         {
; 863  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 864  :             L"Failed initialize triton interrupts\r\n"
; 865  :             ));
; 866  :         goto cleanUp;
; 867  :         }
; 868  : 
; 869  :     // NOTE:
; 870  :     //  Triton generates a low level interrupt.
; 871  :     GPIOSetMode(pDevice->hGpio, pDevice->gpio, GPIO_DIR_INPUT | GPIO_INT_LOW);

  000e8	e5951008	 ldr         r1, [r5, #8]
  000ec	e5950014	 ldr         r0, [r5, #0x14]
  000f0	e3a02009	 mov         r2, #9
  000f4	eb000000	 bl          GPIOSetMode

; 872  : 
; 873  :     //---------------------------------------------------------------------
; 874  :     
; 875  :     // Create interrupt event
; 876  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  000f8	e3a03000	 mov         r3, #0
  000fc	e3a02000	 mov         r2, #0
  00100	e3a01000	 mov         r1, #0
  00104	e3a00000	 mov         r0, #0
  00108	eb000000	 bl          CreateEventW
  0010c	e1b03000	 movs        r3, r0
  00110	e5853038	 str         r3, [r5, #0x38]

; 877  :     if (pDevice->hIntrEvent == NULL)

  00114	0a000014	 beq         |$LN20@TWL_Init|

; 878  :         {
; 879  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 880  :             L"Failed create interrupt event\r\n"
; 881  :             ));
; 882  :         goto cleanUp;
; 883  :         }
; 884  : 
; 885  :     // Initialize interrupt
; 886  :     if (!GPIOInterruptInitialize(pDevice->hGpio, pDevice->gpio, &pDevice->sysIntr, pDevice->hIntrEvent))

  00118	e5951008	 ldr         r1, [r5, #8]
  0011c	e5950014	 ldr         r0, [r5, #0x14]
  00120	e2852030	 add         r2, r5, #0x30
  00124	eb000000	 bl          GPIOInterruptInitialize
  00128	e3500000	 cmp         r0, #0
  0012c	0a00000e	 beq         |$LN20@TWL_Init|

; 887  :         {
; 888  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Init: "
; 889  :             L"InterruptInitialize failed\r\n"
; 890  :             ));
; 891  :         goto cleanUp;
; 892  :         }
; 893  : 
; 894  :     // Start interrupt service thread
; 895  :     pDevice->intrThreadExit = FALSE;
; 896  :     pDevice->hIntrThread = CreateThread(
; 897  :                                 NULL, 0, TWL_InterruptThread, pDevice, 0,NULL
; 898  :                                 );

  00130	e59f204c	 ldr         r2, [pc, #0x4C]
  00134	e1a03005	 mov         r3, r5
  00138	e3a01000	 mov         r1, #0
  0013c	e3a00000	 mov         r0, #0
  00140	e5857040	 str         r7, [r5, #0x40]
  00144	e58d7004	 str         r7, [sp, #4]
  00148	e58d7000	 str         r7, [sp]
  0014c	eb000000	 bl          CreateThread
  00150	e3500000	 cmp         r0, #0
  00154	e585003c	 str         r0, [r5, #0x3C]

; 899  :     if (!pDevice->hIntrThread)

  00158	0a000003	 beq         |$LN20@TWL_Init|

; 900  :         {
; 901  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Init: "
; 902  :             L"Failed create interrupt thread\r\n"
; 903  :             ));
; 904  :         goto cleanUp;
; 905  :         }
; 906  : 
; 907  :     // Set thread priority
; 908  :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256);

  0015c	e595100c	 ldr         r1, [r5, #0xC]
  00160	eb000000	 bl          CeSetThreadPriority

; 909  : 
; 910  :     // Return non-null value
; 911  :     rc = (DWORD)pDevice;

  00164	e1a06005	 mov         r6, r5
  00168		 |$cleanUp$36588|

; 912  :     
; 913  : cleanUp:
; 914  :     if (rc == 0) TWL_Deinit((DWORD)pDevice);

  00168	ea000001	 b           |$LN1@TWL_Init|
  0016c		 |$LN20@TWL_Init|
  0016c	e1a00005	 mov         r0, r5
  00170	eb000000	 bl          |?TWL_Deinit@@YAHK@Z|
  00174		 |$LN1@TWL_Init|

; 915  :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_Init(rc = %d\r\n", rc));
; 916  :     return rc;
; 917  : }

  00174	e1a00006	 mov         r0, r6
  00178	e28dd008	 add         sp, sp, #8
  0017c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00180	e12fff1e	 bx          lr
  00184		 |$LN24@TWL_Init|
  00184		 |$LN25@TWL_Init|
  00184	00000000	 DCD         |?TWL_InterruptThread@@YAKPAX@Z|
  00188		 |$LN26@TWL_Init|
  00188	00000000	 DCD         |?ProcessSecondaryInterrupts_USB@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|
  0018c		 |$LN27@TWL_Init|
  0018c	00000000	 DCD         |?ProcessSecondaryInterrupts_Keypad@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|
  00190		 |$LN28@TWL_Init|
  00190	00000000	 DCD         |?ProcessSecondaryInterrupts@@YAHPAUDevice_t@@PAPAXPBUSIHEntry_t@@@Z|
  00194		 |$LN29@TWL_Init|
  00194	00000000	 DCD         |s_pSIHRoutines|
  00198		 |$LN30@TWL_Init|
  00198	00000000	 DCD         |s_deviceRegParams|
  0019c		 |$LN31@TWL_Init|
  0019c	74776c44	 DCD         0x74776c44
  001a0		 |$M37879|

			 ENDP  ; |?TWL_Init@@YAKPBGPBX@Z|, TWL_Init

	EXPORT	|?TWL_Read@@YAKKPAXK@Z|			; TWL_Read

  00000			 AREA	 |.pdata|, PDATA
|$T37902| DCD	|$LN8@TWL_Read|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Read@@YAKKPAXK@Z| PROC		; TWL_Read

; 1055 : {

  00000		 |$LN8@TWL_Read|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37899|
  00004	e1a04001	 mov         r4, r1
  00008	e3500000	 cmp         r0, #0

; 1056 :     Instance_t *pInstance = (Instance_t*)context;
; 1057 : 
; 1058 :     if (pInstance == NULL || pInstance->cookie != TWL_INSTANCE_COOKIE)

  0000c	0a000009	 beq         |$LN2@TWL_Read|
  00010	e590e000	 ldr         lr, [r0]
  00014	e59f3028	 ldr         r3, [pc, #0x28]
  00018	e15e0003	 cmp         lr, r3
  0001c	1a000005	 bne         |$LN2@TWL_Read|

; 1061 :         goto cleanUp;
; 1062 :         }
; 1063 : 
; 1064 :     count = TWL_ReadRegs(context, pInstance->address, pBuffer, count);

  00020	e5901004	 ldr         r1, [r0, #4]
  00024	e1a03002	 mov         r3, r2
  00028	e1a02004	 mov         r2, r4
  0002c	eb000000	 bl          |?TWL_ReadRegs@@YAHKKPAXK@Z|

; 1065 : 
; 1066 : cleanUp:
; 1067 :     return count;
; 1068 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN2@TWL_Read|

; 1059 :         {
; 1060 :         count = 0;

  00038	e3a00000	 mov         r0, #0
  0003c		 |$cleanUp$36662|

; 1065 : 
; 1066 : cleanUp:
; 1067 :     return count;
; 1068 : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN9@TWL_Read|
  00044		 |$LN10@TWL_Read|
  00044	74776c49	 DCD         0x74776c49
  00048		 |$M37900|

			 ENDP  ; |?TWL_Read@@YAKKPAXK@Z|, TWL_Read

	EXPORT	|?TWL_Write@@YAKKPBXK@Z|		; TWL_Write

  00000			 AREA	 |.pdata|, PDATA
|$T37930| DCD	|$LN16@TWL_Write|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TWL_Write@@YAKKPBXK@Z| PROC		; TWL_Write

; 1082 : {

  00000		 |$LN16@TWL_Write|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37927|
  00004	e1a04002	 mov         r4, r2
  00008	e1a02001	 mov         r2, r1
  0000c	e3500000	 cmp         r0, #0

; 1083 :     Instance_t *pInstance = (Instance_t*)context;
; 1084 : 
; 1085 :     if (pInstance == NULL || pInstance->cookie != TWL_INSTANCE_COOKIE)

  00010	0a00000d	 beq         |$LN3@TWL_Write|
  00014	e590e000	 ldr         lr, [r0]
  00018	e59f303c	 ldr         r3, [pc, #0x3C]
  0001c	e15e0003	 cmp         lr, r3
  00020	1a000009	 bne         |$LN3@TWL_Write|

; 1088 :         goto cleanUp;
; 1089 :         }
; 1090 : 
; 1091 :     if (TWL_WriteRegs(context, pInstance->address, pBuffer, count) == FALSE)

  00024	e5901004	 ldr         r1, [r0, #4]
  00028	e5900008	 ldr         r0, [r0, #8]
  0002c	e35400ff	 cmp         r4, #0xFF
  00030	8a000005	 bhi         |$LN3@TWL_Write|
  00034	e31104ff	 tst         r1, #0xFF, 8
  00038	1a000003	 bne         |$LN3@TWL_Write|
  0003c	e1a03004	 mov         r3, r4
  00040	eb000000	 bl          |?WriteRegs@@YAHPAUDevice_t@@KPBXK@Z|
  00044	e3500000	 cmp         r0, #0
  00048		 |$cleanUp$37914|
  00048	1a000000	 bne         |$cleanUp$36673|
  0004c		 |$LN3@TWL_Write|

; 1086 :         {
; 1087 :         count = 0;

  0004c	e3a04000	 mov         r4, #0
  00050		 |$cleanUp$36673|

; 1092 :         {
; 1093 :         count = 0;
; 1094 :         }
; 1095 : 
; 1096 : cleanUp:
; 1097 :     return count;
; 1098 : }

  00050	e1a00004	 mov         r0, r4
  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN17@TWL_Write|
  0005c		 |$LN18@TWL_Write|
  0005c	74776c49	 DCD         0x74776c49
  00060		 |$M37928|

			 ENDP  ; |?TWL_Write@@YAKKPBXK@Z|, TWL_Write

	END

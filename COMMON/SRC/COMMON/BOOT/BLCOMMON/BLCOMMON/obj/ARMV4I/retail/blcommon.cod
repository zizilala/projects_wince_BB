; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\BOOT\BLCOMMON\blcommon.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|pTOC| [ DATA ]
	EXPORT	|NKSignon| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_pOEMCheckSignature|, 0x4

	 COMMON	|g_pOEMMultiBINNotify|, 0x4

	 COMMON	|g_pOEMReportError|, 0x4

	 COMMON	|g_dwROMOffset|, 0x4

	 COMMON	|g_pOEMVerifyMemory|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|g_fOEMNotified| % 0x4

  00000			 AREA	 |.data|, DATA
|g_bBINDownload| DCB 0x1
|g_downloadFilesRemaining| DCB 0x1

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|pTOC|	DCD	0xffffffff
	%	4
|NKSignon| DCB	0xa, "Microsoft Windows CE Bootloader Common Library Vers"
	DCB	"ion %d.%d Built Jul 10 2013 09:14:55", 0xd, 0xa, 0x0
; File c:\wince600\platform\common\src\common\boot\blcommon\blcommon.c

  00000			 AREA	 |.pdata|, PDATA
|$T40815| DCD	|$LN12@HALT|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HALT|	 PROC

; 145  : {

  00000		 |$LN12@HALT|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40812|

; 146  :     if (g_pOEMReportError)

  00004	e59f2014	 ldr         r2, [pc, #0x14]
  00008	e5923000	 ldr         r3, [r2]
  0000c	e3530000	 cmp         r3, #0

; 147  :     {
; 148  :         g_pOEMReportError (dwReason, 0);

  00010	13a01000	 movne       r1, #0
  00014	11a0e00f	 movne       lr, pc
  00018	112fff13	 bxne        r3
  0001c		 |$LL2@HALT|

; 149  :     }
; 150  :     SPIN_FOREVER;

  0001c	eafffffe	 b           |$LL2@HALT|
  00020		 |$LN13@HALT|
  00020		 |$LN14@HALT|
  00020	00000000	 DCD         |g_pOEMReportError|
  00024		 |$M40813|

			 ENDP  ; |HALT|

	IMPORT	|memset|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T40833| DCD	|$LN13@KernelRelo|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KernelRelocate| PROC

; 238  : {

  00000		 |$LN13@KernelRelo|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40830|
  00004	e1a04000	 mov         r4, r0

; 239  :     ULONG loop;
; 240  :     COPYentry *cptr;
; 241  :     if (pTOC == (ROMHDR *const) -1)

  00008	e3740001	 cmn         r4, #1

; 242  :     {
; 243  :         return (FALSE); // spin forever!

  0000c	03a00000	 moveq       r0, #0

; 255  : }

  00010	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}
  00014	012fff1e	 bxeq        lr

; 244  :     }
; 245  :     // This is where the data sections become valid... don't read globals until after this
; 246  :     for (loop = 0; loop < pTOC->ulCopyEntries; loop++)

  00018	e5943020	 ldr         r3, [r4, #0x20]
  0001c	e3a06000	 mov         r6, #0
  00020	e3530000	 cmp         r3, #0
  00024	9a000016	 bls         |$LN3@KernelRelo|
  00028	e3a07000	 mov         r7, #0
  0002c		 |$LL5@KernelRelo|
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e0875003	 add         r5, r7, r3

; 247  :     {
; 248  :         cptr = (COPYentry *)(pTOC->ulCopyOffset + loop*sizeof(COPYentry));
; 249  :         if (cptr->ulCopyLen)

  00034	e5953008	 ldr         r3, [r5, #8]
  00038	e3530000	 cmp         r3, #0

; 250  :             memcpy((LPVOID)cptr->ulDest,(LPVOID)cptr->ulSource,cptr->ulCopyLen);

  0003c	15951000	 ldrne       r1, [r5]
  00040	15950004	 ldrne       r0, [r5, #4]
  00044	11a02003	 movne       r2, r3
  00048	1b000000	 blne        memcpy

; 251  :         if (cptr->ulCopyLen != cptr->ulDestLen)

  0004c	e595200c	 ldr         r2, [r5, #0xC]
  00050	e5953008	 ldr         r3, [r5, #8]
  00054	e1530002	 cmp         r3, r2

; 252  :             memset((LPVOID)(cptr->ulDest+cptr->ulCopyLen),0,cptr->ulDestLen-cptr->ulCopyLen);

  00058	11a00003	 movne       r0, r3
  0005c	15953004	 ldrne       r3, [r5, #4]
  00060	10422000	 subne       r2, r2, r0
  00064	13a01000	 movne       r1, #0
  00068	10830000	 addne       r0, r3, r0
  0006c	1b000000	 blne        memset
  00070	e5943020	 ldr         r3, [r4, #0x20]
  00074	e2866001	 add         r6, r6, #1
  00078	e2877010	 add         r7, r7, #0x10
  0007c	e1560003	 cmp         r6, r3
  00080	3affffe9	 bcc         |$LL5@KernelRelo|
  00084		 |$LN3@KernelRelo|

; 253  :     }
; 254  :     return (TRUE);

  00084	e3a00001	 mov         r0, #1

; 255  : }

  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M40831|

			 ENDP  ; |KernelRelocate|

	EXPORT	|??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@| [ DATA ] ; `string'
	IMPORT	|KITLOutputDebugString|

  00000			 AREA	 |.pdata|, PDATA
|$T40851| DCD	|$LN14@VerifyChec|
	DCD	0x40001501

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@| DCB "ERROR:"
	DCB	" Checksum failure (expected=0x%x  computed=0x%x)", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VerifyChecksum| PROC

; 258  : {

  00000		 |$LN14@VerifyChec|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40848|
  00004	e1a0e002	 mov         lr, r2
  00008	e3500000	 cmp         r0, #0

; 259  :     // Check the CRC
; 260  :     DWORD dwCRC = 0;

  0000c	e3a02000	 mov         r2, #0

; 261  :     DWORD i;
; 262  :     for (i = 0; i < cbRecord; i++)

  00010	0a000003	 beq         |$LN2@VerifyChec|
  00014		 |$LL4@VerifyChec|

; 263  :         dwCRC += *pbRecord ++;

  00014	e4d13001	 ldrb        r3, [r1], #1
  00018	e2500001	 subs        r0, r0, #1
  0001c	e0822003	 add         r2, r2, r3
  00020	1afffffb	 bne         |$LL4@VerifyChec|
  00024		 |$LN2@VerifyChec|

; 264  : 
; 265  :     if (dwCRC != dwChksum)

  00024	e152000e	 cmp         r2, lr
  00028	0a000005	 beq         |$LN11@VerifyChec|

; 266  :         KITLOutputDebugString ("ERROR: Checksum failure (expected=0x%x  computed=0x%x)\r\n", dwChksum, dwCRC);

  0002c	e59f001c	 ldr         r0, [pc, #0x1C]
  00030	e1a0100e	 mov         r1, lr
  00034	eb000000	 bl          KITLOutputDebugString

; 267  : 
; 268  :     return (dwCRC == dwChksum);

  00038	e3a00000	 mov         r0, #0

; 269  : }

  0003c	e49de004	 ldr         lr, [sp], #4
  00040	e12fff1e	 bx          lr
  00044		 |$LN11@VerifyChec|

; 267  : 
; 268  :     return (dwCRC == dwChksum);

  00044	e3a00001	 mov         r0, #1

; 269  : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN15@VerifyChec|
  00050		 |$LN16@VerifyChec|
  00050	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  00054		 |$M40849|

			 ENDP  ; |VerifyChecksum|

	EXPORT	|??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07LAGBNAEN@R000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07HMMLNAND@S000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07MMNKOBGG@B000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07CBKBMMIF@X000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07JLHFPECJ@N000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@| [ DATA ] ; `string'
	IMPORT	|OEMReadData|
	IMPORT	|memcmp|

  00004			 AREA	 |.bss|, NOINIT
|g_hdr|	%	0x7
|g_hdr|	%	0x7

  00000			 AREA	 |.pdata|, PDATA
|$T40864| DCD	|$LN16@GetImageTy|
	DCD	0x40005001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_UNKNOWN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_SIGNED_NB0", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07LAGBNAEN@R000FF?6?$AA@| DCB "R000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_SIGNED_BIN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07HMMLNAND@S000FF?6?$AA@| DCB "S000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@| DCB 0xd, 0xa
	DCB	"BL_IMAGE_TYPE_BIN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07MMNKOBGG@B000FF?6?$AA@| DCB "B000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_MULTIXIP", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07CBKBMMIF@X000FF?6?$AA@| DCB "X000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_MANIFEST", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07JLHFPECJ@N000FF?6?$AA@| DCB "N000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read image signature.", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetImageType| PROC

; 273  : {

  00000		 |$LN16@GetImageTy|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40861|

; 274  :     BL_IMAGE_TYPE rval = BL_IMAGE_TYPE_UNKNOWN;
; 275  : 
; 276  :     // read the 7 byte "magic number"
; 277  :     //
; 278  :     if (!OEMReadData (BL_HDRSIG_SIZE, g_hdr))

  00004	e59f1108	 ldr         r1, [pc, #0x108]
  00008	e3a00007	 mov         r0, #7
  0000c	eb000000	 bl          OEMReadData
  00010	e3500000	 cmp         r0, #0

; 279  :     {
; 280  :         KITLOutputDebugString ("\r\nERROR: Unable to read image signature.\r\n");

  00014	059f0120	 ldreq       r0, [pc, #0x120]
  00018	0b000000	 bleq        KITLOutputDebugString

; 281  :         rval =  BL_IMAGE_TYPE_NOT_FOUND;
; 282  :     }
; 283  : 
; 284  :     
; 285  :     // The N000FF packet indicates a manifest, which is constructed by Platform 
; 286  :     // Builder when we're downloading multiple .bin files or an .nb0 file.
; 287  :     //
; 288  :     if (!memcmp (g_hdr, "N000FF\x0A", BL_HDRSIG_SIZE))

  0001c	e59f1114	 ldr         r1, [pc, #0x114]
  00020	e59f00ec	 ldr         r0, [pc, #0xEC]
  00024	e3a02007	 mov         r2, #7
  00028	eb000000	 bl          memcmp
  0002c	e3500000	 cmp         r0, #0
  00030	1a000004	 bne         |$LN10@GetImageTy|

; 289  :     {
; 290  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_MANIFEST\r\n\r\n");

  00034	e59f00f8	 ldr         r0, [pc, #0xF8]
  00038	eb000000	 bl          KITLOutputDebugString

; 291  :         rval =  BL_IMAGE_TYPE_MANIFEST;

  0003c	e3a00000	 mov         r0, #0

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$LN10@GetImageTy|

; 292  :     }
; 293  :     else if (!memcmp (g_hdr, "X000FF\x0A", BL_HDRSIG_SIZE))

  00048	e59f10e0	 ldr         r1, [pc, #0xE0]
  0004c	e59f00c0	 ldr         r0, [pc, #0xC0]
  00050	e3a02007	 mov         r2, #7
  00054	eb000000	 bl          memcmp
  00058	e3500000	 cmp         r0, #0
  0005c	1a000004	 bne         |$LN8@GetImageTy|

; 294  :     {
; 295  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_MULTIXIP\r\n\r\n");

  00060	e59f00c4	 ldr         r0, [pc, #0xC4]
  00064	eb000000	 bl          KITLOutputDebugString

; 296  :         rval =  BL_IMAGE_TYPE_MULTIXIP;

  00068	e3a00005	 mov         r0, #5

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  0006c	e49de004	 ldr         lr, [sp], #4
  00070	e12fff1e	 bx          lr
  00074		 |$LN8@GetImageTy|

; 297  :     }
; 298  :     else if (!memcmp (g_hdr, "B000FF\x0A", BL_HDRSIG_SIZE))

  00074	e59f10ac	 ldr         r1, [pc, #0xAC]
  00078	e59f0094	 ldr         r0, [pc, #0x94]
  0007c	e3a02007	 mov         r2, #7
  00080	eb000000	 bl          memcmp
  00084	e3500000	 cmp         r0, #0
  00088	1a000004	 bne         |$LN6@GetImageTy|

; 299  :     {
; 300  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_BIN\r\n\r\n");

  0008c	e59f0090	 ldr         r0, [pc, #0x90]
  00090	eb000000	 bl          KITLOutputDebugString

; 301  :         rval =  BL_IMAGE_TYPE_BIN;

  00094	e3a00001	 mov         r0, #1

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00098	e49de004	 ldr         lr, [sp], #4
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN6@GetImageTy|

; 302  :     }
; 303  :     else if (!memcmp (g_hdr, "S000FF\x0A", BL_HDRSIG_SIZE))

  000a0	e59f1078	 ldr         r1, [pc, #0x78]
  000a4	e59f0068	 ldr         r0, [pc, #0x68]
  000a8	e3a02007	 mov         r2, #7
  000ac	eb000000	 bl          memcmp
  000b0	e3500000	 cmp         r0, #0
  000b4	1a000004	 bne         |$LN4@GetImageTy|

; 304  :     {
; 305  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_SIGNED_BIN\r\n\r\n");

  000b8	e59f005c	 ldr         r0, [pc, #0x5C]
  000bc	eb000000	 bl          KITLOutputDebugString

; 306  :         rval =  BL_IMAGE_TYPE_SIGNED_BIN;

  000c0	e3a00003	 mov         r0, #3

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  000c4	e49de004	 ldr         lr, [sp], #4
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN4@GetImageTy|

; 307  :     }
; 308  :     else if (!memcmp (g_hdr, "R000FF\x0A", BL_HDRSIG_SIZE))

  000cc	e59f1044	 ldr         r1, [pc, #0x44]
  000d0	e59f003c	 ldr         r0, [pc, #0x3C]
  000d4	e3a02007	 mov         r2, #7
  000d8	eb000000	 bl          memcmp
  000dc	e3500000	 cmp         r0, #0
  000e0	1a000004	 bne         |$LN2@GetImageTy|

; 309  :     {
; 310  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_SIGNED_NB0\r\n\r\n");

  000e4	e59f0024	 ldr         r0, [pc, #0x24]
  000e8	eb000000	 bl          KITLOutputDebugString

; 311  :         rval =  BL_IMAGE_TYPE_SIGNED_NB0;

  000ec	e3a00004	 mov         r0, #4

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  000f0	e49de004	 ldr         lr, [sp], #4
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN2@GetImageTy|

; 312  :     }
; 313  :     else
; 314  :     {
; 315  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_UNKNOWN\r\n\r\n");

  000f8	e59f000c	 ldr         r0, [pc, #0xC]
  000fc	eb000000	 bl          KITLOutputDebugString

; 316  :         rval =  BL_IMAGE_TYPE_UNKNOWN;

  00100	e3a00006	 mov         r0, #6

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00104	e49de004	 ldr         lr, [sp], #4
  00108	e12fff1e	 bx          lr
  0010c		 |$LN17@GetImageTy|
  0010c		 |$LN18@GetImageTy|
  0010c	00000000	 DCD         |??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@|
  00110		 |$LN19@GetImageTy|
  00110	00000000	 DCD         |??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@|
  00114		 |$LN20@GetImageTy|
  00114	00000000	 DCD         |g_hdr|
  00118		 |$LN21@GetImageTy|
  00118	00000000	 DCD         |??_C@_07LAGBNAEN@R000FF?6?$AA@|
  0011c		 |$LN22@GetImageTy|
  0011c	00000000	 DCD         |??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@|
  00120		 |$LN23@GetImageTy|
  00120	00000000	 DCD         |??_C@_07HMMLNAND@S000FF?6?$AA@|
  00124		 |$LN24@GetImageTy|
  00124	00000000	 DCD         |??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@|
  00128		 |$LN25@GetImageTy|
  00128	00000000	 DCD         |??_C@_07MMNKOBGG@B000FF?6?$AA@|
  0012c		 |$LN26@GetImageTy|
  0012c	00000000	 DCD         |??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@|
  00130		 |$LN27@GetImageTy|
  00130	00000000	 DCD         |??_C@_07CBKBMMIF@X000FF?6?$AA@|
  00134		 |$LN28@GetImageTy|
  00134	00000000	 DCD         |??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@|
  00138		 |$LN29@GetImageTy|
  00138	00000000	 DCD         |??_C@_07JLHFPECJ@N000FF?6?$AA@|
  0013c		 |$LN30@GetImageTy|
  0013c	00000000	 DCD         |??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@|
  00140		 |$M40862|

			 ENDP  ; |GetImageType|

	EXPORT	|??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@| [ DATA ] ; `string'

  00012			 AREA	 |.bss|, NOINIT
|g_DownloadManifest| % 0x1a30
|g_DownloadManifest| % 0x1a30

  00000			 AREA	 |.pdata|, PDATA
|$T40952| DCD	|$LN59@CheckImage|
	DCD	0x40004b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read download manifest information.", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@| DCB 0xd, 0xa
	DCB	"ERROR: Download manifest packet failed checksum verifica"
	DCB	"tion.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read download manifest checksum.", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CheckImageManifest| PROC

; 324  : {

  00000		 |$LN59@CheckImage|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M40949|

; 325  :     DWORD dwRecChk;
; 326  : 
; 327  :     // read the packet checksum.
; 328  :     //
; 329  :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecChk))

  00008	e28d1000	 add         r1, sp, #0
  0000c	e3a00004	 mov         r0, #4
  00010	eb000000	 bl          OEMReadData
  00014	e3500000	 cmp         r0, #0
  00018	1a000009	 bne         |$LN4@CheckImage|

; 330  :     {
; 331  :         KITLOutputDebugString("\r\nERROR: Unable to read download manifest checksum.\r\n");

  0001c	e59f0104	 ldr         r0, [pc, #0x104]
  00020	eb000000	 bl          KITLOutputDebugString

; 332  :         HALT (BLERR_MAGIC);

  00024	e59f20e8	 ldr         r2, [pc, #0xE8]
  00028	e5923000	 ldr         r3, [r2]
  0002c	e3530000	 cmp         r3, #0
  00030	13a01000	 movne       r1, #0
  00034	13e00007	 mvnne       r0, #7
  00038	11a0e00f	 movne       lr, pc
  0003c	112fff13	 bxne        r3
  00040		 |$LL8@CheckImage|
  00040	eafffffe	 b           |$LL8@CheckImage|
  00044		 |$LN4@CheckImage|

; 333  :         return FALSE;
; 334  :     }
; 335  : 
; 336  :     // read region descriptions (start address and length).
; 337  :     //
; 338  :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &g_DownloadManifest.dwNumRegions) ||
; 339  :         !OEMReadData ((g_DownloadManifest.dwNumRegions * sizeof(RegionInfo)), (LPBYTE) &g_DownloadManifest.Region[0]))

  00044	e59f40d8	 ldr         r4, [pc, #0xD8]
  00048	e3a00004	 mov         r0, #4
  0004c	e1a01004	 mov         r1, r4
  00050	eb000000	 bl          OEMReadData
  00054	e3500000	 cmp         r0, #0
  00058	0a000023	 beq         |$LN2@CheckImage|
  0005c	e5943000	 ldr         r3, [r4]
  00060	e3a02f43	 mov         r2, #0x43, 30
  00064	e2841004	 add         r1, r4, #4
  00068	e0000293	 mul         r0, r3, r2
  0006c	eb000000	 bl          OEMReadData
  00070	e3500000	 cmp         r0, #0
  00074	0a00001c	 beq         |$LN2@CheckImage|

; 343  :         return FALSE;
; 344  :     }
; 345  : 
; 346  :     // verify the packet checksum.
; 347  :     //
; 348  :     if (!VerifyChecksum((g_DownloadManifest.dwNumRegions * sizeof(RegionInfo)), (LPBYTE) &g_DownloadManifest.Region[0], dwRecChk))

  00078	e5943000	 ldr         r3, [r4]
  0007c	e3a02f43	 mov         r2, #0x43, 30
  00080	e2841004	 add         r1, r4, #4
  00084	e0100293	 muls        r0, r3, r2
  00088	e3a02000	 mov         r2, #0
  0008c	0a000003	 beq         |$LN18@CheckImage|
  00090		 |$LL20@CheckImage|
  00090	e4d13001	 ldrb        r3, [r1], #1
  00094	e2500001	 subs        r0, r0, #1
  00098	e0822003	 add         r2, r2, r3
  0009c	1afffffb	 bne         |$LL20@CheckImage|
  000a0		 |$LN18@CheckImage|
  000a0	e59d1000	 ldr         r1, [sp]
  000a4	e1520001	 cmp         r2, r1
  000a8	0a00000b	 beq         |$LN1@CheckImage|
  000ac	e59f006c	 ldr         r0, [pc, #0x6C]
  000b0	eb000000	 bl          KITLOutputDebugString

; 349  :     {
; 350  :         KITLOutputDebugString ("\r\nERROR: Download manifest packet failed checksum verification.\r\n");

  000b4	e59f0060	 ldr         r0, [pc, #0x60]
  000b8	eb000000	 bl          KITLOutputDebugString

; 351  :         HALT (BLERR_CHECKSUM);

  000bc	e59f2050	 ldr         r2, [pc, #0x50]
  000c0	e5923000	 ldr         r3, [r2]
  000c4	e3530000	 cmp         r3, #0
  000c8	13a01000	 movne       r1, #0
  000cc	13e00006	 mvnne       r0, #6
  000d0	11a0e00f	 movne       lr, pc
  000d4	112fff13	 bxne        r3
  000d8		 |$LL26@CheckImage|
  000d8	eafffffe	 b           |$LL26@CheckImage|
  000dc		 |$LN1@CheckImage|

; 352  :         return FALSE;
; 353  :     }
; 354  : 
; 355  :     return TRUE;

  000dc	e3a00001	 mov         r0, #1

; 356  : }

  000e0	e28dd004	 add         sp, sp, #4
  000e4	e8bd4010	 ldmia       sp!, {r4, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$LN2@CheckImage|

; 340  :     {
; 341  :         KITLOutputDebugString("\r\nERROR: Unable to read download manifest information.\r\n");

  000ec	e59f0024	 ldr         r0, [pc, #0x24]
  000f0	eb000000	 bl          KITLOutputDebugString

; 342  :         HALT (BLERR_MAGIC);

  000f4	e59f2018	 ldr         r2, [pc, #0x18]
  000f8	e5923000	 ldr         r3, [r2]
  000fc	e3530000	 cmp         r3, #0
  00100	13a01000	 movne       r1, #0
  00104	13e00007	 mvnne       r0, #7
  00108	11a0e00f	 movne       lr, pc
  0010c	112fff13	 bxne        r3
  00110		 |$LL13@CheckImage|
  00110	eafffffe	 b           |$LL13@CheckImage|
  00114		 |$LN60@CheckImage|
  00114		 |$LN61@CheckImage|
  00114	00000000	 DCD         |g_pOEMReportError|
  00118		 |$LN62@CheckImage|
  00118	00000000	 DCD         |??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@|
  0011c		 |$LN63@CheckImage|
  0011c	00000000	 DCD         |??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@|
  00120		 |$LN64@CheckImage|
  00120	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  00124		 |$LN65@CheckImage|
  00124	00000000	 DCD         |g_DownloadManifest|
  00128		 |$LN66@CheckImage|
  00128	00000000	 DCD         |??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@|
  0012c		 |$M40950|

			 ENDP  ; |CheckImageManifest|

	EXPORT	|??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@| [ DATA ] ; `string'
	IMPORT	|OEMFinishEraseFlash|
	IMPORT	|OEMMapMemAddr|
	IMPORT	|OEMStartEraseFlash|
	IMPORT	|OEMIsFlashAddr|

  00000			 AREA	 |.pdata|, PDATA
|$T41014| DCD	|$LN47@DownloadNB|
	DCD	0x40008001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@| DCB "I"
	DCB	"mageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@| DCB "ERROR: "
	DCB	"failed when reading raw binary file.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@| DCB "Inva"
	DCB	"lid flash address/length", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@| DCB "!OEM"
	DCB	"VERIFYMEMORY: Invalid image", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DownloadNB0| PROC

; 1231 : {

  00000		 |$LN47@DownloadNB|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M41011|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a08000	 mov         r8, r0

; 1232 :     RegionInfo *pCurDownloadFile;
; 1233 :     BOOL        fIsFlash = FALSE;
; 1234 :     LPBYTE      lpDest = NULL;
; 1235 : 
; 1236 :     g_bBINDownload = FALSE;
; 1237 : 
; 1238 : 
; 1239 :     // Provide the download manifest to the OEM.  This gives the OEM the
; 1240 :     // opportunity to provide start addresses for the .nb0 files (which 
; 1241 :     // don't contain placement information like .bin files do).
; 1242 :     if (!g_fOEMNotified && g_pOEMMultiBINNotify)

  00010	e59f41e4	 ldr         r4, [pc, #0x1E4]
  00014	e59f51dc	 ldr         r5, [pc, #0x1DC]
  00018	e3a02000	 mov         r2, #0
  0001c	e5943000	 ldr         r3, [r4]
  00020	e59fa1cc	 ldr         r10, [pc, #0x1CC]
  00024	e5c52000	 strb        r2, [r5]
  00028	e3530000	 cmp         r3, #0
  0002c	1a000008	 bne         |$LN6@DownloadNB|
  00030	e59fe1b8	 ldr         lr, [pc, #0x1B8]
  00034	e59e3000	 ldr         r3, [lr]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000004	 beq         |$LN6@DownloadNB|

; 1243 :     {
; 1244 :         g_pOEMMultiBINNotify((PDownloadManifest)&g_DownloadManifest);

  00040	e28a0008	 add         r0, r10, #8
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 1245 :         g_fOEMNotified = TRUE;

  0004c	e3a03001	 mov         r3, #1
  00050	e5843000	 str         r3, [r4]
  00054		 |$LN6@DownloadNB|

; 1246 :     }
; 1247 : 
; 1248 :     // Locate the current download manifest entry (current download file).
; 1249 :     //
; 1250 :     pCurDownloadFile = &g_DownloadManifest.Region[g_DownloadManifest.dwNumRegions - g_downloadFilesRemaining];
; 1251 : 
; 1252 :     // give the OEM a chance to verify memory
; 1253 :     if (g_pOEMVerifyMemory && !g_pOEMVerifyMemory (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  00054	e59fe190	 ldr         lr, [pc, #0x190]
  00058	e59a0008	 ldr         r0, [r10, #8]
  0005c	e5d52001	 ldrb        r2, [r5, #1]
  00060	e59e1000	 ldr         r1, [lr]
  00064	e28a3008	 add         r3, r10, #8
  00068	e0402002	 sub         r2, r0, r2
  0006c	e3a00f43	 mov         r0, #0x43, 30
  00070	e2833004	 add         r3, r3, #4
  00074	e3510000	 cmp         r1, #0
  00078	e0253092	 mla         r5, r2, r0, r3
  0007c	0a000010	 beq         |$LN5@DownloadNB|
  00080	e5951004	 ldr         r1, [r5, #4]
  00084	e5950000	 ldr         r0, [r5]
  00088	e59e3000	 ldr         r3, [lr]
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff13	 bx          r3
  00094	e3500000	 cmp         r0, #0
  00098	1a000009	 bne         |$LN5@DownloadNB|

; 1254 :     {
; 1255 :         KITLOutputDebugString ("!OEMVERIFYMEMORY: Invalid image\r\n");

  0009c	e59f0144	 ldr         r0, [pc, #0x144]
  000a0	eb000000	 bl          KITLOutputDebugString

; 1256 :         HALT (BLERR_OEMVERIFY);

  000a4	e59f2130	 ldr         r2, [pc, #0x130]
  000a8	e5923000	 ldr         r3, [r2]
  000ac	e3530000	 cmp         r3, #0
  000b0	13a01000	 movne       r1, #0
  000b4	13e00008	 mvnne       r0, #8
  000b8	11a0e00f	 movne       lr, pc
  000bc	112fff13	 bxne        r3
  000c0		 |$LL10@DownloadNB|
  000c0	eafffffe	 b           |$LL10@DownloadNB|
  000c4		 |$LN5@DownloadNB|

; 1257 :         return (FALSE);
; 1258 :     }
; 1259 : 
; 1260 :     // check for flash image. Start erasing if it is.
; 1261 :     if ((fIsFlash = OEMIsFlashAddr (pCurDownloadFile->dwRegionStart)) 
; 1262 :         && !OEMStartEraseFlash (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  000c4	e5950000	 ldr         r0, [r5]
  000c8	eb000000	 bl          OEMIsFlashAddr
  000cc	e1b09000	 movs        r9, r0
  000d0	0a00000e	 beq         |$LN4@DownloadNB|
  000d4	e5951004	 ldr         r1, [r5, #4]
  000d8	e5950000	 ldr         r0, [r5]
  000dc	eb000000	 bl          OEMStartEraseFlash
  000e0	e3500000	 cmp         r0, #0
  000e4	1a000009	 bne         |$LN4@DownloadNB|

; 1263 :     {
; 1264 :         KITLOutputDebugString ("Invalid flash address/length\r\n");

  000e8	e59f00f4	 ldr         r0, [pc, #0xF4]
  000ec	eb000000	 bl          KITLOutputDebugString

; 1265 :         HALT (BLERR_FLASHADDR);

  000f0	e59f20e4	 ldr         r2, [pc, #0xE4]
  000f4	e5923000	 ldr         r3, [r2]
  000f8	e3530000	 cmp         r3, #0
  000fc	13a01000	 movne       r1, #0
  00100	13e00009	 mvnne       r0, #9
  00104	11a0e00f	 movne       lr, pc
  00108	112fff13	 bxne        r3
  0010c		 |$LL15@DownloadNB|
  0010c	eafffffe	 b           |$LL15@DownloadNB|
  00110		 |$LN4@DownloadNB|

; 1266 :         return (FALSE);
; 1267 :     }
; 1268 : 
; 1269 : 
; 1270 :     //------------------------------------------------------------------------
; 1271 :     //  Download the file
; 1272 :     //
; 1273 :     //  If we're downloading an UNSIGNED .nb0 file, we've already read the 
; 1274 :     //  start of the file in GetImageType().
; 1275 :     //  Copy what we've read so far to the destination, then finish downloading.
; 1276 :     //------------------------------------------------------------------------
; 1277 :     lpDest = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart);

  00110	e5950000	 ldr         r0, [r5]
  00114	e1a01000	 mov         r1, r0
  00118	eb000000	 bl          OEMMapMemAddr

; 1278 :     memcpy(lpDest, g_hdr, BL_HDRSIG_SIZE);

  0011c	e3a02007	 mov         r2, #7
  00120	e1a0100a	 mov         r1, r10
  00124	e1a04000	 mov         r4, r0
  00128	eb000000	 bl          memcpy

; 1279 :     lpDest += BL_HDRSIG_SIZE;
; 1280 : 
; 1281 :     if (!OEMReadData ((pCurDownloadFile->dwRegionLength - BL_HDRSIG_SIZE), lpDest))

  0012c	e5953004	 ldr         r3, [r5, #4]
  00130	e2841007	 add         r1, r4, #7
  00134	e2430007	 sub         r0, r3, #7
  00138	eb000000	 bl          OEMReadData
  0013c	e3500000	 cmp         r0, #0
  00140	1a000009	 bne         |$LN3@DownloadNB|

; 1282 :     {
; 1283 :         KITLOutputDebugString ("ERROR: failed when reading raw binary file.\r\n");

  00144	e59f0094	 ldr         r0, [pc, #0x94]
  00148	eb000000	 bl          KITLOutputDebugString

; 1284 :         HALT (BLERR_CORRUPTED_DATA);

  0014c	e59f2088	 ldr         r2, [pc, #0x88]
  00150	e5923000	 ldr         r3, [r2]
  00154	e3530000	 cmp         r3, #0
  00158	13a01000	 movne       r1, #0
  0015c	13e00003	 mvnne       r0, #3
  00160	11a0e00f	 movne       lr, pc
  00164	112fff13	 bxne        r3
  00168		 |$LL20@DownloadNB|
  00168	eafffffe	 b           |$LL20@DownloadNB|
  0016c		 |$LN3@DownloadNB|

; 1285 :         return (FALSE);
; 1286 :     }
; 1287 : 
; 1288 : 
; 1289 :     //------------------------------------------------------------------------
; 1290 :     //  Determine the image entry point
; 1291 :     //------------------------------------------------------------------------
; 1292 : 
; 1293 :     *pdwImageStart  = pCurDownloadFile->dwRegionStart;

  0016c	e5953000	 ldr         r3, [r5]

; 1294 :     *pdwLaunchAddr  = pCurDownloadFile->dwRegionStart;
; 1295 :     *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 1296 : 
; 1297 : 
; 1298 :     if (fIsFlash)

  00170	e3590000	 cmp         r9, #0
  00174	e5883000	 str         r3, [r8]
  00178	e5953000	 ldr         r3, [r5]
  0017c	e5863000	 str         r3, [r6]
  00180	e5953004	 ldr         r3, [r5, #4]
  00184	e5873000	 str         r3, [r7]
  00188	0a00000a	 beq         |$LN1@DownloadNB|

; 1299 :     {
; 1300 :         // finish the flash erase
; 1301 :         if (!OEMFinishEraseFlash())

  0018c	eb000000	 bl          OEMFinishEraseFlash
  00190	e3500000	 cmp         r0, #0
  00194	1a000007	 bne         |$LN1@DownloadNB|

; 1302 :         {
; 1303 :             HALT (BLERR_FLASH_ERASE);

  00198	e59f203c	 ldr         r2, [pc, #0x3C]
  0019c	e5923000	 ldr         r3, [r2]
  001a0	e3530000	 cmp         r3, #0
  001a4	13a01000	 movne       r1, #0
  001a8	13e0000a	 mvnne       r0, #0xA
  001ac	11a0e00f	 movne       lr, pc
  001b0	112fff13	 bxne        r3
  001b4		 |$LL25@DownloadNB|
  001b4	eafffffe	 b           |$LL25@DownloadNB|
  001b8		 |$LN1@DownloadNB|

; 1304 :             return (FALSE);
; 1305 :         }
; 1306 :     }
; 1307 : 
; 1308 :     KITLOutputDebugString("ImageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x\r\n",
; 1309 :         *pdwImageStart, *pdwImageLength, *pdwLaunchAddr);

  001b8	e5963000	 ldr         r3, [r6]
  001bc	e5972000	 ldr         r2, [r7]
  001c0	e5981000	 ldr         r1, [r8]
  001c4	e59f000c	 ldr         r0, [pc, #0xC]
  001c8	eb000000	 bl          KITLOutputDebugString

; 1310 : 
; 1311 :     return TRUE;

  001cc	e3a00001	 mov         r0, #1

; 1312 : }

  001d0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001d4	e12fff1e	 bx          lr
  001d8		 |$LN48@DownloadNB|
  001d8		 |$LN49@DownloadNB|
  001d8	00000000	 DCD         |??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@|
  001dc		 |$LN50@DownloadNB|
  001dc	00000000	 DCD         |g_pOEMReportError|
  001e0		 |$LN51@DownloadNB|
  001e0	00000000	 DCD         |??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@|
  001e4		 |$LN52@DownloadNB|
  001e4	00000000	 DCD         |??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@|
  001e8		 |$LN53@DownloadNB|
  001e8	00000000	 DCD         |??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@|
  001ec		 |$LN54@DownloadNB|
  001ec	00000000	 DCD         |g_pOEMVerifyMemory|
  001f0		 |$LN55@DownloadNB|
  001f0	00000000	 DCD         |g_pOEMMultiBINNotify|
  001f4		 |$LN56@DownloadNB|
  001f4	00000000	 DCD         |g_hdr|
  001f8		 |$LN57@DownloadNB|
  001f8	00000000	 DCD         |g_bBINDownload|
  001fc		 |$LN58@DownloadNB|
  001fc	00000000	 DCD         |g_fOEMNotified|
  00200		 |$M41012|

			 ENDP  ; |DownloadNB0|

	EXPORT	|??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_03ILDADBHF@RAM?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_05HPMNGINJ@FLASH?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@| [ DATA ] ; `string'
	IMPORT	|OEMWriteFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T41052| DCD	|$LN25@WriteImage|
	DCD	0x40003802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@| DCB "["
	DCB	"%d]: Address=0x%x  Length=0x%x  Name=""%s"" Target=%s", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_03ILDADBHF@RAM?$AA@| DCB "RAM", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_05HPMNGINJ@FLASH?$AA@| DCB "FLASH", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@| DCB 0xd, 0xa
	DCB	"Completed file(s):", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@| DCB "-"
	DCB	"--------------------------------------------------------"
	DCB	"----------------------", 0xd, 0xa, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteImageToFlash| PROC

; 1316 : {

  00000		 |$LN25@WriteImage|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41049|

; 1317 :     BOOL  bFlash;
; 1318 :     DWORD i;
; 1319 :     
; 1320 :     KITLOutputDebugString("\r\nCompleted file(s):\r\n");

  00008	e59f00cc	 ldr         r0, [pc, #0xCC]
  0000c	eb000000	 bl          KITLOutputDebugString

; 1321 :     KITLOutputDebugString("-------------------------------------------------------------------------------\r\n");

  00010	e59f00c0	 ldr         r0, [pc, #0xC0]
  00014	eb000000	 bl          KITLOutputDebugString

; 1322 : 
; 1323 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)

  00018	e59f50b4	 ldr         r5, [pc, #0xB4]
  0001c	e3a06000	 mov         r6, #0
  00020	e5953000	 ldr         r3, [r5]
  00024	e3530000	 cmp         r3, #0
  00028	0a000019	 beq         |$LN22@WriteImage|
  0002c	e2854004	 add         r4, r5, #4
  00030		 |$LL5@WriteImage|

; 1324 :     {
; 1325 :         RegionInfo *pRegion = &g_DownloadManifest.Region[i];
; 1326 : 
; 1327 :         bFlash = OEMIsFlashAddr( pRegion->dwRegionStart );

  00030	e5940000	 ldr         r0, [r4]
  00034	eb000000	 bl          OEMIsFlashAddr
  00038	e1b08000	 movs        r8, r0

; 1328 :         
; 1329 :         KITLOutputDebugString("[%d]: Address=0x%x  Length=0x%x  Name=\"%s\" Target=%s\r\n",
; 1330 :             i, 
; 1331 :             pRegion->dwRegionStart, 
; 1332 :             pRegion->dwRegionLength, 
; 1333 :             pRegion->szFileName,
; 1334 :             (bFlash ? "FLASH" : "RAM"));

  0003c	159f708c	 ldrne       r7, [pc, #0x8C]
  00040	059f7084	 ldreq       r7, [pc, #0x84]
  00044	e5943004	 ldr         r3, [r4, #4]
  00048	e5942000	 ldr         r2, [r4]
  0004c	e59f0074	 ldr         r0, [pc, #0x74]
  00050	e284e008	 add         lr, r4, #8
  00054	e1a01006	 mov         r1, r6
  00058	e58d7004	 str         r7, [sp, #4]
  0005c	e58de000	 str         lr, [sp]
  00060	eb000000	 bl          KITLOutputDebugString

; 1335 : 
; 1336 :         if (bFlash) 

  00064	e3580000	 cmp         r8, #0
  00068	0a000004	 beq         |$LN4@WriteImage|

; 1337 :         {
; 1338 :             if (!OEMWriteFlash (pRegion->dwRegionStart, pRegion->dwRegionLength))

  0006c	e5941004	 ldr         r1, [r4, #4]
  00070	e5940000	 ldr         r0, [r4]
  00074	eb000000	 bl          OEMWriteFlash
  00078	e3500000	 cmp         r0, #0
  0007c	0a000008	 beq         |$LN17@WriteImage|
  00080		 |$LN4@WriteImage|

; 1322 : 
; 1323 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)

  00080	e5953000	 ldr         r3, [r5]
  00084	e2866001	 add         r6, r6, #1
  00088	e2844f43	 add         r4, r4, #0x43, 30
  0008c	e1560003	 cmp         r6, r3
  00090	3affffe6	 bcc         |$LL5@WriteImage|
  00094		 |$LN22@WriteImage|

; 1341 :                 return FALSE;
; 1342 :             }
; 1343 :         }
; 1344 :     }
; 1345 : 
; 1346 :     return TRUE;    

  00094	e3a00001	 mov         r0, #1

; 1347 : }

  00098	e28dd008	 add         sp, sp, #8
  0009c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN17@WriteImage|

; 1339 :             {
; 1340 :                 HALT (BLERR_FLASH_WRITE);

  000a4	e59f2018	 ldr         r2, [pc, #0x18]
  000a8	e5923000	 ldr         r3, [r2]
  000ac	e3530000	 cmp         r3, #0
  000b0	13a01000	 movne       r1, #0
  000b4	13e0000b	 mvnne       r0, #0xB
  000b8	11a0e00f	 movne       lr, pc
  000bc	112fff13	 bxne        r3
  000c0		 |$LL11@WriteImage|
  000c0	eafffffe	 b           |$LL11@WriteImage|
  000c4		 |$LN26@WriteImage|
  000c4		 |$LN27@WriteImage|
  000c4	00000000	 DCD         |g_pOEMReportError|
  000c8		 |$LN28@WriteImage|
  000c8	00000000	 DCD         |??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@|
  000cc		 |$LN29@WriteImage|
  000cc	00000000	 DCD         |??_C@_03ILDADBHF@RAM?$AA@|
  000d0		 |$LN30@WriteImage|
  000d0	00000000	 DCD         |??_C@_05HPMNGINJ@FLASH?$AA@|
  000d4		 |$LN31@WriteImage|
  000d4	00000000	 DCD         |g_DownloadManifest|
  000d8		 |$LN32@WriteImage|
  000d8	00000000	 DCD         |??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@|
  000dc		 |$LN33@WriteImage|
  000dc	00000000	 DCD         |??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@|
  000e0		 |$M41050|

			 ENDP  ; |WriteImageToFlash|


  00000			 AREA	 |.pdata|, PDATA
|$T41067| DCD	|$LN5@ComputeChe|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ComputeChecksum| PROC

; 1391 : {

  00000		 |$LN5@ComputeChe|
  00000		 |$M41064|

; 1392 : #ifdef DEBUG
; 1393 :     RegionInfo *pRegion;
; 1394 :     DWORD       dwRegionLength;
; 1395 :     DWORD       dwChecksum;
; 1396 :     BYTE       *pbCache;
; 1397 :     DWORD       i;
; 1398 :     
; 1399 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)
; 1400 :     {
; 1401 :         pRegion         = &g_DownloadManifest.Region[i];
; 1402 :         pbCache         = (LPBYTE) OEMMapMemAddr( pRegion->dwRegionStart, pRegion->dwRegionStart );
; 1403 :         dwRegionLength  = pRegion->dwRegionLength;
; 1404 :         dwChecksum      = 0;
; 1405 : 
; 1406 :         KITLOutputDebugString("Computing checksum: image start = 0x%x, len = 0x%x\r\n", 
; 1407 :             pbCache, dwRegionLength);
; 1408 : 
; 1409 :         while(dwRegionLength--) {
; 1410 :             dwChecksum += *pbCache++;
; 1411 :         }
; 1412 : 
; 1413 :         KITLOutputDebugString("Checksum = 0x%x (0x%x bytes)\r\n", dwChecksum, pRegion->dwRegionLength);
; 1414 :     }
; 1415 : #endif
; 1416 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41065|

			 ENDP  ; |ComputeChecksum|

	EXPORT	|??_C@_06OLEINIPO@nk?4exe?$AA@| [ DATA ] ; `string'
	IMPORT	|strcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T41088| DCD	|$LN16@IsKernelRe|
	DCD	0x40002f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06OLEINIPO@nk?4exe?$AA@| DCB "nk.exe", 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsKernelRegion| PROC

; 1431 : {

  00000		 |$LN16@IsKernelRe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41085|
  00004	e1b04000	 movs        r4, r0

; 1432 : 	DWORD dwCacheAddress = 0;
; 1433 : 	ROMHDR *pROMHeader;
; 1434 : 	DWORD dwNumModules = 0;
; 1435 : 	TOCentry *plTOC;
; 1436 : 
; 1437 :     if (dwRegionStart == 0 || dwRegionLength == 0)

  00008	0a000022	 beq         |$LN6@IsKernelRe|
  0000c	e3510000	 cmp         r1, #0
  00010	0a000020	 beq         |$LN6@IsKernelRe|

; 1439 : 
; 1440 :     if (*(LPDWORD) OEMMapMemAddr (dwRegionStart, dwRegionStart + ROM_SIGNATURE_OFFSET) != ROM_SIGNATURE)

  00014	e2841040	 add         r1, r4, #0x40
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          OEMMapMemAddr
  00020	e5902000	 ldr         r2, [r0]
  00024	e59f308c	 ldr         r3, [pc, #0x8C]
  00028	e1520003	 cmp         r2, r3

; 1441 :         return (FALSE);

  0002c	1a000019	 bne         |$LN6@IsKernelRe|

; 1442 : 
; 1443 :     // A pointer to the ROMHDR structure lives just past the ROM_SIGNATURE (which is a longword value).  Note that
; 1444 :     // this pointer is remapped since it might be a flash address (image destined for flash), but is actually cached
; 1445 :     // in RAM.
; 1446 :     //
; 1447 :     dwCacheAddress = *(LPDWORD) OEMMapMemAddr (dwRegionStart, dwRegionStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG));

  00030	e2841044	 add         r1, r4, #0x44
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          OEMMapMemAddr

; 1448 :     pROMHeader     = (ROMHDR *) OEMMapMemAddr (dwRegionStart, dwCacheAddress + g_dwROMOffset);

  0003c	e59f7070	 ldr         r7, [pc, #0x70]
  00040	e5902000	 ldr         r2, [r0]
  00044	e1a00004	 mov         r0, r4
  00048	e5973000	 ldr         r3, [r7]
  0004c	e0831002	 add         r1, r3, r2
  00050	eb000000	 bl          OEMMapMemAddr

; 1449 : 
; 1450 :     // Make sure sure are some modules in the table of contents.
; 1451 :     //
; 1452 :     if ((dwNumModules = pROMHeader->nummods) == 0)

  00054	e5903010	 ldr         r3, [r0, #0x10]
  00058	e1b06003	 movs        r6, r3

; 1453 :         return (FALSE);

  0005c	0a00000d	 beq         |$LN6@IsKernelRe|

; 1454 : 
; 1455 : 	// Locate the table of contents and search for the kernel executable and the TOC immediately follows the ROMHDR.
; 1456 : 	//
; 1457 :     plTOC = (TOCentry *)(pROMHeader + 1);

  00060	e2805054	 add         r5, r0, #0x54
  00064		 |$LL3@IsKernelRe|

; 1458 : 
; 1459 : 	while(dwNumModules--) {
; 1460 : 		LPBYTE pFileName = OEMMapMemAddr(dwRegionStart, (DWORD)plTOC->lpszFileName + g_dwROMOffset);

  00064	e5952010	 ldr         r2, [r5, #0x10]
  00068	e5973000	 ldr         r3, [r7]
  0006c	e1a00004	 mov         r0, r4
  00070	e2466001	 sub         r6, r6, #1
  00074	e0821003	 add         r1, r2, r3
  00078	eb000000	 bl          OEMMapMemAddr

; 1461 : 		if (!strcmp(pFileName, "nk.exe")) {

  0007c	e59f102c	 ldr         r1, [pc, #0x2C]
  00080	eb000000	 bl          strcmp
  00084	e3500000	 cmp         r0, #0
  00088	0a000005	 beq         |$LN11@IsKernelRe|

; 1463 : 		}
; 1464 : 		++plTOC;

  0008c	e2855020	 add         r5, r5, #0x20
  00090	e3560000	 cmp         r6, #0
  00094	1afffff2	 bne         |$LL3@IsKernelRe|
  00098		 |$LN6@IsKernelRe|

; 1438 :         return(FALSE);

  00098	e3a00000	 mov         r0, #0

; 1465 : 	}
; 1466 : 	return FALSE;
; 1467 : }

  0009c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN11@IsKernelRe|

; 1462 : 			return TRUE;

  000a4	e3a00001	 mov         r0, #1

; 1465 : 	}
; 1466 : 	return FALSE;
; 1467 : }

  000a8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN17@IsKernelRe|
  000b0		 |$LN18@IsKernelRe|
  000b0	00000000	 DCD         |??_C@_06OLEINIPO@nk?4exe?$AA@|
  000b4		 |$LN19@IsKernelRe|
  000b4	00000000	 DCD         |g_dwROMOffset|
  000b8		 |$LN20@IsKernelRe|
  000b8	43454345	 DCD         0x43454345
  000bc		 |$M41086|

			 ENDP  ; |IsKernelRegion|

	EXPORT	|Nib2HexChar|

  00000			 AREA	 |.pdata|, PDATA
|$T41103| DCD	|$LN10@Nib2HexCha|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Nib2HexChar| PROC

; 1472 : {

  00000		 |$LN10@Nib2HexCha|
  00000		 |$M41100|

; 1473 :     if (Nibble < 0x0a) {

  00000	e350000a	 cmp         r0, #0xA
  00004	2a000003	 bcs         |$LN4@Nib2HexCha|

; 1474 : 		return Nibble+'0';

  00008	e2803030	 add         r3, r0, #0x30
  0000c		 |$LN7@Nib2HexCha|
  0000c	e1a00c03	 mov         r0, r3, lsl #24
  00010	e1a00c40	 mov         r0, r0, asr #24

; 1479 :     }
; 1480 : }

  00014	e12fff1e	 bx          lr
  00018		 |$LN4@Nib2HexCha|

; 1475 :     } else if (Nibble < 0x10) {

  00018	e3500010	 cmp         r0, #0x10

; 1476 : 		return Nibble-0x0a+'A';

  0001c	32803037	 addcc       r3, r0, #0x37
  00020	3afffff9	 bcc         |$LN7@Nib2HexCha|

; 1477 :     } else {
; 1478 : 		return '?';

  00024	e3a0003f	 mov         r0, #0x3F

; 1479 :     }
; 1480 : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M41101|

			 ENDP  ; |Nib2HexChar|

	EXPORT	|??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DI@FDIIHFBA@?$CK?$CK?$CK?$CK?$CK?$CK?5Checksum?5failure?5on?5recor@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DD@KHJBCIED@?$CK?$CK?$CK?$CK?$CK?$CK?5Data?5record?5?$CFd?5corrupted?0@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@| [ DATA ] ; `string'
	IMPORT	|OEMContinueEraseFlash|
	IMPORT	|OEMShowProgress|

  00000			 AREA	 |.pdata|, PDATA
|$T41249| DCD	|$LN136@DownloadBi|
	DCD	0x40010602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@| DCB "Unable t"
	DCB	"o read image start/length", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DI@FDIIHFBA@?$CK?$CK?$CK?$CK?$CK?$CK?5Checksum?5failure?5on?5recor@| DCB "*"
	DCB	"***** Checksum failure on record %d, ABORT!!! ******", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DD@KHJBCIED@?$CK?$CK?$CK?$CK?$CK?$CK?5Data?5record?5?$CFd?5corrupted?0@| DCB "*"
	DCB	"***** Data record %d corrupted, ABORT!!! ******", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@| DCB "rom_offset=0"
	DCB	"x%x.", 0xd, 0xa, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DownloadBin| PROC

; 1050 : {

  00000		 |$LN136@DownloadBi|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M41246|
  00008	e1a09002	 mov         r9, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a0b000	 mov         r11, r0

; 1051 :     RegionInfo *pCurDownloadFile;
; 1052 :     BOOL        fIsFlash = FALSE;
; 1053 :     LPBYTE      lpDest = NULL;
; 1054 :     DWORD       dwImageStart, dwImageLength, dwRecAddr, dwRecLen, dwRecChk;
; 1055 :     DWORD       dwRecNum = 0;
; 1056 : 
; 1057 :     g_bBINDownload = TRUE;

  00014	e59f73f8	 ldr         r7, [pc, #0x3F8]
  00018	e3a03001	 mov         r3, #1

; 1058 : 
; 1059 :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &dwImageStart)
; 1060 :         || !OEMReadData (sizeof (DWORD), (LPBYTE) &dwImageLength))

  0001c	e28d100c	 add         r1, sp, #0xC
  00020	e3a00004	 mov         r0, #4
  00024	e5c73000	 strb        r3, [r7]
  00028	e3a08000	 mov         r8, #0
  0002c	eb000000	 bl          OEMReadData
  00030	e3500000	 cmp         r0, #0
  00034	0a0000dd	 beq         |$LN20@DownloadBi|
  00038	e28d1010	 add         r1, sp, #0x10
  0003c	e3a00004	 mov         r0, #4
  00040	eb000000	 bl          OEMReadData
  00044	e3500000	 cmp         r0, #0
  00048	0a0000d8	 beq         |$LN20@DownloadBi|

; 1064 :         return (FALSE);
; 1065 :     }
; 1066 : 
; 1067 :     // If Platform Builder didn't provide a manifest (i.e., we're only 
; 1068 :     // downloading a single .bin file), manufacture a manifest so we
; 1069 :     // can notify the OEM.
; 1070 :     //
; 1071 :     if (!g_DownloadManifest.dwNumRegions)

  0004c	e59f53bc	 ldr         r5, [pc, #0x3BC]

; 1072 :     {
; 1073 :         g_DownloadManifest.dwNumRegions             = 1;
; 1074 :         g_DownloadManifest.Region[0].dwRegionStart  = dwImageStart;
; 1075 :         g_DownloadManifest.Region[0].dwRegionLength = dwImageLength;
; 1076 :     }
; 1077 : 
; 1078 :     // Provide the download manifest to the OEM.
; 1079 :     //
; 1080 :     if (!g_fOEMNotified && g_pOEMMultiBINNotify)

  00050	e59f43b4	 ldr         r4, [pc, #0x3B4]
  00054	e595e000	 ldr         lr, [r5]
  00058	e35e0000	 cmp         lr, #0
  0005c	059d300c	 ldreq       r3, [sp, #0xC]
  00060	03a0e001	 moveq       lr, #1
  00064	059d2010	 ldreq       r2, [sp, #0x10]
  00068	0585e000	 streq       lr, [r5]
  0006c	05853004	 streq       r3, [r5, #4]
  00070	e5943000	 ldr         r3, [r4]
  00074	05852008	 streq       r2, [r5, #8]
  00078	e3530000	 cmp         r3, #0
  0007c	1a000009	 bne         |$LN18@DownloadBi|
  00080	e59f2380	 ldr         r2, [pc, #0x380]
  00084	e5923000	 ldr         r3, [r2]
  00088	e3530000	 cmp         r3, #0
  0008c	0a000005	 beq         |$LN18@DownloadBi|

; 1081 :     {
; 1082 :         g_pOEMMultiBINNotify((PDownloadManifest)&g_DownloadManifest);

  00090	e1a00005	 mov         r0, r5
  00094	e1a0e00f	 mov         lr, pc
  00098	e12fff13	 bx          r3

; 1083 :         g_fOEMNotified = TRUE;

  0009c	e3a03001	 mov         r3, #1
  000a0	e595e000	 ldr         lr, [r5]
  000a4	e5843000	 str         r3, [r4]
  000a8		 |$LN18@DownloadBi|

; 1084 :     }
; 1085 : 
; 1086 :     // Locate the current download manifest entry (current download file).
; 1087 :     //
; 1088 :     pCurDownloadFile = &g_DownloadManifest.Region[g_DownloadManifest.dwNumRegions - g_downloadFilesRemaining];
; 1089 : 
; 1090 :     // give the OEM a chance to verify memory
; 1091 :     if (g_pOEMVerifyMemory && !g_pOEMVerifyMemory (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  000a8	e59f6354	 ldr         r6, [pc, #0x354]
  000ac	e5d73001	 ldrb        r3, [r7, #1]
  000b0	e3a00f43	 mov         r0, #0x43, 30
  000b4	e5961000	 ldr         r1, [r6]
  000b8	e04e2003	 sub         r2, lr, r3
  000bc	e2853004	 add         r3, r5, #4
  000c0	e3510000	 cmp         r1, #0
  000c4	e0243092	 mla         r4, r2, r0, r3
  000c8	0a000010	 beq         |$LN17@DownloadBi|
  000cc	e5941004	 ldr         r1, [r4, #4]
  000d0	e5940000	 ldr         r0, [r4]
  000d4	e5963000	 ldr         r3, [r6]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0	e3500000	 cmp         r0, #0
  000e4	1a000009	 bne         |$LN17@DownloadBi|

; 1092 :     {
; 1093 :         KITLOutputDebugString ("!OEMVERIFYMEMORY: Invalid image\r\n");

  000e8	e59f0310	 ldr         r0, [pc, #0x310]
  000ec	eb000000	 bl          KITLOutputDebugString

; 1094 :         HALT (BLERR_OEMVERIFY);

  000f0	e59f22e0	 ldr         r2, [pc, #0x2E0]
  000f4	e5923000	 ldr         r3, [r2]
  000f8	e3530000	 cmp         r3, #0
  000fc	13a01000	 movne       r1, #0
  00100	13e00008	 mvnne       r0, #8
  00104	11a0e00f	 movne       lr, pc
  00108	112fff13	 bxne        r3
  0010c		 |$LL34@DownloadBi|
  0010c	eafffffe	 b           |$LL34@DownloadBi|
  00110		 |$LN17@DownloadBi|

; 1095 :         return (FALSE);
; 1096 :     }
; 1097 : 
; 1098 :     // check for flash image. Start erasing if it is.
; 1099 :     if ((fIsFlash = OEMIsFlashAddr (pCurDownloadFile->dwRegionStart)) 
; 1100 :         && !OEMStartEraseFlash (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  00110	e5940000	 ldr         r0, [r4]
  00114	eb000000	 bl          OEMIsFlashAddr
  00118	e1b07000	 movs        r7, r0
  0011c	0a00005a	 beq         |$LN8@DownloadBi|
  00120	e5941004	 ldr         r1, [r4, #4]
  00124	e5940000	 ldr         r0, [r4]
  00128	eb000000	 bl          OEMStartEraseFlash
  0012c	e3500000	 cmp         r0, #0
  00130	1a000055	 bne         |$LN8@DownloadBi|

; 1101 :     {
; 1102 :         KITLOutputDebugString ("Invalid flash address/length\r\n");

  00134	e59f02c0	 ldr         r0, [pc, #0x2C0]
  00138	eb000000	 bl          KITLOutputDebugString

; 1103 :         HALT (BLERR_FLASHADDR);

  0013c	e59f2294	 ldr         r2, [pc, #0x294]
  00140	e5923000	 ldr         r3, [r2]
  00144	e3530000	 cmp         r3, #0
  00148	13a01000	 movne       r1, #0
  0014c	13e00009	 mvnne       r0, #9
  00150	11a0e00f	 movne       lr, pc
  00154	112fff13	 bxne        r3
  00158		 |$LL39@DownloadBi|
  00158	eafffffe	 b           |$LL39@DownloadBi|

; 1104 :         return (FALSE);
; 1105 :     }
; 1106 : 
; 1107 : #ifdef DEBUG
; 1108 :     // Clearing memory ensures no garbage between sparse .bin records, so that 
; 1109 :     // our post-download checksum will be accurate.
; 1110 :     memset( (LPVOID) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart),
; 1111 :                 0, pCurDownloadFile->dwRegionLength );
; 1112 : #endif
; 1113 : 
; 1114 : 
; 1115 :     //------------------------------------------------------------------------
; 1116 :     //  Download .bin records
; 1117 :     //------------------------------------------------------------------------
; 1118 : 
; 1119 :     while ( OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecAddr)  &&
; 1120 :             OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecLen)   &&
; 1121 :             OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecChk) )

  0015c		 |$LL15@DownloadBi|
  0015c	e28d1000	 add         r1, sp, #0
  00160	e3a00004	 mov         r0, #4
  00164	eb000000	 bl          OEMReadData
  00168	e3500000	 cmp         r0, #0
  0016c	0a00004b	 beq         |$LN14@DownloadBi|
  00170	e28d1008	 add         r1, sp, #8
  00174	e3a00004	 mov         r0, #4
  00178	eb000000	 bl          OEMReadData
  0017c	e3500000	 cmp         r0, #0
  00180	0a000046	 beq         |$LN14@DownloadBi|

; 1122 :     {
; 1123 : #ifdef DEBUG
; 1124 :         KITLOutputDebugString(" <> Record [ %d ] dwRecAddr = 0x%x, dwRecLen = 0x%x\r\n", 
; 1125 :             dwRecNum, dwRecAddr, dwRecLen);
; 1126 : #endif
; 1127 : 
; 1128 :         // last record of .bin file uses sentinel values for address and checksum.
; 1129 :         if (!dwRecAddr && !dwRecChk)

  00184	e59d1004	 ldr         r1, [sp, #4]
  00188	e3510000	 cmp         r1, #0
  0018c	1a000002	 bne         |$LN13@DownloadBi|
  00190	e59d3008	 ldr         r3, [sp, #8]
  00194	e3530000	 cmp         r3, #0
  00198	0a000040	 beq         |$LN14@DownloadBi|
  0019c		 |$LN13@DownloadBi|

; 1130 :         {
; 1131 :             break;
; 1132 :         }
; 1133 : 
; 1134 :         // map the record address (FLASH data is cached, for example)
; 1135 :         lpDest = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, dwRecAddr);

  0019c	e5940000	 ldr         r0, [r4]
  001a0	eb000000	 bl          OEMMapMemAddr
  001a4	e1a06000	 mov         r6, r0

; 1136 : 
; 1137 :         // read data block
; 1138 :         if (!OEMReadData (dwRecLen, lpDest))

  001a8	e59d0000	 ldr         r0, [sp]
  001ac	e1a01006	 mov         r1, r6
  001b0	eb000000	 bl          OEMReadData
  001b4	e3500000	 cmp         r0, #0
  001b8	0a000052	 beq         |$LN76@DownloadBi|

; 1142 :             return (FALSE);
; 1143 :         }
; 1144 : 
; 1145 :         if (!VerifyChecksum (dwRecLen, lpDest, dwRecChk))

  001bc	e59de000	 ldr         lr, [sp]
  001c0	e1a00006	 mov         r0, r6
  001c4	e3a02000	 mov         r2, #0
  001c8	e35e0000	 cmp         lr, #0
  001cc	0a000004	 beq         |$LN49@DownloadBi|
  001d0	e1a0100e	 mov         r1, lr
  001d4		 |$LL51@DownloadBi|
  001d4	e4d03001	 ldrb        r3, [r0], #1
  001d8	e2511001	 subs        r1, r1, #1
  001dc	e0822003	 add         r2, r2, r3
  001e0	1afffffb	 bne         |$LL51@DownloadBi|
  001e4		 |$LN49@DownloadBi|
  001e4	e59d1008	 ldr         r1, [sp, #8]
  001e8	e1520001	 cmp         r2, r1
  001ec	1a000038	 bne         |$LN106@DownloadBi|

; 1149 :             return (FALSE);
; 1150 :         }
; 1151 : 
; 1152 :         // Look for ROMHDR to compute ROM offset.  NOTE: romimage guarantees that the record containing
; 1153 :         // the TOC signature and pointer will always come before the record that contains the ROMHDR contents.
; 1154 :         //
; 1155 :         if (dwRecLen == sizeof(ROMHDR) && (*(LPDWORD) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE))

  001f0	e35e0054	 cmp         lr, #0x54
  001f4	1a00001f	 bne         |$LN9@DownloadBi|
  001f8	e5940000	 ldr         r0, [r4]
  001fc	e2801040	 add         r1, r0, #0x40
  00200	eb000000	 bl          OEMMapMemAddr
  00204	e5903000	 ldr         r3, [r0]
  00208	e59f21e0	 ldr         r2, [pc, #0x1E0]
  0020c	e1530002	 cmp         r3, r2
  00210	1a000018	 bne         |$LN9@DownloadBi|

; 1156 :         {
; 1157 :             DWORD dwTempOffset = (dwRecAddr - *(LPDWORD)OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG)));

  00214	e5940000	 ldr         r0, [r4]
  00218	e2801044	 add         r1, r0, #0x44
  0021c	eb000000	 bl          OEMMapMemAddr
  00220	e5901000	 ldr         r1, [r0]
  00224	e59d3004	 ldr         r3, [sp, #4]

; 1158 :             ROMHDR *pROMHdr = (ROMHDR *)lpDest;
; 1159 : 
; 1160 :             // Check to make sure this record really contains the ROMHDR.
; 1161 :             //
; 1162 :             if ((pROMHdr->physfirst == (pCurDownloadFile->dwRegionStart - dwTempOffset)) &&
; 1163 :                 (pROMHdr->physlast  == (pCurDownloadFile->dwRegionStart - dwTempOffset + pCurDownloadFile->dwRegionLength)) &&
; 1164 :                 (DWORD)(HIWORD(pROMHdr->dllfirst << 16) <= pROMHdr->dlllast) &&
; 1165 :                 (DWORD)(LOWORD(pROMHdr->dllfirst << 16) <= pROMHdr->dlllast))

  00228	e5940000	 ldr         r0, [r4]
  0022c	e5962008	 ldr         r2, [r6, #8]
  00230	e043e001	 sub         lr, r3, r1
  00234	e040300e	 sub         r3, r0, lr
  00238	e1520003	 cmp         r2, r3
  0023c	1a00000d	 bne         |$LN9@DownloadBi|
  00240	e5942004	 ldr         r2, [r4, #4]
  00244	e596100c	 ldr         r1, [r6, #0xC]
  00248	e040300e	 sub         r3, r0, lr
  0024c	e0833002	 add         r3, r3, r2
  00250	e1510003	 cmp         r1, r3
  00254	1a000007	 bne         |$LN9@DownloadBi|
  00258	e1d630b0	 ldrh        r3, [r6]
  0025c	e5962004	 ldr         r2, [r6, #4]
  00260	e1530002	 cmp         r3, r2

; 1166 :             {
; 1167 :                 g_dwROMOffset = dwTempOffset;
; 1168 :                 KITLOutputDebugString("rom_offset=0x%x.\r\n", g_dwROMOffset); 

  00264	959f318c	 ldrls       r3, [pc, #0x18C]
  00268	959f0184	 ldrls       r0, [pc, #0x184]
  0026c	91a0100e	 movls       r1, lr
  00270	9583e000	 strls       lr, [r3]
  00274	9b000000	 blls        KITLOutputDebugString
  00278		 |$LN9@DownloadBi|

; 1169 :             }
; 1170 :         }
; 1171 : 
; 1172 :         // verify partial checksum
; 1173 :         OEMShowProgress (dwRecNum++);

  00278	e1a00008	 mov         r0, r8
  0027c	eb000000	 bl          OEMShowProgress

; 1174 : 
; 1175 :         if (fIsFlash)

  00280	e3570000	 cmp         r7, #0
  00284	e2888001	 add         r8, r8, #1

; 1176 :         {
; 1177 :             OEMContinueEraseFlash ();

  00288	1b000000	 blne        OEMContinueEraseFlash
  0028c		 |$LN8@DownloadBi|
  0028c	e28d1004	 add         r1, sp, #4
  00290	e3a00004	 mov         r0, #4
  00294	eb000000	 bl          OEMReadData
  00298	e3500000	 cmp         r0, #0
  0029c	1affffae	 bne         |$LL15@DownloadBi|
  002a0		 |$LN14@DownloadBi|

; 1178 :         }
; 1179 :     }  // while( records remaining )
; 1180 :     
; 1181 : 
; 1182 :     //------------------------------------------------------------------------
; 1183 :     //  Determine the image entry point
; 1184 :     //------------------------------------------------------------------------
; 1185 : 
; 1186 :     // Does this .bin file contain a TOC?
; 1187 :     if (*(LPDWORD) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE)

  002a0	e5940000	 ldr         r0, [r4]
  002a4	e2801040	 add         r1, r0, #0x40
  002a8	eb000000	 bl          OEMMapMemAddr
  002ac	e5903000	 ldr         r3, [r0]
  002b0	e59f2138	 ldr         r2, [pc, #0x138]
  002b4	e1530002	 cmp         r3, r2
  002b8	1a00001d	 bne         |$LN7@DownloadBi|

; 1188 :     {
; 1189 :         // Contain the kernel?
; 1190 :         if (IsKernelRegion(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  002bc	e5941004	 ldr         r1, [r4, #4]
  002c0	e5940000	 ldr         r0, [r4]
  002c4	eb000000	 bl          IsKernelRegion
  002c8	e3500000	 cmp         r0, #0
  002cc	0a000021	 beq         |$LN4@DownloadBi|

; 1191 :         {
; 1192 :             *pdwImageStart  = pCurDownloadFile->dwRegionStart;
; 1193 :             *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 1194 :             *pdwLaunchAddr  = dwRecLen;
; 1195 :         }

  002d0	ea00001a	 b           |$LN133@DownloadBi|
  002d4		 |$LN106@DownloadBi|

; 1142 :             return (FALSE);
; 1143 :         }
; 1144 : 
; 1145 :         if (!VerifyChecksum (dwRecLen, lpDest, dwRecChk))

  002d4	e59f0110	 ldr         r0, [pc, #0x110]
  002d8	eb000000	 bl          KITLOutputDebugString

; 1146 :         {
; 1147 :             KITLOutputDebugString ("****** Checksum failure on record %d, ABORT!!! ******\r\n", dwRecNum);

  002dc	e59f0104	 ldr         r0, [pc, #0x104]
  002e0	e1a01008	 mov         r1, r8
  002e4	eb000000	 bl          KITLOutputDebugString

; 1148 :             HALT (BLERR_CHECKSUM);

  002e8	e59f20e8	 ldr         r2, [pc, #0xE8]
  002ec	e5923000	 ldr         r3, [r2]
  002f0	e3530000	 cmp         r3, #0
  002f4	13a01000	 movne       r1, #0
  002f8	13e00006	 mvnne       r0, #6
  002fc	11a0e00f	 movne       lr, pc
  00300	112fff13	 bxne        r3
  00304		 |$LL57@DownloadBi|
  00304	eafffffe	 b           |$LL57@DownloadBi|
  00308		 |$LN76@DownloadBi|

; 1139 :         {
; 1140 :             KITLOutputDebugString ("****** Data record %d corrupted, ABORT!!! ******\r\n", dwRecNum);

  00308	e59f00d4	 ldr         r0, [pc, #0xD4]
  0030c	e1a01008	 mov         r1, r8
  00310	eb000000	 bl          KITLOutputDebugString

; 1141 :             HALT (BLERR_CORRUPTED_DATA);

  00314	e59f20bc	 ldr         r2, [pc, #0xBC]
  00318	e5923000	 ldr         r3, [r2]
  0031c	e3530000	 cmp         r3, #0
  00320	13a01000	 movne       r1, #0
  00324	13e00003	 mvnne       r0, #3
  00328	11a0e00f	 movne       lr, pc
  0032c	112fff13	 bxne        r3
  00330		 |$LL44@DownloadBi|
  00330	eafffffe	 b           |$LL44@DownloadBi|
  00334		 |$LN7@DownloadBi|

; 1196 :     }
; 1197 :     // No TOC - not made by romimage.  
; 1198 :     else if (g_DownloadManifest.dwNumRegions == 1)

  00334	e5953000	 ldr         r3, [r5]
  00338	e3530001	 cmp         r3, #1
  0033c	1a000005	 bne         |$LN4@DownloadBi|
  00340		 |$LN133@DownloadBi|

; 1199 :     {
; 1200 :         *pdwImageStart  = pCurDownloadFile->dwRegionStart;

  00340	e5943000	 ldr         r3, [r4]

; 1201 :         *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 1202 :         *pdwLaunchAddr  = dwRecLen;

  00344	e59d2000	 ldr         r2, [sp]
  00348	e58b3000	 str         r3, [r11]
  0034c	e5943004	 ldr         r3, [r4, #4]
  00350	e58a3000	 str         r3, [r10]
  00354	e5892000	 str         r2, [r9]
  00358		 |$LN4@DownloadBi|

; 1203 :     }
; 1204 :     else
; 1205 :     {
; 1206 :         // If we're downloading more than one .bin file, it's probably 
; 1207 :         // chain.bin which doesn't have a TOC (and which isn't
; 1208 :         // going to be downloaded on its own) and we should ignore it.
; 1209 :     }
; 1210 : 
; 1211 : 
; 1212 :     if (fIsFlash)

  00358	e3570000	 cmp         r7, #0
  0035c	0a00000a	 beq         |$LN1@DownloadBi|

; 1213 :     {
; 1214 :         // finish the flash erase
; 1215 :         if (!OEMFinishEraseFlash())

  00360	eb000000	 bl          OEMFinishEraseFlash
  00364	e3500000	 cmp         r0, #0
  00368	1a000007	 bne         |$LN1@DownloadBi|

; 1216 :         {
; 1217 :             HALT (BLERR_FLASH_ERASE);

  0036c	e59f2064	 ldr         r2, [pc, #0x64]
  00370	e5923000	 ldr         r3, [r2]
  00374	e3530000	 cmp         r3, #0
  00378	13a01000	 movne       r1, #0
  0037c	13e0000a	 mvnne       r0, #0xA
  00380	11a0e00f	 movne       lr, pc
  00384	112fff13	 bxne        r3
  00388		 |$LL62@DownloadBi|
  00388	eafffffe	 b           |$LL62@DownloadBi|
  0038c		 |$LN1@DownloadBi|

; 1218 :             return (FALSE);
; 1219 :         }
; 1220 : 
; 1221 :     }
; 1222 : 
; 1223 :     KITLOutputDebugString("ImageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x\r\n",
; 1224 :         *pdwImageStart, *pdwImageLength, *pdwLaunchAddr);

  0038c	e5993000	 ldr         r3, [r9]
  00390	e59a2000	 ldr         r2, [r10]
  00394	e59b1000	 ldr         r1, [r11]
  00398	e59f0040	 ldr         r0, [pc, #0x40]
  0039c	eb000000	 bl          KITLOutputDebugString

; 1225 : 
; 1226 :     return TRUE;

  003a0	e3a00001	 mov         r0, #1

; 1227 : }

  003a4	e28dd014	 add         sp, sp, #0x14
  003a8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003ac	e12fff1e	 bx          lr
  003b0		 |$LN20@DownloadBi|

; 1061 :     {
; 1062 :         KITLOutputDebugString ("Unable to read image start/length\r\n");

  003b0	e59f0024	 ldr         r0, [pc, #0x24]
  003b4	eb000000	 bl          KITLOutputDebugString

; 1063 :         HALT (BLERR_MAGIC);

  003b8	e59f2018	 ldr         r2, [pc, #0x18]
  003bc	e5923000	 ldr         r3, [r2]
  003c0	e3530000	 cmp         r3, #0
  003c4	13a01000	 movne       r1, #0
  003c8	13e00007	 mvnne       r0, #7
  003cc	11a0e00f	 movne       lr, pc
  003d0	112fff13	 bxne        r3
  003d4		 |$LL29@DownloadBi|
  003d4	eafffffe	 b           |$LL29@DownloadBi|
  003d8		 |$LN137@DownloadBi|
  003d8		 |$LN138@DownloadBi|
  003d8	00000000	 DCD         |g_pOEMReportError|
  003dc		 |$LN139@DownloadBi|
  003dc	00000000	 DCD         |??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@|
  003e0		 |$LN140@DownloadBi|
  003e0	00000000	 DCD         |??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@|
  003e4		 |$LN141@DownloadBi|
  003e4	00000000	 DCD         |??_C@_0DD@KHJBCIED@?$CK?$CK?$CK?$CK?$CK?$CK?5Data?5record?5?$CFd?5corrupted?0@|
  003e8		 |$LN142@DownloadBi|
  003e8	00000000	 DCD         |??_C@_0DI@FDIIHFBA@?$CK?$CK?$CK?$CK?$CK?$CK?5Checksum?5failure?5on?5recor@|
  003ec		 |$LN143@DownloadBi|
  003ec	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  003f0		 |$LN144@DownloadBi|
  003f0	43454345	 DCD         0x43454345
  003f4		 |$LN145@DownloadBi|
  003f4	00000000	 DCD         |??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@|
  003f8		 |$LN146@DownloadBi|
  003f8	00000000	 DCD         |g_dwROMOffset|
  003fc		 |$LN147@DownloadBi|
  003fc	00000000	 DCD         |??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@|
  00400		 |$LN148@DownloadBi|
  00400	00000000	 DCD         |??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@|
  00404		 |$LN149@DownloadBi|
  00404	00000000	 DCD         |g_pOEMVerifyMemory|
  00408		 |$LN150@DownloadBi|
  00408	00000000	 DCD         |g_pOEMMultiBINNotify|
  0040c		 |$LN151@DownloadBi|
  0040c	00000000	 DCD         |g_fOEMNotified|
  00410		 |$LN152@DownloadBi|
  00410	00000000	 DCD         |g_DownloadManifest|
  00414		 |$LN153@DownloadBi|
  00414	00000000	 DCD         |g_bBINDownload|
  00418		 |$M41247|

			 ENDP  ; |DownloadBin|

	EXPORT	|??_C@_0EC@NABDPCJO@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EC@MIGFFFAC@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@| [ DATA ] ; `string'
	EXPORT	|??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@| [ DATA ] ; `string'
	EXPORT	|??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41327| DCD	|$LN61@DownloadIm|
	DCD	0x40007301

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EC@NABDPCJO@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| DCB "*"
	DCB	"* ERROR: This boot loader does not support signed .bin i"
	DCB	"mages.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EC@MIGFFFAC@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| DCB "*"
	DCB	"* ERROR: This boot loader does not support signed .nb0 i"
	DCB	"mages.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@| DCB 0xd, 0xa, "**", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@| DCB "*"
	DCB	"* ERROR: The X000FF packet is an old-style multi-bin dow"
	DCB	"nload manifest and it's no longer supported.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@| DCB "**"
	DCB	" Please update your Platform Builder installation in you"
	DCB	" want to download multiple files.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@| DCB "**", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DownloadImage| PROC

; 360  : {

  00000		 |$LN61@DownloadIm|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M41324|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a08000	 mov         r8, r0

; 361  :     BOOL        rval = TRUE;
; 362  :     DWORD       dwImageType;
; 363  : 
; 364  :     *pdwImageStart = *pdwImageLength = *pdwLaunchAddr = 0;

  00010	e3a03000	 mov         r3, #0
  00014	e5863000	 str         r3, [r6]
  00018	e59f91a8	 ldr         r9, [pc, #0x1A8]
  0001c	e59f51a0	 ldr         r5, [pc, #0x1A0]
  00020	e5873000	 str         r3, [r7]
  00024	e5883000	 str         r3, [r8]
  00028	e3a04001	 mov         r4, #1
  0002c		 |$LL13@DownloadIm|

; 365  : 
; 366  : #ifdef SECURE_BOOTLOADER
; 367  :     InitSecureBootLoader();
; 368  : #endif
; 369  : 
; 370  : 
; 371  :     //
; 372  :     // Download each region (multiple can be sent)
; 373  :     //
; 374  :     do
; 375  :     {
; 376  :         dwImageType = GetImageType();

  0002c	eb000000	 bl          GetImageType
  00030	e3500000	 cmp         r0, #0

; 377  :         
; 378  :         switch(dwImageType) 

  00034	0a000015	 beq         |$LN8@DownloadIm|
  00038	e3500001	 cmp         r0, #1
  0003c	0a00000d	 beq         |$LN6@DownloadIm|
  00040	e3500003	 cmp         r0, #3
  00044	0a000041	 beq         |$LN5@DownloadIm|
  00048	e3500004	 cmp         r0, #4
  0004c	0a000031	 beq         |$LN4@DownloadIm|
  00050	e3500005	 cmp         r0, #5
  00054	0a00001f	 beq         |$LN3@DownloadIm|
  00058	e3500006	 cmp         r0, #6
  0005c	1a00001a	 bne         |$LN43@DownloadIm|

; 437  :                 return (FALSE);
; 438  : 
; 439  :             case BL_IMAGE_TYPE_UNKNOWN:
; 440  : #ifdef SECURE_BOOTLOADER
; 441  :                 KITLOutputDebugString("\r\n**\r\n");
; 442  :                 KITLOutputDebugString("** ERROR: Unrecognized image type (possibly unsigned .nb0).\r\n");
; 443  :                 KITLOutputDebugString("**        This boot loader does not support unsigned images.\r\n");
; 444  :                 KITLOutputDebugString("**        Image must be signed with a recognized private key.\r\n");
; 445  :                 KITLOutputDebugString("**\r\n");
; 446  :                 HALT (BLERR_MAGIC);
; 447  :                 return (FALSE);
; 448  : #else
; 449  :                 // Assume files without a "type" header (e.g. raw data) are unsigned .nb0
; 450  :                 rval &= DownloadNB0( pdwImageStart, pdwImageLength, pdwLaunchAddr );

  00060	e1a02006	 mov         r2, r6
  00064	e1a01007	 mov         r1, r7
  00068	e1a00008	 mov         r0, r8
  0006c	eb000000	 bl          DownloadNB0
  00070	e0004004	 and         r4, r0, r4
  00074	ea00000b	 b           |$LN12@DownloadIm|
  00078		 |$LN6@DownloadIm|

; 391  :                 continue;
; 392  : 
; 393  : #ifdef SECURE_BOOTLOADER
; 394  :             case BL_IMAGE_TYPE_BIN:
; 395  :                 KITLOutputDebugString("\r\n**\r\n");
; 396  :                 KITLOutputDebugString("** ERROR: This boot loader does not support unsigned .bin images.\r\n");
; 397  :                 KITLOutputDebugString("**        Image must be signed with a recognized private key.\r\n");
; 398  :                 KITLOutputDebugString("**\r\n");
; 399  :                 HALT (BLERR_SIGNATURE);
; 400  :                 return (FALSE);
; 401  : 
; 402  :             case BL_IMAGE_TYPE_SIGNED_BIN:
; 403  :                 rval &= DownloadSignedBin( pdwImageStart, pdwImageLength, pdwLaunchAddr );
; 404  :                 break;
; 405  : 
; 406  :             case BL_IMAGE_TYPE_SIGNED_NB0:
; 407  :                 rval &= DownloadSignedNB0( pdwImageStart, pdwImageLength, pdwLaunchAddr );
; 408  :                 break;
; 409  : 
; 410  : #else // not SECURE_BOOTLOADER
; 411  : 
; 412  :             case BL_IMAGE_TYPE_BIN:
; 413  :                 rval &= DownloadBin( pdwImageStart, pdwImageLength, pdwLaunchAddr );

  00078	e1a02006	 mov         r2, r6
  0007c	e1a01007	 mov         r1, r7
  00080	e1a00008	 mov         r0, r8
  00084	eb000000	 bl          DownloadBin
  00088	e0004004	 and         r4, r0, r4

; 414  :                 break;

  0008c	ea000005	 b           |$LN12@DownloadIm|
  00090		 |$LN8@DownloadIm|

; 379  :         {
; 380  :             case BL_IMAGE_TYPE_MANIFEST:
; 381  :                 // Platform Builder sends a manifest to indicate the following 
; 382  :                 // data consists of multiple .bin files /OR/ one .nb0 file.
; 383  :                 if (!CheckImageManifest()) {

  00090	eb000000	 bl          CheckImageManifest
  00094	e3500000	 cmp         r0, #0
  00098	0a00003a	 beq         |$LN45@DownloadIm|

; 385  :                     return (FALSE);   
; 386  :                 }
; 387  : 
; 388  :                 // Continue with download of next file
; 389  :                 // +1 to account for the manifest
; 390  :                 g_downloadFilesRemaining = (BYTE)(g_DownloadManifest.dwNumRegions + 1);

  0009c	e5993000	 ldr         r3, [r9]
  000a0	e2833001	 add         r3, r3, #1
  000a4	e5c53000	 strb        r3, [r5]
  000a8		 |$LN12@DownloadIm|

; 451  :                 break;

  000a8	e5d53000	 ldrb        r3, [r5]

; 457  :                 
; 458  :         }
; 459  :     }
; 460  :     while (--g_downloadFilesRemaining);

  000ac	e28330ff	 add         r3, r3, #0xFF
  000b0	e21330ff	 ands        r3, r3, #0xFF
  000b4	e5c53000	 strb        r3, [r5]
  000b8	1affffdb	 bne         |$LL13@DownloadIm|

; 461  : 
; 462  :     ComputeChecksum();
; 463  :     rval &= WriteImageToFlash();

  000bc	eb000000	 bl          WriteImageToFlash
  000c0	e0000004	 and         r0, r0, r4

; 464  : 
; 465  :     return rval;
; 466  : }

  000c4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN43@DownloadIm|

; 452  : #endif                
; 453  : 
; 454  :             default:
; 455  :                 // should never get here
; 456  :                 return (FALSE);

  000cc	e3a00000	 mov         r0, #0

; 464  : 
; 465  :     return rval;
; 466  : }

  000d0	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN3@DownloadIm|

; 428  :                 return (FALSE);
; 429  : #endif // SECURE_BOOTLOADER
; 430  : 
; 431  :             case BL_IMAGE_TYPE_MULTIXIP:
; 432  :                 KITLOutputDebugString("\r\n**\r\n");

  000d8	e59f00d4	 ldr         r0, [pc, #0xD4]
  000dc	eb000000	 bl          KITLOutputDebugString

; 433  :                 KITLOutputDebugString("** ERROR: The X000FF packet is an old-style multi-bin download manifest and it's no longer supported.\r\n");

  000e0	e59f00d8	 ldr         r0, [pc, #0xD8]
  000e4	eb000000	 bl          KITLOutputDebugString

; 434  :                 KITLOutputDebugString("** Please update your Platform Builder installation in you want to download multiple files.\r\n");

  000e8	e59f00cc	 ldr         r0, [pc, #0xCC]
  000ec	eb000000	 bl          KITLOutputDebugString

; 435  :                 KITLOutputDebugString("**\r\n");

  000f0	e59f00b4	 ldr         r0, [pc, #0xB4]
  000f4	eb000000	 bl          KITLOutputDebugString

; 436  :                 HALT (BLERR_MAGIC);

  000f8	e59f20a8	 ldr         r2, [pc, #0xA8]
  000fc	e5923000	 ldr         r3, [r2]
  00100	e3530000	 cmp         r3, #0
  00104	13a01000	 movne       r1, #0
  00108	13e00007	 mvnne       r0, #7
  0010c	11a0e00f	 movne       lr, pc
  00110	112fff13	 bxne        r3
  00114		 |$LL32@DownloadIm|
  00114	eafffffe	 b           |$LL32@DownloadIm|
  00118		 |$LN4@DownloadIm|

; 421  :                 return (FALSE);
; 422  : 
; 423  :             case BL_IMAGE_TYPE_SIGNED_NB0:
; 424  :                 KITLOutputDebugString("\r\n**\r\n");

  00118	e59f0094	 ldr         r0, [pc, #0x94]
  0011c	eb000000	 bl          KITLOutputDebugString

; 425  :                 KITLOutputDebugString("** ERROR: This boot loader does not support signed .nb0 images.\r\n");

  00120	e59f0090	 ldr         r0, [pc, #0x90]
  00124	eb000000	 bl          KITLOutputDebugString

; 426  :                 KITLOutputDebugString("**\r\n");

  00128	e59f007c	 ldr         r0, [pc, #0x7C]
  0012c	eb000000	 bl          KITLOutputDebugString

; 427  :                 HALT (BLERR_SIGNATURE);

  00130	e59f2070	 ldr         r2, [pc, #0x70]
  00134	e5923000	 ldr         r3, [r2]
  00138	e3530000	 cmp         r3, #0
  0013c	13a01000	 movne       r1, #0
  00140	13e00004	 mvnne       r0, #4
  00144	11a0e00f	 movne       lr, pc
  00148	112fff13	 bxne        r3
  0014c		 |$LL27@DownloadIm|
  0014c	eafffffe	 b           |$LL27@DownloadIm|
  00150		 |$LN5@DownloadIm|

; 415  : 
; 416  :             case BL_IMAGE_TYPE_SIGNED_BIN:
; 417  :                 KITLOutputDebugString("\r\n**\r\n");

  00150	e59f005c	 ldr         r0, [pc, #0x5C]
  00154	eb000000	 bl          KITLOutputDebugString

; 418  :                 KITLOutputDebugString("** ERROR: This boot loader does not support signed .bin images.\r\n");

  00158	e59f0050	 ldr         r0, [pc, #0x50]
  0015c	eb000000	 bl          KITLOutputDebugString

; 419  :                 KITLOutputDebugString("**\r\n");

  00160	e59f0044	 ldr         r0, [pc, #0x44]
  00164	eb000000	 bl          KITLOutputDebugString

; 420  :                 HALT (BLERR_SIGNATURE);

  00168	e59f2038	 ldr         r2, [pc, #0x38]
  0016c	e5923000	 ldr         r3, [r2]
  00170	e3530000	 cmp         r3, #0
  00174	13a01000	 movne       r1, #0
  00178	13e00004	 mvnne       r0, #4
  0017c	11a0e00f	 movne       lr, pc
  00180	112fff13	 bxne        r3
  00184		 |$LL22@DownloadIm|
  00184	eafffffe	 b           |$LL22@DownloadIm|
  00188		 |$LN45@DownloadIm|

; 384  :                     HALT (BLERR_MAGIC);

  00188	e59f2018	 ldr         r2, [pc, #0x18]
  0018c	e5923000	 ldr         r3, [r2]
  00190	e3530000	 cmp         r3, #0
  00194	13a01000	 movne       r1, #0
  00198	13e00007	 mvnne       r0, #7
  0019c	11a0e00f	 movne       lr, pc
  001a0	112fff13	 bxne        r3
  001a4		 |$LL17@DownloadIm|
  001a4	eafffffe	 b           |$LL17@DownloadIm|
  001a8		 |$LN62@DownloadIm|
  001a8		 |$LN63@DownloadIm|
  001a8	00000000	 DCD         |g_pOEMReportError|
  001ac		 |$LN64@DownloadIm|
  001ac	00000000	 DCD         |??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@|
  001b0		 |$LN65@DownloadIm|
  001b0	00000000	 DCD         |??_C@_0EC@NABDPCJO@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@|
  001b4		 |$LN66@DownloadIm|
  001b4	00000000	 DCD         |??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@|
  001b8		 |$LN67@DownloadIm|
  001b8	00000000	 DCD         |??_C@_0EC@MIGFFFAC@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@|
  001bc		 |$LN68@DownloadIm|
  001bc	00000000	 DCD         |??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@|
  001c0		 |$LN69@DownloadIm|
  001c0	00000000	 DCD         |??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@|
  001c4		 |$LN70@DownloadIm|
  001c4	00000000	 DCD         |g_downloadFilesRemaining|
  001c8		 |$LN71@DownloadIm|
  001c8	00000000	 DCD         |g_DownloadManifest|
  001cc		 |$M41325|

			 ENDP  ; |DownloadImage|

	EXPORT	|BootloaderMain|
	EXPORT	|??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@| [ DATA ] ; `string'
	IMPORT	|OEMLaunch|
	IMPORT	|OEMPreDownload|
	IMPORT	|OEMPlatformInit|
	IMPORT	|OEMDebugInit|

  00000			 AREA	 |.pdata|, PDATA
|$T41431| DCD	|$LN87@Bootloader|
	DCD	0x4000a402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@| DCB "ROMHDR a"
	DCB	"t Address %Xh", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@| DCB "Sys"
	DCB	"tem ready!", 0xd, 0xa, "Preparing for download...", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BootloaderMain| PROC

; 155  : {

  00000		 |$LN87@Bootloader|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M41428|

; 156  :     DWORD dwAction;   
; 157  :     DWORD dwpToc = 0;
; 158  :     DWORD dwImageStart = 0, dwImageLength = 0, dwLaunchAddr = 0;
; 159  :     BOOL bDownloaded = FALSE;
; 160  : 
; 161  :     // relocate globals to RAM
; 162  :     if (!KernelRelocate (pTOC))

  00008	e59fb27c	 ldr         r11, [pc, #0x27C]
  0000c	e3a05000	 mov         r5, #0
  00010	e3a0a000	 mov         r10, #0
  00014	e59b6000	 ldr         r6, [r11]
  00018	e3a08000	 mov         r8, #0
  0001c	e58d5008	 str         r5, [sp, #8]
  00020	e3760001	 cmn         r6, #1
  00024	e58da000	 str         r10, [sp]
  00028	e58d8004	 str         r8, [sp, #4]
  0002c	e3a07000	 mov         r7, #0
  00030	0a000086	 beq         |$LN58@Bootloader|
  00034	e5963020	 ldr         r3, [r6, #0x20]
  00038	e3a09000	 mov         r9, #0
  0003c	e3530000	 cmp         r3, #0
  00040	9a000017	 bls         |$LN14@Bootloader|
  00044	e3a07000	 mov         r7, #0
  00048		 |$LL21@Bootloader|
  00048	e5963024	 ldr         r3, [r6, #0x24]
  0004c	e0834007	 add         r4, r3, r7
  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e3530000	 cmp         r3, #0
  00058	15941000	 ldrne       r1, [r4]
  0005c	15940004	 ldrne       r0, [r4, #4]
  00060	11a02003	 movne       r2, r3
  00064	1b000000	 blne        memcpy
  00068	e594200c	 ldr         r2, [r4, #0xC]
  0006c	e5943008	 ldr         r3, [r4, #8]
  00070	e1530002	 cmp         r3, r2
  00074	11a00003	 movne       r0, r3
  00078	15943004	 ldrne       r3, [r4, #4]
  0007c	10422000	 subne       r2, r2, r0
  00080	13a01000	 movne       r1, #0
  00084	10800003	 addne       r0, r0, r3
  00088	1b000000	 blne        memset
  0008c	e5963020	 ldr         r3, [r6, #0x20]
  00090	e2899001	 add         r9, r9, #1
  00094	e2877010	 add         r7, r7, #0x10
  00098	e1590003	 cmp         r9, r3
  0009c	3affffe9	 bcc         |$LL21@Bootloader|
  000a0	e3a07000	 mov         r7, #0
  000a4		 |$LN14@Bootloader|

; 166  :     }
; 167  : 
; 168  :     // (1) Init debug support. We can use OEMWriteDebugString afterward.
; 169  :     if (!OEMDebugInit ())

  000a4	eb000000	 bl          OEMDebugInit
  000a8	e3500000	 cmp         r0, #0
  000ac	1a000007	 bne         |$LN13@Bootloader|

; 170  :     {
; 171  :         // spin forever
; 172  :         HALT (BLERR_DBGINIT);

  000b0	e59f21b8	 ldr         r2, [pc, #0x1B8]
  000b4	e5923000	 ldr         r3, [r2]
  000b8	e3530000	 cmp         r3, #0
  000bc	13a01000	 movne       r1, #0
  000c0	13e00001	 mvnne       r0, #1
  000c4	11a0e00f	 movne       lr, pc
  000c8	112fff13	 bxne        r3
  000cc		 |$LL31@Bootloader|
  000cc	eafffffe	 b           |$LL31@Bootloader|
  000d0		 |$LN13@Bootloader|

; 173  :     }
; 174  : 
; 175  :     // output banner
; 176  :     KITLOutputDebugString (NKSignon, CURRENT_VERSION_MAJOR, CURRENT_VERSION_MINOR);

  000d0	e3a02004	 mov         r2, #4
  000d4	e3a01001	 mov         r1, #1
  000d8	e28b0008	 add         r0, r11, #8
  000dc	eb000000	 bl          KITLOutputDebugString

; 177  : 
; 178  :     // (3) initialize platform (clock, drivers, transports, etc)
; 179  :     if (!OEMPlatformInit ())

  000e0	eb000000	 bl          OEMPlatformInit
  000e4	e3500000	 cmp         r0, #0
  000e8	1a000007	 bne         |$LN12@Bootloader|

; 180  :     {
; 181  :         // spin forever
; 182  :         HALT (BLERR_PLATINIT);

  000ec	e59f217c	 ldr         r2, [pc, #0x17C]
  000f0	e5923000	 ldr         r3, [r2]
  000f4	e3530000	 cmp         r3, #0
  000f8	13a01000	 movne       r1, #0
  000fc	13e00002	 mvnne       r0, #2
  00100	11a0e00f	 movne       lr, pc
  00104	112fff13	 bxne        r3
  00108		 |$LL36@Bootloader|
  00108	eafffffe	 b           |$LL36@Bootloader|
  0010c		 |$LN12@Bootloader|

; 183  :     }
; 184  : 
; 185  :     // system ready, preparing for download
; 186  :     KITLOutputDebugString ("System ready!\r\nPreparing for download...\r\n");

  0010c	e59f0174	 ldr         r0, [pc, #0x174]
  00110	eb000000	 bl          KITLOutputDebugString

; 187  : 
; 188  :     // (4) call OEM specific pre-download function
; 189  :     switch (dwAction = OEMPreDownload ())

  00114	eb000000	 bl          OEMPreDownload
  00118	e59f4164	 ldr         r4, [pc, #0x164]
  0011c	e3500000	 cmp         r0, #0
  00120	0a000002	 beq         |$LN9@Bootloader|
  00124	e3500001	 cmp         r0, #1
  00128	0a000021	 beq         |$LN84@Bootloader|
  0012c	ea00003f	 b           |$LN1@Bootloader|
  00130		 |$LN9@Bootloader|

; 190  :     {
; 191  :     case BL_DOWNLOAD:
; 192  :         // (5) download image
; 193  :         if (!DownloadImage (&dwImageStart, &dwImageLength, &dwLaunchAddr))

  00130	e28d2004	 add         r2, sp, #4
  00134	e28d1000	 add         r1, sp, #0
  00138	e28d0008	 add         r0, sp, #8
  0013c	eb000000	 bl          DownloadImage
  00140	e3500000	 cmp         r0, #0
  00144	1a000000	 bne         |$LN6@Bootloader|
  00148		 |$LL7@Bootloader|

; 194  :         {
; 195  :             // error already reported in DownloadImage
; 196  :             SPIN_FOREVER;

  00148	eafffffe	 b           |$LL7@Bootloader|
  0014c		 |$LN6@Bootloader|

; 197  :         }
; 198  :         bDownloaded = TRUE;
; 199  : 
; 200  :         // Check for pTOC signature ("CECE") here, after image in place
; 201  :         if (*(LPDWORD) OEMMapMemAddr (dwImageStart, dwImageStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE)

  0014c	e59d5008	 ldr         r5, [sp, #8]
  00150	e3a07001	 mov         r7, #1
  00154	e2851040	 add         r1, r5, #0x40
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          OEMMapMemAddr
  00160	e5902000	 ldr         r2, [r0]
  00164	e59f3114	 ldr         r3, [pc, #0x114]
  00168	e1520003	 cmp         r2, r3
  0016c	1a00000e	 bne         |$LN71@Bootloader|

; 202  :         {
; 203  :             dwpToc = *(LPDWORD) OEMMapMemAddr (dwImageStart, dwImageStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG));

  00170	e2851044	 add         r1, r5, #0x44
  00174	e1a00005	 mov         r0, r5
  00178	eb000000	 bl          OEMMapMemAddr
  0017c	e5902000	 ldr         r2, [r0]

; 204  :             // need to map the content again since the pointer is going to be in a fixup address
; 205  :             dwpToc = (DWORD) OEMMapMemAddr (dwImageStart, dwpToc + g_dwROMOffset);

  00180	e5943000	 ldr         r3, [r4]
  00184	e1a00005	 mov         r0, r5
  00188	e0831002	 add         r1, r3, r2
  0018c	eb000000	 bl          OEMMapMemAddr
  00190	e1a06000	 mov         r6, r0

; 206  : 
; 207  :             KITLOutputDebugString ("ROMHDR at Address %Xh\r\n", dwImageStart + ROM_SIGNATURE_OFFSET + sizeof (DWORD)); // right after signature

  00194	e59f00e0	 ldr         r0, [pc, #0xE0]
  00198	e2851044	 add         r1, r5, #0x44
  0019c	eb000000	 bl          KITLOutputDebugString
  001a0	e59da000	 ldr         r10, [sp]
  001a4	e59d8004	 ldr         r8, [sp, #4]
  001a8	ea000002	 b           |$LN5@Bootloader|
  001ac		 |$LN71@Bootloader|
  001ac	e59da000	 ldr         r10, [sp]
  001b0	e59d8004	 ldr         r8, [sp, #4]
  001b4		 |$LN84@Bootloader|
  001b4	e3a06000	 mov         r6, #0
  001b8		 |$LN5@Bootloader|

; 208  :         }
; 209  : 
; 210  :         // fall through
; 211  :     case BL_JUMP:
; 212  :         // Before jumping to the image, optionally check the image signature.
; 213  :         // NOTE: if we haven't downloaded the image by now, we assume that it'll be loaded from local storage in OEMLaunch (or it
; 214  :         // already resides in RAM from an earlier download), and in this case, the image start address might be 0.  This means 
; 215  :         // that the image signature routine will need to find the image in storage or in RAM to validate it.  Since the OEM"s 
; 216  :         // OEMLaunch function will need to do this anyways, we trust that it's within their abilities to do it here.
; 217  :         //
; 218  :         if (g_bBINDownload && g_pOEMCheckSignature)

  001b8	e59f20b8	 ldr         r2, [pc, #0xB8]
  001bc	e5d22000	 ldrb        r2, [r2]
  001c0	e3520000	 cmp         r2, #0
  001c4	0a000014	 beq         |$LN2@Bootloader|
  001c8	e59f00a4	 ldr         r0, [pc, #0xA4]
  001cc	e5902000	 ldr         r2, [r0]
  001d0	e3520000	 cmp         r2, #0
  001d4	0a000010	 beq         |$LN2@Bootloader|

; 219  :         {
; 220  :             if (!g_pOEMCheckSignature(dwImageStart, g_dwROMOffset, dwLaunchAddr, bDownloaded))

  001d8	e5941000	 ldr         r1, [r4]
  001dc	e1a04002	 mov         r4, r2
  001e0	e1a02008	 mov         r2, r8
  001e4	e1a03007	 mov         r3, r7
  001e8	e1a00005	 mov         r0, r5
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff14	 bx          r4
  001f4	e3500000	 cmp         r0, #0
  001f8	1a000007	 bne         |$LN2@Bootloader|

; 221  :                 HALT(BLERR_CAT_SIGNATURE);

  001fc	e59f206c	 ldr         r2, [pc, #0x6C]
  00200	e5923000	 ldr         r3, [r2]
  00204	e3530000	 cmp         r3, #0
  00208	13a01000	 movne       r1, #0
  0020c	13e0000c	 mvnne       r0, #0xC
  00210	11a0e00f	 movne       lr, pc
  00214	112fff13	 bxne        r3
  00218		 |$LL41@Bootloader|
  00218	eafffffe	 b           |$LL41@Bootloader|
  0021c		 |$LN2@Bootloader|

; 222  :         }
; 223  :         // (5) final call to launch the image. never returned
; 224  :         OEMLaunch (dwImageStart, dwImageLength, dwLaunchAddr, (const ROMHDR *)dwpToc);

  0021c	e1a03006	 mov         r3, r6
  00220	e1a02008	 mov         r2, r8
  00224	e1a0100a	 mov         r1, r10
  00228	e1a00005	 mov         r0, r5
  0022c	eb000000	 bl          OEMLaunch
  00230		 |$LN1@Bootloader|

; 225  :         // should never return
; 226  :         // fall through
; 227  :     default:
; 228  :         // ERROR! spin forever
; 229  :         HALT (BLERR_INVALIDCMD);

  00230	e59f2038	 ldr         r2, [pc, #0x38]
  00234	e5923000	 ldr         r3, [r2]
  00238	e3530000	 cmp         r3, #0
  0023c	13a01000	 movne       r1, #0
  00240	13e00005	 mvnne       r0, #5
  00244	11a0e00f	 movne       lr, pc
  00248	112fff13	 bxne        r3
  0024c		 |$LL46@Bootloader|
  0024c	eafffffe	 b           |$LL46@Bootloader|
  00250		 |$LN58@Bootloader|

; 163  :     {
; 164  :         // spin forever
; 165  :         HALT (BLERR_KERNELRELOCATE);

  00250	e59f2018	 ldr         r2, [pc, #0x18]
  00254	e5923000	 ldr         r3, [r2]
  00258	e3530000	 cmp         r3, #0
  0025c	13a01000	 movne       r1, #0
  00260	13e00000	 mvnne       r0, #0
  00264	11a0e00f	 movne       lr, pc
  00268	112fff13	 bxne        r3
  0026c		 |$LL26@Bootloader|
  0026c	eafffffe	 b           |$LL26@Bootloader|
  00270		 |$LN88@Bootloader|
  00270		 |$LN89@Bootloader|
  00270	00000000	 DCD         |g_pOEMReportError|
  00274		 |$LN90@Bootloader|
  00274	00000000	 DCD         |g_pOEMCheckSignature|
  00278		 |$LN91@Bootloader|
  00278	00000000	 DCD         |g_bBINDownload|
  0027c		 |$LN92@Bootloader|
  0027c	00000000	 DCD         |??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@|
  00280		 |$LN93@Bootloader|
  00280	43454345	 DCD         0x43454345
  00284		 |$LN94@Bootloader|
  00284	00000000	 DCD         |g_dwROMOffset|
  00288		 |$LN95@Bootloader|
  00288	00000000	 DCD         |??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@|
  0028c		 |$LN96@Bootloader|
  0028c	00000000	 DCD         |pTOC|
  00290		 |$M41429|

			 ENDP  ; |BootloaderMain|

	END

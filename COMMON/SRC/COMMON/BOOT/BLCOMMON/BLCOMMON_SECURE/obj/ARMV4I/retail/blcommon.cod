; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\BOOT\BLCOMMON\blcommon.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|pTOC| [ DATA ]
	EXPORT	|NKSignon| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_pOEMCheckSignature|, 0x4

	 COMMON	|g_pOEMMultiBINNotify|, 0x4

	 COMMON	|g_pOEMReportError|, 0x4

	 COMMON	|g_dwROMOffset|, 0x4

	 COMMON	|g_pOEMVerifyMemory|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|g_fOEMNotified| % 0x4

  00000			 AREA	 |.data|, DATA
|g_bBINDownload| DCB 0x1
|g_downloadFilesRemaining| DCB 0x1

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|pTOC|	DCD	0xffffffff
	%	4
|NKSignon| DCB	0xa, "Microsoft Windows CE Secure Bootloader Common Libra"
	DCB	"ry Version %d.%d Built Jul 10 2013 09:14:57", 0xd, 0xa, 0x0
; File c:\wince600\platform\common\src\common\boot\blcommon\blcommon.c

  00000			 AREA	 |.pdata|, PDATA
|$T41049| DCD	|$LN12@HALT|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HALT|	 PROC

; 145  : {

  00000		 |$LN12@HALT|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41046|

; 146  :     if (g_pOEMReportError)

  00004	e59f2014	 ldr         r2, [pc, #0x14]
  00008	e5923000	 ldr         r3, [r2]
  0000c	e3530000	 cmp         r3, #0

; 147  :     {
; 148  :         g_pOEMReportError (dwReason, 0);

  00010	13a01000	 movne       r1, #0
  00014	11a0e00f	 movne       lr, pc
  00018	112fff13	 bxne        r3
  0001c		 |$LL2@HALT|

; 149  :     }
; 150  :     SPIN_FOREVER;

  0001c	eafffffe	 b           |$LL2@HALT|
  00020		 |$LN13@HALT|
  00020		 |$LN14@HALT|
  00020	00000000	 DCD         |g_pOEMReportError|
  00024		 |$M41047|

			 ENDP  ; |HALT|

	IMPORT	|memset|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T41067| DCD	|$LN13@KernelRelo|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KernelRelocate| PROC

; 238  : {

  00000		 |$LN13@KernelRelo|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41064|
  00004	e1a04000	 mov         r4, r0

; 239  :     ULONG loop;
; 240  :     COPYentry *cptr;
; 241  :     if (pTOC == (ROMHDR *const) -1)

  00008	e3740001	 cmn         r4, #1

; 242  :     {
; 243  :         return (FALSE); // spin forever!

  0000c	03a00000	 moveq       r0, #0

; 255  : }

  00010	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}
  00014	012fff1e	 bxeq        lr

; 244  :     }
; 245  :     // This is where the data sections become valid... don't read globals until after this
; 246  :     for (loop = 0; loop < pTOC->ulCopyEntries; loop++)

  00018	e5943020	 ldr         r3, [r4, #0x20]
  0001c	e3a06000	 mov         r6, #0
  00020	e3530000	 cmp         r3, #0
  00024	9a000016	 bls         |$LN3@KernelRelo|
  00028	e3a07000	 mov         r7, #0
  0002c		 |$LL5@KernelRelo|
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e0875003	 add         r5, r7, r3

; 247  :     {
; 248  :         cptr = (COPYentry *)(pTOC->ulCopyOffset + loop*sizeof(COPYentry));
; 249  :         if (cptr->ulCopyLen)

  00034	e5953008	 ldr         r3, [r5, #8]
  00038	e3530000	 cmp         r3, #0

; 250  :             memcpy((LPVOID)cptr->ulDest,(LPVOID)cptr->ulSource,cptr->ulCopyLen);

  0003c	15951000	 ldrne       r1, [r5]
  00040	15950004	 ldrne       r0, [r5, #4]
  00044	11a02003	 movne       r2, r3
  00048	1b000000	 blne        memcpy

; 251  :         if (cptr->ulCopyLen != cptr->ulDestLen)

  0004c	e595200c	 ldr         r2, [r5, #0xC]
  00050	e5953008	 ldr         r3, [r5, #8]
  00054	e1530002	 cmp         r3, r2

; 252  :             memset((LPVOID)(cptr->ulDest+cptr->ulCopyLen),0,cptr->ulDestLen-cptr->ulCopyLen);

  00058	11a00003	 movne       r0, r3
  0005c	15953004	 ldrne       r3, [r5, #4]
  00060	10422000	 subne       r2, r2, r0
  00064	13a01000	 movne       r1, #0
  00068	10830000	 addne       r0, r3, r0
  0006c	1b000000	 blne        memset
  00070	e5943020	 ldr         r3, [r4, #0x20]
  00074	e2866001	 add         r6, r6, #1
  00078	e2877010	 add         r7, r7, #0x10
  0007c	e1560003	 cmp         r6, r3
  00080	3affffe9	 bcc         |$LL5@KernelRelo|
  00084		 |$LN3@KernelRelo|

; 253  :     }
; 254  :     return (TRUE);

  00084	e3a00001	 mov         r0, #1

; 255  : }

  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M41065|

			 ENDP  ; |KernelRelocate|

	EXPORT	|??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@| [ DATA ] ; `string'
	IMPORT	|KITLOutputDebugString|

  00000			 AREA	 |.pdata|, PDATA
|$T41085| DCD	|$LN14@VerifyChec|
	DCD	0x40001501

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@| DCB "ERROR:"
	DCB	" Checksum failure (expected=0x%x  computed=0x%x)", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VerifyChecksum| PROC

; 258  : {

  00000		 |$LN14@VerifyChec|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41082|
  00004	e1a0e002	 mov         lr, r2
  00008	e3500000	 cmp         r0, #0

; 259  :     // Check the CRC
; 260  :     DWORD dwCRC = 0;

  0000c	e3a02000	 mov         r2, #0

; 261  :     DWORD i;
; 262  :     for (i = 0; i < cbRecord; i++)

  00010	0a000003	 beq         |$LN2@VerifyChec|
  00014		 |$LL4@VerifyChec|

; 263  :         dwCRC += *pbRecord ++;

  00014	e4d13001	 ldrb        r3, [r1], #1
  00018	e2500001	 subs        r0, r0, #1
  0001c	e0822003	 add         r2, r2, r3
  00020	1afffffb	 bne         |$LL4@VerifyChec|
  00024		 |$LN2@VerifyChec|

; 264  : 
; 265  :     if (dwCRC != dwChksum)

  00024	e152000e	 cmp         r2, lr
  00028	0a000005	 beq         |$LN11@VerifyChec|

; 266  :         KITLOutputDebugString ("ERROR: Checksum failure (expected=0x%x  computed=0x%x)\r\n", dwChksum, dwCRC);

  0002c	e59f001c	 ldr         r0, [pc, #0x1C]
  00030	e1a0100e	 mov         r1, lr
  00034	eb000000	 bl          KITLOutputDebugString

; 267  : 
; 268  :     return (dwCRC == dwChksum);

  00038	e3a00000	 mov         r0, #0

; 269  : }

  0003c	e49de004	 ldr         lr, [sp], #4
  00040	e12fff1e	 bx          lr
  00044		 |$LN11@VerifyChec|

; 267  : 
; 268  :     return (dwCRC == dwChksum);

  00044	e3a00001	 mov         r0, #1

; 269  : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN15@VerifyChec|
  00050		 |$LN16@VerifyChec|
  00050	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  00054		 |$M41083|

			 ENDP  ; |VerifyChecksum|

	EXPORT	|??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07LAGBNAEN@R000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07HMMLNAND@S000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07MMNKOBGG@B000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07CBKBMMIF@X000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_07JLHFPECJ@N000FF?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@| [ DATA ] ; `string'
	IMPORT	|OEMReadData|
	IMPORT	|memcmp|

  00004			 AREA	 |.bss|, NOINIT
|g_hdr|	%	0x7
|g_hdr|	%	0x7

  00000			 AREA	 |.pdata|, PDATA
|$T41098| DCD	|$LN16@GetImageTy|
	DCD	0x40005001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_UNKNOWN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_SIGNED_NB0", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07LAGBNAEN@R000FF?6?$AA@| DCB "R000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_SIGNED_BIN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07HMMLNAND@S000FF?6?$AA@| DCB "S000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@| DCB 0xd, 0xa
	DCB	"BL_IMAGE_TYPE_BIN", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07MMNKOBGG@B000FF?6?$AA@| DCB "B000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_MULTIXIP", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07CBKBMMIF@X000FF?6?$AA@| DCB "X000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@| DCB 0xd
	DCB	0xa, "BL_IMAGE_TYPE_MANIFEST", 0xd, 0xa, 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_07JLHFPECJ@N000FF?6?$AA@| DCB "N000FF", 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read image signature.", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetImageType| PROC

; 273  : {

  00000		 |$LN16@GetImageTy|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41095|

; 274  :     BL_IMAGE_TYPE rval = BL_IMAGE_TYPE_UNKNOWN;
; 275  : 
; 276  :     // read the 7 byte "magic number"
; 277  :     //
; 278  :     if (!OEMReadData (BL_HDRSIG_SIZE, g_hdr))

  00004	e59f1108	 ldr         r1, [pc, #0x108]
  00008	e3a00007	 mov         r0, #7
  0000c	eb000000	 bl          OEMReadData
  00010	e3500000	 cmp         r0, #0

; 279  :     {
; 280  :         KITLOutputDebugString ("\r\nERROR: Unable to read image signature.\r\n");

  00014	059f0120	 ldreq       r0, [pc, #0x120]
  00018	0b000000	 bleq        KITLOutputDebugString

; 281  :         rval =  BL_IMAGE_TYPE_NOT_FOUND;
; 282  :     }
; 283  : 
; 284  :     
; 285  :     // The N000FF packet indicates a manifest, which is constructed by Platform 
; 286  :     // Builder when we're downloading multiple .bin files or an .nb0 file.
; 287  :     //
; 288  :     if (!memcmp (g_hdr, "N000FF\x0A", BL_HDRSIG_SIZE))

  0001c	e59f1114	 ldr         r1, [pc, #0x114]
  00020	e59f00ec	 ldr         r0, [pc, #0xEC]
  00024	e3a02007	 mov         r2, #7
  00028	eb000000	 bl          memcmp
  0002c	e3500000	 cmp         r0, #0
  00030	1a000004	 bne         |$LN10@GetImageTy|

; 289  :     {
; 290  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_MANIFEST\r\n\r\n");

  00034	e59f00f8	 ldr         r0, [pc, #0xF8]
  00038	eb000000	 bl          KITLOutputDebugString

; 291  :         rval =  BL_IMAGE_TYPE_MANIFEST;

  0003c	e3a00000	 mov         r0, #0

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$LN10@GetImageTy|

; 292  :     }
; 293  :     else if (!memcmp (g_hdr, "X000FF\x0A", BL_HDRSIG_SIZE))

  00048	e59f10e0	 ldr         r1, [pc, #0xE0]
  0004c	e59f00c0	 ldr         r0, [pc, #0xC0]
  00050	e3a02007	 mov         r2, #7
  00054	eb000000	 bl          memcmp
  00058	e3500000	 cmp         r0, #0
  0005c	1a000004	 bne         |$LN8@GetImageTy|

; 294  :     {
; 295  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_MULTIXIP\r\n\r\n");

  00060	e59f00c4	 ldr         r0, [pc, #0xC4]
  00064	eb000000	 bl          KITLOutputDebugString

; 296  :         rval =  BL_IMAGE_TYPE_MULTIXIP;

  00068	e3a00005	 mov         r0, #5

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  0006c	e49de004	 ldr         lr, [sp], #4
  00070	e12fff1e	 bx          lr
  00074		 |$LN8@GetImageTy|

; 297  :     }
; 298  :     else if (!memcmp (g_hdr, "B000FF\x0A", BL_HDRSIG_SIZE))

  00074	e59f10ac	 ldr         r1, [pc, #0xAC]
  00078	e59f0094	 ldr         r0, [pc, #0x94]
  0007c	e3a02007	 mov         r2, #7
  00080	eb000000	 bl          memcmp
  00084	e3500000	 cmp         r0, #0
  00088	1a000004	 bne         |$LN6@GetImageTy|

; 299  :     {
; 300  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_BIN\r\n\r\n");

  0008c	e59f0090	 ldr         r0, [pc, #0x90]
  00090	eb000000	 bl          KITLOutputDebugString

; 301  :         rval =  BL_IMAGE_TYPE_BIN;

  00094	e3a00001	 mov         r0, #1

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00098	e49de004	 ldr         lr, [sp], #4
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN6@GetImageTy|

; 302  :     }
; 303  :     else if (!memcmp (g_hdr, "S000FF\x0A", BL_HDRSIG_SIZE))

  000a0	e59f1078	 ldr         r1, [pc, #0x78]
  000a4	e59f0068	 ldr         r0, [pc, #0x68]
  000a8	e3a02007	 mov         r2, #7
  000ac	eb000000	 bl          memcmp
  000b0	e3500000	 cmp         r0, #0
  000b4	1a000004	 bne         |$LN4@GetImageTy|

; 304  :     {
; 305  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_SIGNED_BIN\r\n\r\n");

  000b8	e59f005c	 ldr         r0, [pc, #0x5C]
  000bc	eb000000	 bl          KITLOutputDebugString

; 306  :         rval =  BL_IMAGE_TYPE_SIGNED_BIN;

  000c0	e3a00003	 mov         r0, #3

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  000c4	e49de004	 ldr         lr, [sp], #4
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN4@GetImageTy|

; 307  :     }
; 308  :     else if (!memcmp (g_hdr, "R000FF\x0A", BL_HDRSIG_SIZE))

  000cc	e59f1044	 ldr         r1, [pc, #0x44]
  000d0	e59f003c	 ldr         r0, [pc, #0x3C]
  000d4	e3a02007	 mov         r2, #7
  000d8	eb000000	 bl          memcmp
  000dc	e3500000	 cmp         r0, #0
  000e0	1a000004	 bne         |$LN2@GetImageTy|

; 309  :     {
; 310  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_SIGNED_NB0\r\n\r\n");

  000e4	e59f0024	 ldr         r0, [pc, #0x24]
  000e8	eb000000	 bl          KITLOutputDebugString

; 311  :         rval =  BL_IMAGE_TYPE_SIGNED_NB0;

  000ec	e3a00004	 mov         r0, #4

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  000f0	e49de004	 ldr         lr, [sp], #4
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN2@GetImageTy|

; 312  :     }
; 313  :     else
; 314  :     {
; 315  :         KITLOutputDebugString("\r\nBL_IMAGE_TYPE_UNKNOWN\r\n\r\n");

  000f8	e59f000c	 ldr         r0, [pc, #0xC]
  000fc	eb000000	 bl          KITLOutputDebugString

; 316  :         rval =  BL_IMAGE_TYPE_UNKNOWN;

  00100	e3a00006	 mov         r0, #6

; 317  :     }
; 318  : 
; 319  :     return rval;  
; 320  : }

  00104	e49de004	 ldr         lr, [sp], #4
  00108	e12fff1e	 bx          lr
  0010c		 |$LN17@GetImageTy|
  0010c		 |$LN18@GetImageTy|
  0010c	00000000	 DCD         |??_C@_0BM@DKIOIAMD@?$AN?6BL_IMAGE_TYPE_UNKNOWN?$AN?6?$AN?6?$AA@|
  00110		 |$LN19@GetImageTy|
  00110	00000000	 DCD         |??_C@_0BP@KNNCEABF@?$AN?6BL_IMAGE_TYPE_SIGNED_NB0?$AN?6?$AN?6?$AA@|
  00114		 |$LN20@GetImageTy|
  00114	00000000	 DCD         |g_hdr|
  00118		 |$LN21@GetImageTy|
  00118	00000000	 DCD         |??_C@_07LAGBNAEN@R000FF?6?$AA@|
  0011c		 |$LN22@GetImageTy|
  0011c	00000000	 DCD         |??_C@_0BP@MJFCGNBB@?$AN?6BL_IMAGE_TYPE_SIGNED_BIN?$AN?6?$AN?6?$AA@|
  00120		 |$LN23@GetImageTy|
  00120	00000000	 DCD         |??_C@_07HMMLNAND@S000FF?6?$AA@|
  00124		 |$LN24@GetImageTy|
  00124	00000000	 DCD         |??_C@_0BI@HBMHAEFD@?$AN?6BL_IMAGE_TYPE_BIN?$AN?6?$AN?6?$AA@|
  00128		 |$LN25@GetImageTy|
  00128	00000000	 DCD         |??_C@_07MMNKOBGG@B000FF?6?$AA@|
  0012c		 |$LN26@GetImageTy|
  0012c	00000000	 DCD         |??_C@_0BN@IHLEHBEK@?$AN?6BL_IMAGE_TYPE_MULTIXIP?$AN?6?$AN?6?$AA@|
  00130		 |$LN27@GetImageTy|
  00130	00000000	 DCD         |??_C@_07CBKBMMIF@X000FF?6?$AA@|
  00134		 |$LN28@GetImageTy|
  00134	00000000	 DCD         |??_C@_0BN@GCKOHOON@?$AN?6BL_IMAGE_TYPE_MANIFEST?$AN?6?$AN?6?$AA@|
  00138		 |$LN29@GetImageTy|
  00138	00000000	 DCD         |??_C@_07JLHFPECJ@N000FF?6?$AA@|
  0013c		 |$LN30@GetImageTy|
  0013c	00000000	 DCD         |??_C@_0CL@OKMIEAHJ@?$AN?6ERROR?3?5Unable?5to?5read?5image?5si@|
  00140		 |$M41096|

			 ENDP  ; |GetImageType|

	EXPORT	|??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@| [ DATA ] ; `string'

  00012			 AREA	 |.bss|, NOINIT
|g_DownloadManifest| % 0x1a30
|g_DownloadManifest| % 0x1a30

  00000			 AREA	 |.pdata|, PDATA
|$T41186| DCD	|$LN59@CheckImage|
	DCD	0x40004b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read download manifest information.", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@| DCB 0xd, 0xa
	DCB	"ERROR: Download manifest packet failed checksum verifica"
	DCB	"tion.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@| DCB 0xd, 0xa
	DCB	"ERROR: Unable to read download manifest checksum.", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CheckImageManifest| PROC

; 324  : {

  00000		 |$LN59@CheckImage|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41183|

; 325  :     DWORD dwRecChk;
; 326  : 
; 327  :     // read the packet checksum.
; 328  :     //
; 329  :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecChk))

  00008	e28d1000	 add         r1, sp, #0
  0000c	e3a00004	 mov         r0, #4
  00010	eb000000	 bl          OEMReadData
  00014	e3500000	 cmp         r0, #0
  00018	1a000009	 bne         |$LN4@CheckImage|

; 330  :     {
; 331  :         KITLOutputDebugString("\r\nERROR: Unable to read download manifest checksum.\r\n");

  0001c	e59f0104	 ldr         r0, [pc, #0x104]
  00020	eb000000	 bl          KITLOutputDebugString

; 332  :         HALT (BLERR_MAGIC);

  00024	e59f20e8	 ldr         r2, [pc, #0xE8]
  00028	e5923000	 ldr         r3, [r2]
  0002c	e3530000	 cmp         r3, #0
  00030	13a01000	 movne       r1, #0
  00034	13e00007	 mvnne       r0, #7
  00038	11a0e00f	 movne       lr, pc
  0003c	112fff13	 bxne        r3
  00040		 |$LL8@CheckImage|
  00040	eafffffe	 b           |$LL8@CheckImage|
  00044		 |$LN4@CheckImage|

; 333  :         return FALSE;
; 334  :     }
; 335  : 
; 336  :     // read region descriptions (start address and length).
; 337  :     //
; 338  :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &g_DownloadManifest.dwNumRegions) ||
; 339  :         !OEMReadData ((g_DownloadManifest.dwNumRegions * sizeof(RegionInfo)), (LPBYTE) &g_DownloadManifest.Region[0]))

  00044	e59f40d8	 ldr         r4, [pc, #0xD8]
  00048	e3a00004	 mov         r0, #4
  0004c	e1a01004	 mov         r1, r4
  00050	eb000000	 bl          OEMReadData
  00054	e3500000	 cmp         r0, #0
  00058	0a000023	 beq         |$LN2@CheckImage|
  0005c	e5943000	 ldr         r3, [r4]
  00060	e3a02f43	 mov         r2, #0x43, 30
  00064	e2841004	 add         r1, r4, #4
  00068	e0000293	 mul         r0, r3, r2
  0006c	eb000000	 bl          OEMReadData
  00070	e3500000	 cmp         r0, #0
  00074	0a00001c	 beq         |$LN2@CheckImage|

; 343  :         return FALSE;
; 344  :     }
; 345  : 
; 346  :     // verify the packet checksum.
; 347  :     //
; 348  :     if (!VerifyChecksum((g_DownloadManifest.dwNumRegions * sizeof(RegionInfo)), (LPBYTE) &g_DownloadManifest.Region[0], dwRecChk))

  00078	e5943000	 ldr         r3, [r4]
  0007c	e3a02f43	 mov         r2, #0x43, 30
  00080	e2841004	 add         r1, r4, #4
  00084	e0100293	 muls        r0, r3, r2
  00088	e3a02000	 mov         r2, #0
  0008c	0a000003	 beq         |$LN18@CheckImage|
  00090		 |$LL20@CheckImage|
  00090	e4d13001	 ldrb        r3, [r1], #1
  00094	e2500001	 subs        r0, r0, #1
  00098	e0822003	 add         r2, r2, r3
  0009c	1afffffb	 bne         |$LL20@CheckImage|
  000a0		 |$LN18@CheckImage|
  000a0	e59d1000	 ldr         r1, [sp]
  000a4	e1520001	 cmp         r2, r1
  000a8	0a00000b	 beq         |$LN1@CheckImage|
  000ac	e59f006c	 ldr         r0, [pc, #0x6C]
  000b0	eb000000	 bl          KITLOutputDebugString

; 349  :     {
; 350  :         KITLOutputDebugString ("\r\nERROR: Download manifest packet failed checksum verification.\r\n");

  000b4	e59f0060	 ldr         r0, [pc, #0x60]
  000b8	eb000000	 bl          KITLOutputDebugString

; 351  :         HALT (BLERR_CHECKSUM);

  000bc	e59f2050	 ldr         r2, [pc, #0x50]
  000c0	e5923000	 ldr         r3, [r2]
  000c4	e3530000	 cmp         r3, #0
  000c8	13a01000	 movne       r1, #0
  000cc	13e00006	 mvnne       r0, #6
  000d0	11a0e00f	 movne       lr, pc
  000d4	112fff13	 bxne        r3
  000d8		 |$LL26@CheckImage|
  000d8	eafffffe	 b           |$LL26@CheckImage|
  000dc		 |$LN1@CheckImage|

; 352  :         return FALSE;
; 353  :     }
; 354  : 
; 355  :     return TRUE;

  000dc	e3a00001	 mov         r0, #1

; 356  : }

  000e0	e28dd004	 add         sp, sp, #4
  000e4	e8bd4010	 ldmia       sp!, {r4, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$LN2@CheckImage|

; 340  :     {
; 341  :         KITLOutputDebugString("\r\nERROR: Unable to read download manifest information.\r\n");

  000ec	e59f0024	 ldr         r0, [pc, #0x24]
  000f0	eb000000	 bl          KITLOutputDebugString

; 342  :         HALT (BLERR_MAGIC);

  000f4	e59f2018	 ldr         r2, [pc, #0x18]
  000f8	e5923000	 ldr         r3, [r2]
  000fc	e3530000	 cmp         r3, #0
  00100	13a01000	 movne       r1, #0
  00104	13e00007	 mvnne       r0, #7
  00108	11a0e00f	 movne       lr, pc
  0010c	112fff13	 bxne        r3
  00110		 |$LL13@CheckImage|
  00110	eafffffe	 b           |$LL13@CheckImage|
  00114		 |$LN60@CheckImage|
  00114		 |$LN61@CheckImage|
  00114	00000000	 DCD         |g_pOEMReportError|
  00118		 |$LN62@CheckImage|
  00118	00000000	 DCD         |??_C@_0DJ@PIPLIHFI@?$AN?6ERROR?3?5Unable?5to?5read?5download@|
  0011c		 |$LN63@CheckImage|
  0011c	00000000	 DCD         |??_C@_0EC@LAKEOKID@?$AN?6ERROR?3?5Download?5manifest?5packe@|
  00120		 |$LN64@CheckImage|
  00120	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  00124		 |$LN65@CheckImage|
  00124	00000000	 DCD         |g_DownloadManifest|
  00128		 |$LN66@CheckImage|
  00128	00000000	 DCD         |??_C@_0DG@DBBGHEAG@?$AN?6ERROR?3?5Unable?5to?5read?5download@|
  0012c		 |$M41184|

			 ENDP  ; |CheckImageManifest|

	EXPORT	|??_C@_0CN@MMIJIGEN@Secure?5Boot?5Loader?5includes?5?$CFd?5p@| [ DATA ] ; `string'
	IMPORT	|g_wNumPublicKeys|
	IMPORT	|g_rgpbPublicKeys|
	IMPORT	|g_rgdwKeyLengths|

  03472			 AREA	 |.bss|, NOINIT
|g_keyData| %	0x10
|g_keyData| %	0x10

  00000			 AREA	 |.pdata|, PDATA
|$T41202| DCD	|$LN5@InitSecure|
	DCD	0x40001701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CN@MMIJIGEN@Secure?5Boot?5Loader?5includes?5?$CFd?5p@| DCB "Secur"
	DCB	"e Boot Loader includes %d public keys", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitSecureBootLoader| PROC

; 471  : {

  00000		 |$LN5@InitSecure|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41199|

; 472  :     // Initialize public keys for signature validation
; 473  :     g_keyData.rgpbPublicKeys  = g_rgpbPublicKeys;       // pointer to array of public keys        
; 474  :     g_keyData.rgdwKeyLengths  = g_rgdwKeyLengths;       // pointer to array of public key lengths 
; 475  :     g_keyData.wNumPublicKeys  = g_wNumPublicKeys;       // number of public keys in rgpbPublicKeys

  00004	e59f304c	 ldr         r3, [pc, #0x4C]
  00008	e59f2044	 ldr         r2, [pc, #0x44]
  0000c	e59fe03c	 ldr         lr, [pc, #0x3C]
  00010	e1d310b0	 ldrh        r1, [r3]
  00014	e59f3030	 ldr         r3, [pc, #0x30]

; 476  :     g_keyData.wMinSearchIndex = 0;                      // starting array index of search         
; 477  :     g_keyData.wMaxSearchIndex = g_wNumPublicKeys - 1;   // ending array index of search           
; 478  : 
; 479  :     KITLOutputDebugString("Secure Boot Loader includes %d public keys\r\n",
; 480  :         g_keyData.wNumPublicKeys);

  00018	e59f0028	 ldr         r0, [pc, #0x28]
  0001c	e3a04000	 mov         r4, #0
  00020	e88e000c	 stmia       lr, {r2, r3}
  00024	e2812cff	 add         r2, r1, #0xFF, 24
  00028	e28230ff	 add         r3, r2, #0xFF
  0002c	e1ce10b8	 strh        r1, [lr, #8]
  00030	e1ce40ba	 strh        r4, [lr, #0xA]
  00034	e1ce30bc	 strh        r3, [lr, #0xC]
  00038	eb000000	 bl          KITLOutputDebugString

; 481  :         
; 482  :     return TRUE;

  0003c	e3a00001	 mov         r0, #1

; 483  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN6@InitSecure|
  00048		 |$LN7@InitSecure|
  00048	00000000	 DCD         |??_C@_0CN@MMIJIGEN@Secure?5Boot?5Loader?5includes?5?$CFd?5p@|
  0004c		 |$LN8@InitSecure|
  0004c	00000000	 DCD         |g_rgdwKeyLengths|
  00050		 |$LN9@InitSecure|
  00050	00000000	 DCD         |g_keyData|
  00054		 |$LN10@InitSecure|
  00054	00000000	 DCD         |g_rgpbPublicKeys|
  00058		 |$LN11@InitSecure|
  00058	00000000	 DCD         |g_wNumPublicKeys|
  0005c		 |$M41200|

			 ENDP  ; |InitSecureBootLoader|

	EXPORT	|??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_03ILDADBHF@RAM?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_05HPMNGINJ@FLASH?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@| [ DATA ] ; `string'
	IMPORT	|OEMWriteFlash|
	IMPORT	|OEMIsFlashAddr|

  00000			 AREA	 |.pdata|, PDATA
|$T41235| DCD	|$LN25@WriteImage|
	DCD	0x40003802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@| DCB "["
	DCB	"%d]: Address=0x%x  Length=0x%x  Name=""%s"" Target=%s", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_03ILDADBHF@RAM?$AA@| DCB "RAM", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_05HPMNGINJ@FLASH?$AA@| DCB "FLASH", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@| DCB 0xd, 0xa
	DCB	"Completed file(s):", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@| DCB "-"
	DCB	"--------------------------------------------------------"
	DCB	"----------------------", 0xd, 0xa, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteImageToFlash| PROC

; 1316 : {

  00000		 |$LN25@WriteImage|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41232|

; 1317 :     BOOL  bFlash;
; 1318 :     DWORD i;
; 1319 :     
; 1320 :     KITLOutputDebugString("\r\nCompleted file(s):\r\n");

  00008	e59f00cc	 ldr         r0, [pc, #0xCC]
  0000c	eb000000	 bl          KITLOutputDebugString

; 1321 :     KITLOutputDebugString("-------------------------------------------------------------------------------\r\n");

  00010	e59f00c0	 ldr         r0, [pc, #0xC0]
  00014	eb000000	 bl          KITLOutputDebugString

; 1322 : 
; 1323 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)

  00018	e59f50b4	 ldr         r5, [pc, #0xB4]
  0001c	e3a06000	 mov         r6, #0
  00020	e5953000	 ldr         r3, [r5]
  00024	e3530000	 cmp         r3, #0
  00028	0a000019	 beq         |$LN22@WriteImage|
  0002c	e2854004	 add         r4, r5, #4
  00030		 |$LL5@WriteImage|

; 1324 :     {
; 1325 :         RegionInfo *pRegion = &g_DownloadManifest.Region[i];
; 1326 : 
; 1327 :         bFlash = OEMIsFlashAddr( pRegion->dwRegionStart );

  00030	e5940000	 ldr         r0, [r4]
  00034	eb000000	 bl          OEMIsFlashAddr
  00038	e1b08000	 movs        r8, r0

; 1328 :         
; 1329 :         KITLOutputDebugString("[%d]: Address=0x%x  Length=0x%x  Name=\"%s\" Target=%s\r\n",
; 1330 :             i, 
; 1331 :             pRegion->dwRegionStart, 
; 1332 :             pRegion->dwRegionLength, 
; 1333 :             pRegion->szFileName,
; 1334 :             (bFlash ? "FLASH" : "RAM"));

  0003c	159f708c	 ldrne       r7, [pc, #0x8C]
  00040	059f7084	 ldreq       r7, [pc, #0x84]
  00044	e5943004	 ldr         r3, [r4, #4]
  00048	e5942000	 ldr         r2, [r4]
  0004c	e59f0074	 ldr         r0, [pc, #0x74]
  00050	e284e008	 add         lr, r4, #8
  00054	e1a01006	 mov         r1, r6
  00058	e58d7004	 str         r7, [sp, #4]
  0005c	e58de000	 str         lr, [sp]
  00060	eb000000	 bl          KITLOutputDebugString

; 1335 : 
; 1336 :         if (bFlash) 

  00064	e3580000	 cmp         r8, #0
  00068	0a000004	 beq         |$LN4@WriteImage|

; 1337 :         {
; 1338 :             if (!OEMWriteFlash (pRegion->dwRegionStart, pRegion->dwRegionLength))

  0006c	e5941004	 ldr         r1, [r4, #4]
  00070	e5940000	 ldr         r0, [r4]
  00074	eb000000	 bl          OEMWriteFlash
  00078	e3500000	 cmp         r0, #0
  0007c	0a000008	 beq         |$LN17@WriteImage|
  00080		 |$LN4@WriteImage|

; 1322 : 
; 1323 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)

  00080	e5953000	 ldr         r3, [r5]
  00084	e2866001	 add         r6, r6, #1
  00088	e2844f43	 add         r4, r4, #0x43, 30
  0008c	e1560003	 cmp         r6, r3
  00090	3affffe6	 bcc         |$LL5@WriteImage|
  00094		 |$LN22@WriteImage|

; 1341 :                 return FALSE;
; 1342 :             }
; 1343 :         }
; 1344 :     }
; 1345 : 
; 1346 :     return TRUE;    

  00094	e3a00001	 mov         r0, #1

; 1347 : }

  00098	e28dd008	 add         sp, sp, #8
  0009c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN17@WriteImage|

; 1339 :             {
; 1340 :                 HALT (BLERR_FLASH_WRITE);

  000a4	e59f2018	 ldr         r2, [pc, #0x18]
  000a8	e5923000	 ldr         r3, [r2]
  000ac	e3530000	 cmp         r3, #0
  000b0	13a01000	 movne       r1, #0
  000b4	13e0000b	 mvnne       r0, #0xB
  000b8	11a0e00f	 movne       lr, pc
  000bc	112fff13	 bxne        r3
  000c0		 |$LL11@WriteImage|
  000c0	eafffffe	 b           |$LL11@WriteImage|
  000c4		 |$LN26@WriteImage|
  000c4		 |$LN27@WriteImage|
  000c4	00000000	 DCD         |g_pOEMReportError|
  000c8		 |$LN28@WriteImage|
  000c8	00000000	 DCD         |??_C@_0DH@GJCJAHAP@?$FL?$CFd?$FN?3?5Address?$DN0x?$CFx?5?5Length?$DN0x?$CFx?5@|
  000cc		 |$LN29@WriteImage|
  000cc	00000000	 DCD         |??_C@_03ILDADBHF@RAM?$AA@|
  000d0		 |$LN30@WriteImage|
  000d0	00000000	 DCD         |??_C@_05HPMNGINJ@FLASH?$AA@|
  000d4		 |$LN31@WriteImage|
  000d4	00000000	 DCD         |g_DownloadManifest|
  000d8		 |$LN32@WriteImage|
  000d8	00000000	 DCD         |??_C@_0FC@PGPOMBFM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@|
  000dc		 |$LN33@WriteImage|
  000dc	00000000	 DCD         |??_C@_0BH@FIOKDOBJ@?$AN?6Completed?5file?$CIs?$CJ?3?$AN?6?$AA@|
  000e0		 |$M41233|

			 ENDP  ; |WriteImageToFlash|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T41255| DCD	|$LN5@PrintPacke|
	DCD	0xc0000b02

  00000			 AREA	 |.xdata|, DATA
|$T41251| DCD	0xfffffff8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41251|

  00008		 |PrintPacketData| PROC

; 1352 : {

  00008		 |$LN5@PrintPacke|
  00008	e52de004	 str         lr, [sp, #-4]!
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M41252|
  00010	e59f3018	 ldr         r3, [pc, #0x18]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3000	 str         r3, [sp]
  0001c	e59d0000	 ldr         r0, [sp]
  00020	eb000000	 bl          __security_check_cookie

; 1353 : #ifdef DEBUG
; 1354 :     DWORD i;
; 1355 :     
; 1356 :     KITLOutputDebugString("packetData.pbData        = 0x%x\r\n", packetData.pbData);
; 1357 :     
; 1358 :     KITLOutputDebugString("pbData = [");
; 1359 :     for (i = 0; i < packetData.dwDataLength; i++) {
; 1360 :         KITLOutputDebugString("%x ", packetData.pbData[i]);   
; 1361 :         
; 1362 :         if (20 < i && i < packetData.dwDataLength) {
; 1363 :             KITLOutputDebugString("...");
; 1364 :             break;
; 1365 :         }
; 1366 :     }
; 1367 :     KITLOutputDebugString("]\r\n\r\n");
; 1368 :     
; 1369 :     KITLOutputDebugString("packetData.dwDataLength  = 0x%x\r\n", packetData.dwDataLength);
; 1370 :     KITLOutputDebugString("packetData.pbSig         = 0x%x\r\n", packetData.pbSig       );
; 1371 :     KITLOutputDebugString("packetData.dwSigLength   = 0x%x\r\n", packetData.dwSigLength );
; 1372 :     KITLOutputDebugString("packetData.dwRecAddress  = 0x%x\r\n", packetData.dwRecAddress);
; 1373 :     KITLOutputDebugString("packetData.dwRecLength   = 0x%x\r\n", packetData.dwRecLength );
; 1374 :     KITLOutputDebugString("packetData.dwRecCheck    = 0x%x\r\n", packetData.dwRecCheck  );
; 1375 :     KITLOutputDebugString("packetData.dwSeqNum      = 0x%x\r\n", packetData.dwSequenceNumber);
; 1376 :     KITLOutputDebugString("packetData.bFlags        = 0x%x\r\n", packetData.bFlags      );
; 1377 :     KITLOutputDebugString("\r\n");
; 1378 :     
; 1379 :     KITLOutputDebugString("Signature = [");
; 1380 :     for (i = 0; i < sizeof(g_rgpbSignature); i++) {
; 1381 :         KITLOutputDebugString("%x ", g_rgpbSignature[i]);   
; 1382 :     }
; 1383 :     KITLOutputDebugString("]\r\n\r\n");
; 1384 : #endif
; 1385 : }

  00024	e28dd004	 add         sp, sp, #4
  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@PrintPacke|
  00030		 |$LN7@PrintPacke|
  00030	00000000	 DCD         |__security_cookie|
  00034		 |$M41253|

			 ENDP  ; |PrintPacketData|


  00000			 AREA	 |.pdata|, PDATA
|$T41265| DCD	|$LN5@ComputeChe|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ComputeChecksum| PROC

; 1391 : {

  00000		 |$LN5@ComputeChe|
  00000		 |$M41262|

; 1392 : #ifdef DEBUG
; 1393 :     RegionInfo *pRegion;
; 1394 :     DWORD       dwRegionLength;
; 1395 :     DWORD       dwChecksum;
; 1396 :     BYTE       *pbCache;
; 1397 :     DWORD       i;
; 1398 :     
; 1399 :     for (i = 0; i < g_DownloadManifest.dwNumRegions; i++)
; 1400 :     {
; 1401 :         pRegion         = &g_DownloadManifest.Region[i];
; 1402 :         pbCache         = (LPBYTE) OEMMapMemAddr( pRegion->dwRegionStart, pRegion->dwRegionStart );
; 1403 :         dwRegionLength  = pRegion->dwRegionLength;
; 1404 :         dwChecksum      = 0;
; 1405 : 
; 1406 :         KITLOutputDebugString("Computing checksum: image start = 0x%x, len = 0x%x\r\n", 
; 1407 :             pbCache, dwRegionLength);
; 1408 : 
; 1409 :         while(dwRegionLength--) {
; 1410 :             dwChecksum += *pbCache++;
; 1411 :         }
; 1412 : 
; 1413 :         KITLOutputDebugString("Checksum = 0x%x (0x%x bytes)\r\n", dwChecksum, pRegion->dwRegionLength);
; 1414 :     }
; 1415 : #endif
; 1416 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41263|

			 ENDP  ; |ComputeChecksum|

	EXPORT	|??_C@_06OLEINIPO@nk?4exe?$AA@| [ DATA ] ; `string'
	IMPORT	|OEMMapMemAddr|
	IMPORT	|strcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T41286| DCD	|$LN16@IsKernelRe|
	DCD	0x40002f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06OLEINIPO@nk?4exe?$AA@| DCB "nk.exe", 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsKernelRegion| PROC

; 1431 : {

  00000		 |$LN16@IsKernelRe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41283|
  00004	e1b04000	 movs        r4, r0

; 1432 : 	DWORD dwCacheAddress = 0;
; 1433 : 	ROMHDR *pROMHeader;
; 1434 : 	DWORD dwNumModules = 0;
; 1435 : 	TOCentry *plTOC;
; 1436 : 
; 1437 :     if (dwRegionStart == 0 || dwRegionLength == 0)

  00008	0a000022	 beq         |$LN6@IsKernelRe|
  0000c	e3510000	 cmp         r1, #0
  00010	0a000020	 beq         |$LN6@IsKernelRe|

; 1439 : 
; 1440 :     if (*(LPDWORD) OEMMapMemAddr (dwRegionStart, dwRegionStart + ROM_SIGNATURE_OFFSET) != ROM_SIGNATURE)

  00014	e2841040	 add         r1, r4, #0x40
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          OEMMapMemAddr
  00020	e5902000	 ldr         r2, [r0]
  00024	e59f308c	 ldr         r3, [pc, #0x8C]
  00028	e1520003	 cmp         r2, r3

; 1441 :         return (FALSE);

  0002c	1a000019	 bne         |$LN6@IsKernelRe|

; 1442 : 
; 1443 :     // A pointer to the ROMHDR structure lives just past the ROM_SIGNATURE (which is a longword value).  Note that
; 1444 :     // this pointer is remapped since it might be a flash address (image destined for flash), but is actually cached
; 1445 :     // in RAM.
; 1446 :     //
; 1447 :     dwCacheAddress = *(LPDWORD) OEMMapMemAddr (dwRegionStart, dwRegionStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG));

  00030	e2841044	 add         r1, r4, #0x44
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          OEMMapMemAddr

; 1448 :     pROMHeader     = (ROMHDR *) OEMMapMemAddr (dwRegionStart, dwCacheAddress + g_dwROMOffset);

  0003c	e59f7070	 ldr         r7, [pc, #0x70]
  00040	e5902000	 ldr         r2, [r0]
  00044	e1a00004	 mov         r0, r4
  00048	e5973000	 ldr         r3, [r7]
  0004c	e0831002	 add         r1, r3, r2
  00050	eb000000	 bl          OEMMapMemAddr

; 1449 : 
; 1450 :     // Make sure sure are some modules in the table of contents.
; 1451 :     //
; 1452 :     if ((dwNumModules = pROMHeader->nummods) == 0)

  00054	e5903010	 ldr         r3, [r0, #0x10]
  00058	e1b06003	 movs        r6, r3

; 1453 :         return (FALSE);

  0005c	0a00000d	 beq         |$LN6@IsKernelRe|

; 1454 : 
; 1455 : 	// Locate the table of contents and search for the kernel executable and the TOC immediately follows the ROMHDR.
; 1456 : 	//
; 1457 :     plTOC = (TOCentry *)(pROMHeader + 1);

  00060	e2805054	 add         r5, r0, #0x54
  00064		 |$LL3@IsKernelRe|

; 1458 : 
; 1459 : 	while(dwNumModules--) {
; 1460 : 		LPBYTE pFileName = OEMMapMemAddr(dwRegionStart, (DWORD)plTOC->lpszFileName + g_dwROMOffset);

  00064	e5952010	 ldr         r2, [r5, #0x10]
  00068	e5973000	 ldr         r3, [r7]
  0006c	e1a00004	 mov         r0, r4
  00070	e2466001	 sub         r6, r6, #1
  00074	e0821003	 add         r1, r2, r3
  00078	eb000000	 bl          OEMMapMemAddr

; 1461 : 		if (!strcmp(pFileName, "nk.exe")) {

  0007c	e59f102c	 ldr         r1, [pc, #0x2C]
  00080	eb000000	 bl          strcmp
  00084	e3500000	 cmp         r0, #0
  00088	0a000005	 beq         |$LN11@IsKernelRe|

; 1463 : 		}
; 1464 : 		++plTOC;

  0008c	e2855020	 add         r5, r5, #0x20
  00090	e3560000	 cmp         r6, #0
  00094	1afffff2	 bne         |$LL3@IsKernelRe|
  00098		 |$LN6@IsKernelRe|

; 1438 :         return(FALSE);

  00098	e3a00000	 mov         r0, #0

; 1465 : 	}
; 1466 : 	return FALSE;
; 1467 : }

  0009c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN11@IsKernelRe|

; 1462 : 			return TRUE;

  000a4	e3a00001	 mov         r0, #1

; 1465 : 	}
; 1466 : 	return FALSE;
; 1467 : }

  000a8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN17@IsKernelRe|
  000b0		 |$LN18@IsKernelRe|
  000b0	00000000	 DCD         |??_C@_06OLEINIPO@nk?4exe?$AA@|
  000b4		 |$LN19@IsKernelRe|
  000b4	00000000	 DCD         |g_dwROMOffset|
  000b8		 |$LN20@IsKernelRe|
  000b8	43454345	 DCD         0x43454345
  000bc		 |$M41284|

			 ENDP  ; |IsKernelRegion|

	EXPORT	|Nib2HexChar|

  00000			 AREA	 |.pdata|, PDATA
|$T41301| DCD	|$LN10@Nib2HexCha|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Nib2HexChar| PROC

; 1472 : {

  00000		 |$LN10@Nib2HexCha|
  00000		 |$M41298|

; 1473 :     if (Nibble < 0x0a) {

  00000	e350000a	 cmp         r0, #0xA
  00004	2a000003	 bcs         |$LN4@Nib2HexCha|

; 1474 : 		return Nibble+'0';

  00008	e2803030	 add         r3, r0, #0x30
  0000c		 |$LN7@Nib2HexCha|
  0000c	e1a00c03	 mov         r0, r3, lsl #24
  00010	e1a00c40	 mov         r0, r0, asr #24

; 1479 :     }
; 1480 : }

  00014	e12fff1e	 bx          lr
  00018		 |$LN4@Nib2HexCha|

; 1475 :     } else if (Nibble < 0x10) {

  00018	e3500010	 cmp         r0, #0x10

; 1476 : 		return Nibble-0x0a+'A';

  0001c	32803037	 addcc       r3, r0, #0x37
  00020	3afffff9	 bcc         |$LN7@Nib2HexCha|

; 1477 :     } else {
; 1478 : 		return '?';

  00024	e3a0003f	 mov         r0, #0x3F

; 1479 :     }
; 1480 : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M41299|

			 ENDP  ; |Nib2HexChar|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EF@CGJFHBCJ@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5This?5image?5was?5s@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EF@DMPBGGIN@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EF@KMGGNDPA@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@| [ DATA ] ; `string'
	EXPORT	|??_C@_02PCIJFNDE@?$AN?6?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_0BI@KDBHNKIE@Downloaded?5?$CFd?5records?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DG@FCKPNIAC@ERROR?3?5Failed?5to?5read?5?4bin?5recor@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EL@FPJHPAOD@ERROR?3?5Signature?5validation?5fail@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DI@HDMNFPHA@ERROR?3?5Failed?5to?5read?5signature?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CK@FKELKNBC@ERROR?3?5Data?5packet?5?$CFd?5corrupted?0@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CK@MHLPBKBP@Reached?5last?5record?5of?5signed?5?4b@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DI@NMKBLNAC@ERROR?3?5Failed?5to?5read?5signed?5pac@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EB@CGKACAF@ERROR?3?5Failed?5to?5read?5random?5see@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@| [ DATA ] ; `string'
	IMPORT	|OEMFinishEraseFlash|
	IMPORT	|OEMContinueEraseFlash|
	IMPORT	|OEMShowProgress|
	IMPORT	|SBL_VerifyPacket|
	IMPORT	|OEMStartEraseFlash|

  03492			 AREA	 |.bss|, NOINIT
|g_rgpbSignature| % 0x80
|g_rgpbSignature| % 0x80

  00000			 AREA	 |.pdata|, PDATA
|$T41533| DCD	|$LN216@DownloadSi|
	DCD	0xc001c402

  00000			 AREA	 |.xdata|, DATA
|$T41529| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@| DCB "Unable t"
	DCB	"o read image start/length", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@| DCB "I"
	DCB	"mageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EF@CGJFHBCJ@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5This?5image?5was?5s@| DCB " "
	DCB	"           *   This image was signed with a valid privat"
	DCB	"e key   *", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EF@DMPBGGIN@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@| DCB " "
	DCB	"           *                                            "
	DCB	"        *", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EF@KMGGNDPA@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@| DCB " "
	DCB	"           *********************************************"
	DCB	"*********", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_02PCIJFNDE@?$AN?6?$AA@| DCB 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@KDBHNKIE@Downloaded?5?$CFd?5records?$AN?6?$AA@| DCB "Downloade"
	DCB	"d %d records", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DG@FCKPNIAC@ERROR?3?5Failed?5to?5read?5?4bin?5recor@| DCB "ERROR:"
	DCB	" Failed to read .bin record header %d, ABORT!", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EL@FPJHPAOD@ERROR?3?5Signature?5validation?5fail@| DCB "ERROR: Si"
	DCB	"gnature validation failed for packet %d with error 0x%x,"
	DCB	" ABORT!", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DI@HDMNFPHA@ERROR?3?5Failed?5to?5read?5signature?5@| DCB "ERROR: "
	DCB	"Failed to read signature for packet %d, ABORT!", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CK@FKELKNBC@ERROR?3?5Data?5packet?5?$CFd?5corrupted?0@| DCB "ERRO"
	DCB	"R: Data packet %d corrupted, ABORT!", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CK@MHLPBKBP@Reached?5last?5record?5of?5signed?5?4b@| DCB "Reached"
	DCB	" last record of signed .bin file", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DI@NMKBLNAC@ERROR?3?5Failed?5to?5read?5signed?5pac@| DCB "ERROR: "
	DCB	"Failed to read signed packet header %d, ABORT!", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@| DCB "rom_offset=0"
	DCB	"x%x.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EB@CGKACAF@ERROR?3?5Failed?5to?5read?5random?5see@| DCB "ERROR: F"
	DCB	"ailed to read random seed at start of signed .bin file", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@| DCB "Inva"
	DCB	"lid flash address/length", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@| DCB "!OEM"
	DCB	"VERIFYMEMORY: Invalid image", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41529|

  00008		 |DownloadSignedBin| PROC

; 489  : {

  00008		 |$LN216@DownloadSi|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd068	 sub         sp, sp, #0x68
  00010		 |$M41530|
  00010	e1a09002	 mov         r9, r2
  00014	e1a0a001	 mov         r10, r1
  00018	e1a0b000	 mov         r11, r0
  0001c	e59f36f0	 ldr         r3, [pc, #0x6F0]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3064	 str         r3, [sp, #0x64]

; 490  :     RegionInfo *pCurDownloadFile;
; 491  :     BOOL        fIsFlash = FALSE;
; 492  :     LPBYTE      lpDest = NULL;
; 493  :     DWORD       dwImageStart, dwImageLength;
; 494  :     DWORD       dwSignedDataLength, dwSigLength;
; 495  :     BYTE        bFlags;
; 496  :     DWORD       dwRecNum = 0;
; 497  :     DWORD       dwRecAddr, dwRecLen, dwRecChk;
; 498  :     DWORD       dwPacketNum = 1;
; 499  :     DWORD       dwChunksRemaining = 0;
; 500  :     DWORD       dwChunkOffset = 0;
; 501  :     HRESULT     hr;
; 502  :     PACKETDATA  packetData;
; 503  : 
; 504  :     g_bBINDownload = TRUE;

  00028	e59f56e0	 ldr         r5, [pc, #0x6E0]
  0002c	e3a03001	 mov         r3, #1

; 505  : 
; 506  : 
; 507  :     if (!OEMReadData (sizeof (DWORD), (LPBYTE) &dwImageStart)   ||
; 508  :         !OEMReadData (sizeof (DWORD), (LPBYTE) &dwImageLength))

  00030	e3a08000	 mov         r8, #0
  00034	e5c53000	 strb        r3, [r5]
  00038	e3a03000	 mov         r3, #0
  0003c	e58d301c	 str         r3, [sp, #0x1C]
  00040	e3a03000	 mov         r3, #0
  00044	e28d1028	 add         r1, sp, #0x28
  00048	e3a00004	 mov         r0, #4
  0004c	e58d3018	 str         r3, [sp, #0x18]
  00050	e3a07001	 mov         r7, #1
  00054	e58d8004	 str         r8, [sp, #4]
  00058	eb000000	 bl          OEMReadData
  0005c	e3500000	 cmp         r0, #0
  00060	0a000187	 beq         |$LN32@DownloadSi|
  00064	e28d102c	 add         r1, sp, #0x2C
  00068	e3a00004	 mov         r0, #4
  0006c	eb000000	 bl          OEMReadData
  00070	e3500000	 cmp         r0, #0
  00074	0a000182	 beq         |$LN32@DownloadSi|

; 512  :         return (FALSE);
; 513  :     }
; 514  : 
; 515  : 
; 516  :     // If Platform Builder didn't provide a manifest (i.e., we're
; 517  :     // only downloading a single .bin file), manufacture a manifest so we
; 518  :     // can notify the OEM.
; 519  :     //
; 520  :     if (!g_DownloadManifest.dwNumRegions)

  00078	e59f668c	 ldr         r6, [pc, #0x68C]

; 521  :     {
; 522  :         g_DownloadManifest.dwNumRegions             = 1;
; 523  :         g_DownloadManifest.Region[0].dwRegionStart  = dwImageStart;
; 524  :         g_DownloadManifest.Region[0].dwRegionLength = dwImageLength;
; 525  :     }
; 526  : 
; 527  :     // Provide the download manifest to the OEM.
; 528  :     //
; 529  :     if (!g_fOEMNotified && g_pOEMMultiBINNotify)

  0007c	e59f4684	 ldr         r4, [pc, #0x684]
  00080	e596e090	 ldr         lr, [r6, #0x90]
  00084	e35e0000	 cmp         lr, #0
  00088	059d3028	 ldreq       r3, [sp, #0x28]
  0008c	03a0e001	 moveq       lr, #1
  00090	059d202c	 ldreq       r2, [sp, #0x2C]
  00094	0586e090	 streq       lr, [r6, #0x90]
  00098	05863094	 streq       r3, [r6, #0x94]
  0009c	e5943000	 ldr         r3, [r4]
  000a0	05862098	 streq       r2, [r6, #0x98]
  000a4	e3530000	 cmp         r3, #0
  000a8	1a000009	 bne         |$LN30@DownloadSi|
  000ac	e59f2650	 ldr         r2, [pc, #0x650]
  000b0	e5923000	 ldr         r3, [r2]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000005	 beq         |$LN30@DownloadSi|

; 530  :     {
; 531  :         g_pOEMMultiBINNotify((PDownloadManifest)&g_DownloadManifest);

  000bc	e2860090	 add         r0, r6, #0x90
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff13	 bx          r3

; 532  :         g_fOEMNotified = TRUE;

  000c8	e3a03001	 mov         r3, #1
  000cc	e596e090	 ldr         lr, [r6, #0x90]
  000d0	e5843000	 str         r3, [r4]
  000d4		 |$LN30@DownloadSi|

; 533  :     }
; 534  : 
; 535  : 
; 536  :     // Locate the current download manifest entry (current download file).
; 537  :     //
; 538  :     pCurDownloadFile = &g_DownloadManifest.Region[g_DownloadManifest.dwNumRegions - g_downloadFilesRemaining];
; 539  : 
; 540  :     // give the OEM a chance to verify memory
; 541  :     if (g_pOEMVerifyMemory && !g_pOEMVerifyMemory (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  000d4	e59f4624	 ldr         r4, [pc, #0x624]
  000d8	e5d53001	 ldrb        r3, [r5, #1]
  000dc	e2861090	 add         r1, r6, #0x90
  000e0	e5940000	 ldr         r0, [r4]
  000e4	e04e2003	 sub         r2, lr, r3
  000e8	e3a0ef43	 mov         lr, #0x43, 30
  000ec	e2813004	 add         r3, r1, #4
  000f0	e3500000	 cmp         r0, #0
  000f4	e0253e92	 mla         r5, r2, lr, r3
  000f8	0a000010	 beq         |$LN29@DownloadSi|
  000fc	e5951004	 ldr         r1, [r5, #4]
  00100	e5950000	 ldr         r0, [r5]
  00104	e5943000	 ldr         r3, [r4]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff13	 bx          r3
  00110	e3500000	 cmp         r0, #0
  00114	1a000009	 bne         |$LN29@DownloadSi|

; 542  :     {
; 543  :         KITLOutputDebugString ("!OEMVERIFYMEMORY: Invalid image\r\n");

  00118	e59f05dc	 ldr         r0, [pc, #0x5DC]
  0011c	eb000000	 bl          KITLOutputDebugString

; 544  :         HALT (BLERR_OEMVERIFY);

  00120	e59f2584	 ldr         r2, [pc, #0x584]
  00124	e5923000	 ldr         r3, [r2]
  00128	e3530000	 cmp         r3, #0
  0012c	13a01000	 movne       r1, #0
  00130	13e00008	 mvnne       r0, #8
  00134	11a0e00f	 movne       lr, pc
  00138	112fff13	 bxne        r3
  0013c		 |$LL46@DownloadSi|
  0013c	eafffffe	 b           |$LL46@DownloadSi|
  00140		 |$LN29@DownloadSi|

; 545  :         return (FALSE);
; 546  :     }
; 547  : 
; 548  : #ifdef DEBUG
; 549  :     // Clearing memory ensures no garbage between sparse .bin records, so that 
; 550  :     // our post-download checksum will be accurate.
; 551  :     memset( (LPVOID) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart),
; 552  :                 0, pCurDownloadFile->dwRegionLength );
; 553  : #endif
; 554  : 
; 555  :     // Check for flash image. Start erasing if it is.
; 556  :     // This is risky iff:
; 557  :     //      We're downloading the bootloader
; 558  :     //      OEM has implemented OEMStartEraseFlash()/OEMContinueEraseFlash()
; 559  :     //      Download fails (e.g. image has been tampered with)
; 560  :     //
; 561  :     // In this scenario only, the device will be unbootable and require
; 562  :     // JTAG recovery.
; 563  :     //
; 564  :     // The OEM should implement the flash functions to skip erase if the image
; 565  :     // is a bootloader (i.e. defer erase until OEMFinishEraseFlash()). 
; 566  :     // That prevents bricking the device.  
; 567  :     //
; 568  :     // It's safe to erase flash and/or flush RAM to flash when download the OS.
; 569  :     // In fact this improves download speed, and lets you download images
; 570  :     // much larger than available RAM.
; 571  :     if ((fIsFlash = OEMIsFlashAddr (pCurDownloadFile->dwRegionStart)) 
; 572  :         && !OEMStartEraseFlash (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  00140	e5950000	 ldr         r0, [r5]
  00144	eb000000	 bl          OEMIsFlashAddr
  00148	e1b04000	 movs        r4, r0
  0014c	e58d4020	 str         r4, [sp, #0x20]
  00150	0a00000e	 beq         |$LN28@DownloadSi|
  00154	e5951004	 ldr         r1, [r5, #4]
  00158	e5950000	 ldr         r0, [r5]
  0015c	eb000000	 bl          OEMStartEraseFlash
  00160	e3500000	 cmp         r0, #0
  00164	1a000009	 bne         |$LN28@DownloadSi|

; 573  :     {
; 574  :         KITLOutputDebugString ("Invalid flash address/length\r\n");

  00168	e59f0588	 ldr         r0, [pc, #0x588]
  0016c	eb000000	 bl          KITLOutputDebugString

; 575  :         HALT (BLERR_FLASHADDR);

  00170	e59f2534	 ldr         r2, [pc, #0x534]
  00174	e5923000	 ldr         r3, [r2]
  00178	e3530000	 cmp         r3, #0
  0017c	13a01000	 movne       r1, #0
  00180	13e00009	 mvnne       r0, #9
  00184	11a0e00f	 movne       lr, pc
  00188	112fff13	 bxne        r3
  0018c		 |$LL51@DownloadSi|
  0018c	eafffffe	 b           |$LL51@DownloadSi|
  00190		 |$LN28@DownloadSi|

; 576  :         return (FALSE);
; 577  :     }
; 578  : 
; 579  :     //------------------------------------------------------------------------
; 580  :     //  Signed files are prefixed with a 16-byte random seed, which
; 581  :     //  is included in the hash.
; 582  :     //------------------------------------------------------------------------
; 583  :     if (!OEMReadData (RANDOM_SEED_LENGTH, (LPBYTE) &packetData.bRandomSeed))

  00190	e28d104c	 add         r1, sp, #0x4C
  00194	e3a00010	 mov         r0, #0x10
  00198	eb000000	 bl          OEMReadData
  0019c	e3500000	 cmp         r0, #0
  001a0	1a000009	 bne         |$LN109@DownloadSi|

; 584  :     {
; 585  :         KITLOutputDebugString ("ERROR: Failed to read random seed at start of signed .bin file\r\n");

  001a4	e59f0548	 ldr         r0, [pc, #0x548]
  001a8	eb000000	 bl          KITLOutputDebugString

; 586  :         HALT (BLERR_MAGIC);

  001ac	e59f24f8	 ldr         r2, [pc, #0x4F8]
  001b0	e5923000	 ldr         r3, [r2]
  001b4	e3530000	 cmp         r3, #0
  001b8	13a01000	 movne       r1, #0
  001bc	13e00007	 mvnne       r0, #7
  001c0	11a0e00f	 movne       lr, pc
  001c4	112fff13	 bxne        r3
  001c8		 |$LL56@DownloadSi|
  001c8	eafffffe	 b           |$LL56@DownloadSi|
  001cc		 |$LN109@DownloadSi|

; 587  :         return (FALSE);
; 588  :     }
; 589  : 
; 590  : 
; 591  :     //------------------------------------------------------------------------
; 592  :     //  Download signed packets (.bin records or record chunks)
; 593  :     //------------------------------------------------------------------------
; 594  : 
; 595  :     while ( OEMReadData (sizeof (DWORD), (LPBYTE) &dwSignedDataLength) &&
; 596  :             OEMReadData (sizeof (DWORD), (LPBYTE) &dwSigLength)        &&
; 597  :             OEMReadData (sizeof (BYTE),  (LPBYTE) &bFlags) )

  001cc	e28d1010	 add         r1, sp, #0x10
  001d0	e3a00004	 mov         r0, #4
  001d4	eb000000	 bl          OEMReadData
  001d8	e3500000	 cmp         r0, #0
  001dc	0a0000de	 beq         |$LN25@DownloadSi|
  001e0		 |$LL26@DownloadSi|
  001e0	e28d1008	 add         r1, sp, #8
  001e4	e3a00004	 mov         r0, #4
  001e8	eb000000	 bl          OEMReadData
  001ec	e3500000	 cmp         r0, #0
  001f0	0a0000d9	 beq         |$LN25@DownloadSi|
  001f4	e28d1000	 add         r1, sp, #0
  001f8	e3a00001	 mov         r0, #1
  001fc	eb000000	 bl          OEMReadData
  00200	e3500000	 cmp         r0, #0
  00204	0a0000d4	 beq         |$LN25@DownloadSi|

; 598  :     {
; 599  : #ifdef DEBUG
; 600  :         KITLOutputDebugString("\r\n------------------------------------------------------------------------------\r\n");
; 601  :         KITLOutputDebugString(" <> Packet [ %d ] dwSignedDataLength = 0x%x, dwSigLen = 0x%x, bFlags = 0x%x\r\n", 
; 602  :             dwPacketNum, dwSignedDataLength, dwSigLength, bFlags);
; 603  : #endif
; 604  : 
; 605  :         // Check if what we just read was a chunk header instead of a
; 606  :         // signed packet header.
; 607  :         //
; 608  :         // If a .bin record is larger than the <packet size> parameter to 
; 609  :         // ImageHash.exe, it will be broken into multiple chunks.
; 610  :         //
; 611  :         // This theoretically allows download of .bin records that are larger
; 612  :         // than the bootloader's available RAM.  However BLCommon doesn't 
; 613  :         // implement that.  The OEM can do it by creatively using 
; 614  :         // OEMMapMemAddr() and OEMContinueEraseFlash() to periodically flush 
; 615  :         // the RAM buffer to flash.
; 616  : 
; 617  :         if (bFlags & SBL_FLAG_CHUNK_HEADER)

  00208	e5dd3000	 ldrb        r3, [sp]
  0020c	e3130004	 tst         r3, #4
  00210	0a00001d	 beq         |$LN211@DownloadSi|

; 618  :         {
; 619  :             // It's a chunk header; we must reinterpret the data we just read:
; 620  :             //
; 621  :             //  field 0: ignore             (always zero for a chunk header)
; 622  :             //  field 1: dwChunksRemaining  (multiple chunks = one .bin record)
; 623  :             //  field 2: bFlags             (no change)
; 624  :             dwChunksRemaining = dwSigLength;
; 625  :             dwChunkOffset     = 0;
; 626  : #ifdef DEBUG
; 627  :             KITLOutputDebugString(" <> Record chunk (dwChunksRemaining = %d)\r\n", dwChunksRemaining);
; 628  : #endif             
; 629  :             
; 630  :             // Read the signed packet header
; 631  :             if ( !(OEMReadData (sizeof (DWORD), (LPBYTE) &dwSignedDataLength) &&
; 632  :                    OEMReadData (sizeof (DWORD), (LPBYTE) &dwSigLength)        &&
; 633  :                    OEMReadData (sizeof (BYTE),  (LPBYTE) &bFlags)))

  00214	e59d4008	 ldr         r4, [sp, #8]
  00218	e3a08000	 mov         r8, #0
  0021c	e28d1010	 add         r1, sp, #0x10
  00220	e3a00004	 mov         r0, #4
  00224	e58d4018	 str         r4, [sp, #0x18]
  00228	e58d8004	 str         r8, [sp, #4]
  0022c	eb000000	 bl          OEMReadData
  00230	e3500000	 cmp         r0, #0
  00234	0a000009	 beq         |$LN22@DownloadSi|
  00238	e28d1008	 add         r1, sp, #8
  0023c	e3a00004	 mov         r0, #4
  00240	eb000000	 bl          OEMReadData
  00244	e3500000	 cmp         r0, #0
  00248	0a000004	 beq         |$LN22@DownloadSi|
  0024c	e28d1000	 add         r1, sp, #0
  00250	e3a00001	 mov         r0, #1
  00254	eb000000	 bl          OEMReadData
  00258	e3500000	 cmp         r0, #0
  0025c	1a00000b	 bne         |$LN23@DownloadSi|
  00260		 |$LN22@DownloadSi|

; 634  :             {
; 635  :                 KITLOutputDebugString ("ERROR: Failed to read signed packet header %d, ABORT!\r\n", dwPacketNum);

  00260	e59f0488	 ldr         r0, [pc, #0x488]
  00264	e1a01007	 mov         r1, r7
  00268	eb000000	 bl          KITLOutputDebugString

; 636  :                 HALT (BLERR_CORRUPTED_DATA);

  0026c	e59f2438	 ldr         r2, [pc, #0x438]
  00270	e5923000	 ldr         r3, [r2]
  00274	e3530000	 cmp         r3, #0
  00278	13a01000	 movne       r1, #0
  0027c	13e00003	 mvnne       r0, #3
  00280	11a0e00f	 movne       lr, pc
  00284	112fff13	 bxne        r3
  00288		 |$LL61@DownloadSi|
  00288	eafffffe	 b           |$LL61@DownloadSi|
  0028c		 |$LN211@DownloadSi|

; 696  :         {
; 697  :             if (--dwChunksRemaining > 0) 

  0028c	e59d4018	 ldr         r4, [sp, #0x18]
  00290		 |$LN23@DownloadSi|

; 637  :                 return (FALSE);
; 638  :             }
; 639  : #ifdef DEBUG
; 640  :             KITLOutputDebugString(" <> Packet [ %d ] dwSignedDataLength = 0x%x, dwSigLen = 0x%x, bFlags = 0x%x\r\n", 
; 641  :                 dwPacketNum, dwSignedDataLength, dwSigLength, bFlags);
; 642  : #endif            
; 643  :         }
; 644  : 
; 645  : 
; 646  :         // Read the .bin record header
; 647  :         if ( !(OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecAddr) &&
; 648  :                OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecLen)  &&
; 649  :                OEMReadData (sizeof (DWORD), (LPBYTE) &dwRecChk)) )

  00290	e28d1014	 add         r1, sp, #0x14
  00294	e3a00004	 mov         r0, #4
  00298	eb000000	 bl          OEMReadData
  0029c	e3500000	 cmp         r0, #0
  002a0	0a0000ba	 beq         |$LN20@DownloadSi|
  002a4	e28d100c	 add         r1, sp, #0xC
  002a8	e3a00004	 mov         r0, #4
  002ac	eb000000	 bl          OEMReadData
  002b0	e3500000	 cmp         r0, #0
  002b4	0a0000b5	 beq         |$LN20@DownloadSi|
  002b8	e28d1024	 add         r1, sp, #0x24
  002bc	e3a00004	 mov         r0, #4
  002c0	eb000000	 bl          OEMReadData
  002c4	e3500000	 cmp         r0, #0
  002c8	0a0000b0	 beq         |$LN20@DownloadSi|

; 653  :             return (FALSE);
; 654  :         }
; 655  : #ifdef DEBUG
; 656  :         KITLOutputDebugString(" <> Record [ %d ] dwRecAddr = 0x%x, dwRecLen = 0x%x, dwRecChk = 0x%x\r\n", 
; 657  :             dwRecNum, dwRecAddr, dwRecLen, dwRecChk);
; 658  : #endif
; 659  : 
; 660  :         if (bFlags & SBL_FLAG_END_FILE)

  002cc	e5dd3000	 ldrb        r3, [sp]
  002d0	e3130002	 tst         r3, #2
  002d4	1a00009a	 bne         |$LN120@DownloadSi|

; 668  :         }
; 669  : 
; 670  :         // map the record address (FLASH data is cached, for example)
; 671  :         // add offset if this is a record chunk
; 672  :         lpDest = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, dwRecAddr + dwChunkOffset);

  002d8	e59d3014	 ldr         r3, [sp, #0x14]
  002dc	e5950000	 ldr         r0, [r5]
  002e0	e0831008	 add         r1, r3, r8
  002e4	eb000000	 bl          OEMMapMemAddr
  002e8	e1a08000	 mov         r8, r0

; 673  : 
; 674  :         // read record (or record chunk)
; 675  :         if (!OEMReadData (dwSignedDataLength, lpDest))

  002ec	e59d0010	 ldr         r0, [sp, #0x10]
  002f0	e1a01008	 mov         r1, r8
  002f4	eb000000	 bl          OEMReadData
  002f8	e3500000	 cmp         r0, #0
  002fc	0a000085	 beq         |$LN121@DownloadSi|

; 679  :             return (FALSE);
; 680  :         }
; 681  : #ifdef DEBUG
; 682  :         else
; 683  :         {
; 684  :             KITLOutputDebugString ("Read 0x%x bytes into cache: 0x%x (final address: 0x%x)\r\n", 
; 685  :                 dwSignedDataLength,
; 686  :                 lpDest,
; 687  :                 dwRecAddr + dwChunkOffset);   
; 688  :                 
; 689  :             DumpMem( lpDest, 64 );                
; 690  :         }
; 691  : #endif
; 692  :         
; 693  :         
; 694  :         // Check for last chunk in a fragmented .bin record
; 695  :         if (0 != dwChunksRemaining) 

  00300	e3540000	 cmp         r4, #0
  00304	0a000009	 beq         |$LN140@DownloadSi|

; 696  :         {
; 697  :             if (--dwChunksRemaining > 0) 

  00308	e2544001	 subs        r4, r4, #1

; 698  :             {
; 699  :                 dwChunkOffset += dwSignedDataLength;

  0030c	159d3010	 ldrne       r3, [sp, #0x10]
  00310	159d2004	 ldrne       r2, [sp, #4]
  00314	e58d4018	 str         r4, [sp, #0x18]
  00318	10822003	 addne       r2, r2, r3

; 700  :             } 
; 701  :             else 
; 702  :             {
; 703  :                 dwChunkOffset = 0;  

  0031c	03a02000	 moveq       r2, #0

; 704  :             }
; 705  : #ifdef DEBUG
; 706  :             KITLOutputDebugString("dwChunksRemaining = %d, offset = 0x%x\r\n", 
; 707  :                 dwChunksRemaining, dwChunkOffset);
; 708  : #endif            
; 709  :         }
; 710  :         
; 711  : 
; 712  :         if (0 == dwChunksRemaining) 

  00320	e3540000	 cmp         r4, #0

; 720  :                 return (FALSE);
; 721  :             }
; 722  : 
; 723  :             dwRecNum++; 

  00324	159de00c	 ldrne       lr, [sp, #0xC]
  00328	e58d2004	 str         r2, [sp, #4]
  0032c	1a000011	 bne         |$LN14@DownloadSi|
  00330		 |$LN140@DownloadSi|

; 713  :         {
; 714  :             LPBYTE cacheAddress = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, dwRecAddr);

  00330	e59d1014	 ldr         r1, [sp, #0x14]
  00334	e5950000	 ldr         r0, [r5]
  00338	eb000000	 bl          OEMMapMemAddr

; 715  :             
; 716  :             // The packet signature makes this redundant, but we check anyway.
; 717  :             if (!VerifyChecksum (dwRecLen, cacheAddress, dwRecChk))

  0033c	e59de00c	 ldr         lr, [sp, #0xC]
  00340	e3a02000	 mov         r2, #0
  00344	e35e0000	 cmp         lr, #0
  00348	0a000004	 beq         |$LN76@DownloadSi|

; 713  :         {
; 714  :             LPBYTE cacheAddress = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, dwRecAddr);

  0034c	e1a0100e	 mov         r1, lr

; 715  :             
; 716  :             // The packet signature makes this redundant, but we check anyway.
; 717  :             if (!VerifyChecksum (dwRecLen, cacheAddress, dwRecChk))

  00350		 |$LL78@DownloadSi|
  00350	e4d03001	 ldrb        r3, [r0], #1
  00354	e2511001	 subs        r1, r1, #1
  00358	e0822003	 add         r2, r2, r3
  0035c	1afffffb	 bne         |$LL78@DownloadSi|
  00360		 |$LN76@DownloadSi|
  00360	e59d1024	 ldr         r1, [sp, #0x24]
  00364	e1520001	 cmp         r2, r1
  00368	1a000060	 bne         |$LN169@DownloadSi|

; 720  :                 return (FALSE);
; 721  :             }
; 722  : 
; 723  :             dwRecNum++; 

  0036c	e59d301c	 ldr         r3, [sp, #0x1C]
  00370	e2833001	 add         r3, r3, #1
  00374	e58d301c	 str         r3, [sp, #0x1C]
  00378		 |$LN14@DownloadSi|

; 724  :         }
; 725  : 
; 726  :         // Look for ROMHDR to compute ROM offset.  NOTE: romimage guarantees that the record containing
; 727  :         // the TOC signature and pointer will always come before the record that contains the ROMHDR contents.
; 728  :         //
; 729  :         if (dwRecLen == sizeof(ROMHDR) && (*(LPDWORD) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE))

  00378	e35e0054	 cmp         lr, #0x54
  0037c	1a00001f	 bne         |$LN11@DownloadSi|
  00380	e5950000	 ldr         r0, [r5]
  00384	e2801040	 add         r1, r0, #0x40
  00388	eb000000	 bl          OEMMapMemAddr
  0038c	e5903000	 ldr         r3, [r0]
  00390	e59f2338	 ldr         r2, [pc, #0x338]
  00394	e1530002	 cmp         r3, r2
  00398	1a000018	 bne         |$LN11@DownloadSi|

; 730  :         {
; 731  :             DWORD dwTempOffset = (dwRecAddr - *(LPDWORD)OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG)));

  0039c	e5950000	 ldr         r0, [r5]
  003a0	e2801044	 add         r1, r0, #0x44
  003a4	eb000000	 bl          OEMMapMemAddr
  003a8	e5901000	 ldr         r1, [r0]
  003ac	e59d3014	 ldr         r3, [sp, #0x14]

; 732  :             ROMHDR *pROMHdr = (ROMHDR *)lpDest;
; 733  : 
; 734  :             // Check to make sure this record really contains the ROMHDR.
; 735  :             //
; 736  :             if ((pROMHdr->physfirst == (pCurDownloadFile->dwRegionStart - dwTempOffset)) &&
; 737  :                 (pROMHdr->physlast  == (pCurDownloadFile->dwRegionStart - dwTempOffset + pCurDownloadFile->dwRegionLength)) &&
; 738  :                 (DWORD)(HIWORD(pROMHdr->dllfirst << 16) <= pROMHdr->dlllast) &&
; 739  :                 (DWORD)(LOWORD(pROMHdr->dllfirst << 16) <= pROMHdr->dlllast))

  003b0	e5950000	 ldr         r0, [r5]
  003b4	e5982008	 ldr         r2, [r8, #8]
  003b8	e043e001	 sub         lr, r3, r1
  003bc	e040300e	 sub         r3, r0, lr
  003c0	e1520003	 cmp         r2, r3
  003c4	1a00000d	 bne         |$LN11@DownloadSi|
  003c8	e5953004	 ldr         r3, [r5, #4]
  003cc	e598200c	 ldr         r2, [r8, #0xC]
  003d0	e043300e	 sub         r3, r3, lr
  003d4	e0833000	 add         r3, r3, r0
  003d8	e1520003	 cmp         r2, r3
  003dc	1a000007	 bne         |$LN11@DownloadSi|
  003e0	e1d830b0	 ldrh        r3, [r8]
  003e4	e5982004	 ldr         r2, [r8, #4]
  003e8	e1530002	 cmp         r3, r2

; 740  :             {
; 741  :                 g_dwROMOffset = dwTempOffset;
; 742  :                 KITLOutputDebugString("rom_offset=0x%x.\r\n", g_dwROMOffset); 

  003ec	959f32f8	 ldrls       r3, [pc, #0x2F8]
  003f0	959f02f0	 ldrls       r0, [pc, #0x2F0]
  003f4	91a0100e	 movls       r1, lr
  003f8	9583e000	 strls       lr, [r3]
  003fc	9b000000	 blls        KITLOutputDebugString
  00400		 |$LN11@DownloadSi|

; 743  :             }
; 744  :         }
; 745  : 
; 746  :         // read packet signature
; 747  :         ASSERT(dwSigLength <= sizeof(g_rgpbSignature));
; 748  :         if (!OEMReadData (dwSigLength, (LPBYTE) &g_rgpbSignature))

  00400	e59d0008	 ldr         r0, [sp, #8]
  00404	e1a01006	 mov         r1, r6
  00408	eb000000	 bl          OEMReadData
  0040c	e3500000	 cmp         r0, #0
  00410	0a00002b	 beq         |$LN123@DownloadSi|

; 752  :             return (FALSE);
; 753  :         }
; 754  :     
; 755  :         //------------------------------------------------------------------------
; 756  :         //  Validate signature for this record or chunk
; 757  :         //------------------------------------------------------------------------
; 758  : 
; 759  :         packetData.pbData       = lpDest;               // data to verify               
; 760  :         packetData.dwDataLength = dwSignedDataLength;   // length of data in bytes              
; 761  :         packetData.pbSig        = g_rgpbSignature;      // signature to verify               
; 762  :         packetData.dwSigLength  = dwSigLength;          // length of signature in bytes                
; 763  :         packetData.dwRecAddress = dwRecAddr;            // record address              

  00414	e59d1014	 ldr         r1, [sp, #0x14]

; 764  :         packetData.dwRecLength  = dwRecLen;             // record length   

  00418	e59d000c	 ldr         r0, [sp, #0xC]
  0041c	e59d3010	 ldr         r3, [sp, #0x10]
  00420	e59d2008	 ldr         r2, [sp, #8]

; 765  :         packetData.dwRecCheck   = dwRecChk;             // record checksum  

  00424	e59de024	 ldr         lr, [sp, #0x24]

; 766  :         packetData.dwSequenceNumber = dwPacketNum;      // packet sequence number           
; 767  :         packetData.bFlags       = bFlags;               // Flags

  00428	e5dd4000	 ldrb        r4, [sp]
  0042c	e58d1040	 str         r1, [sp, #0x40]
  00430	e58d0044	 str         r0, [sp, #0x44]

; 768  : 
; 769  :         PrintPacketData( packetData );
; 770  : 
; 771  :         hr = SBL_VerifyPacket( &packetData, &g_keyData );

  00434	e2861080	 add         r1, r6, #0x80
  00438	e28d0030	 add         r0, sp, #0x30
  0043c	e58d3034	 str         r3, [sp, #0x34]
  00440	e58d203c	 str         r2, [sp, #0x3C]
  00444	e58de048	 str         lr, [sp, #0x48]
  00448	e5cd4060	 strb        r4, [sp, #0x60]
  0044c	e58d8030	 str         r8, [sp, #0x30]
  00450	e58d6038	 str         r6, [sp, #0x38]
  00454	e58d705c	 str         r7, [sp, #0x5C]
  00458	eb000000	 bl          SBL_VerifyPacket
  0045c	e1b02000	 movs        r2, r0

; 772  : 
; 773  :         if (FAILED(hr)) {

  00460	4a00000c	 bmi         |$LN124@DownloadSi|

; 776  :             return (FALSE);
; 777  :         }
; 778  :         
; 779  :         OEMShowProgress (dwPacketNum++);

  00464	e1a00007	 mov         r0, r7
  00468	eb000000	 bl          OEMShowProgress

; 780  : 
; 781  :         if (fIsFlash)

  0046c	e59d4020	 ldr         r4, [sp, #0x20]
  00470	e2877001	 add         r7, r7, #1
  00474	e3540000	 cmp         r4, #0

; 782  :         {
; 783  :             OEMContinueEraseFlash ();

  00478	1b000000	 blne        OEMContinueEraseFlash
  0047c	e28d1010	 add         r1, sp, #0x10
  00480	e3a00004	 mov         r0, #4
  00484	eb000000	 bl          OEMReadData
  00488	e3500000	 cmp         r0, #0
  0048c	0a000032	 beq         |$LN25@DownloadSi|

; 587  :         return (FALSE);
; 588  :     }
; 589  : 
; 590  : 
; 591  :     //------------------------------------------------------------------------
; 592  :     //  Download signed packets (.bin records or record chunks)
; 593  :     //------------------------------------------------------------------------
; 594  : 
; 595  :     while ( OEMReadData (sizeof (DWORD), (LPBYTE) &dwSignedDataLength) &&
; 596  :             OEMReadData (sizeof (DWORD), (LPBYTE) &dwSigLength)        &&
; 597  :             OEMReadData (sizeof (BYTE),  (LPBYTE) &bFlags) )

  00490	e59d8004	 ldr         r8, [sp, #4]
  00494	eaffff51	 b           |$LL26@DownloadSi|
  00498		 |$LN124@DownloadSi|

; 774  :             KITLOutputDebugString("ERROR: Signature validation failed for packet %d with error 0x%x, ABORT!\r\n", dwPacketNum, hr);

  00498	e59f0244	 ldr         r0, [pc, #0x244]
  0049c	e1a01007	 mov         r1, r7
  004a0	eb000000	 bl          KITLOutputDebugString

; 775  :             HALT (BLERR_SIGNATURE);

  004a4	e59f2200	 ldr         r2, [pc, #0x200]
  004a8	e5923000	 ldr         r3, [r2]
  004ac	e3530000	 cmp         r3, #0
  004b0	13a01000	 movne       r1, #0
  004b4	13e00004	 mvnne       r0, #4
  004b8	11a0e00f	 movne       lr, pc
  004bc	112fff13	 bxne        r3
  004c0		 |$LL96@DownloadSi|
  004c0	eafffffe	 b           |$LL96@DownloadSi|
  004c4		 |$LN123@DownloadSi|

; 749  :         {
; 750  :             KITLOutputDebugString ("ERROR: Failed to read signature for packet %d, ABORT!\r\n", dwPacketNum);

  004c4	e59f0214	 ldr         r0, [pc, #0x214]
  004c8	e1a01007	 mov         r1, r7
  004cc	eb000000	 bl          KITLOutputDebugString

; 751  :             HALT (BLERR_SIGNATURE);

  004d0	e59f21d4	 ldr         r2, [pc, #0x1D4]
  004d4	e5923000	 ldr         r3, [r2]
  004d8	e3530000	 cmp         r3, #0
  004dc	13a01000	 movne       r1, #0
  004e0	13e00004	 mvnne       r0, #4
  004e4	11a0e00f	 movne       lr, pc
  004e8	112fff13	 bxne        r3
  004ec		 |$LL89@DownloadSi|
  004ec	eafffffe	 b           |$LL89@DownloadSi|
  004f0		 |$LN169@DownloadSi|

; 715  :             
; 716  :             // The packet signature makes this redundant, but we check anyway.
; 717  :             if (!VerifyChecksum (dwRecLen, cacheAddress, dwRecChk))

  004f0	e59f01e4	 ldr         r0, [pc, #0x1E4]
  004f4	eb000000	 bl          KITLOutputDebugString

; 718  :             {
; 719  :                 HALT (BLERR_CHECKSUM);

  004f8	e59f21ac	 ldr         r2, [pc, #0x1AC]
  004fc	e5923000	 ldr         r3, [r2]
  00500	e3530000	 cmp         r3, #0
  00504	13a01000	 movne       r1, #0
  00508	13e00006	 mvnne       r0, #6
  0050c	11a0e00f	 movne       lr, pc
  00510	112fff13	 bxne        r3
  00514		 |$LL84@DownloadSi|
  00514	eafffffe	 b           |$LL84@DownloadSi|
  00518		 |$LN121@DownloadSi|

; 676  :         {
; 677  :             KITLOutputDebugString ("ERROR: Data packet %d corrupted, ABORT!\r\n", dwPacketNum);

  00518	e59f01b8	 ldr         r0, [pc, #0x1B8]
  0051c	e1a01007	 mov         r1, r7
  00520	eb000000	 bl          KITLOutputDebugString

; 678  :             HALT (BLERR_CORRUPTED_DATA);

  00524	e59f2180	 ldr         r2, [pc, #0x180]
  00528	e5923000	 ldr         r3, [r2]
  0052c	e3530000	 cmp         r3, #0
  00530	13a01000	 movne       r1, #0
  00534	13e00003	 mvnne       r0, #3
  00538	11a0e00f	 movne       lr, pc
  0053c	112fff13	 bxne        r3
  00540		 |$LL71@DownloadSi|
  00540	eafffffe	 b           |$LL71@DownloadSi|
  00544		 |$LN120@DownloadSi|

; 661  :         {
; 662  :             // last packet always has unused signature block, read it!
; 663  :             ASSERT(dwSignedDataLength == 0);
; 664  :             ASSERT(dwSigLength <= sizeof(g_rgpbSignature));
; 665  :             OEMReadData(dwSigLength, (LPBYTE) &g_rgpbSignature);

  00544	e59d0008	 ldr         r0, [sp, #8]
  00548	e1a01006	 mov         r1, r6
  0054c	eb000000	 bl          OEMReadData

; 666  :             KITLOutputDebugString("Reached last record of signed .bin file\r\n");

  00550	e59f017c	 ldr         r0, [pc, #0x17C]
  00554	eb000000	 bl          KITLOutputDebugString

; 667  :             break;

  00558	e59d4020	 ldr         r4, [sp, #0x20]
  0055c		 |$LN25@DownloadSi|

; 784  :         }
; 785  :     }  // while( signed packets remaining )
; 786  :     
; 787  : 
; 788  :     //------------------------------------------------------------------------
; 789  :     //  Determine the image entry point
; 790  :     //------------------------------------------------------------------------
; 791  : 
; 792  :     // Does this .bin file contain a TOC?
; 793  :     if (*(LPDWORD) OEMMapMemAddr(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE)

  0055c	e5950000	 ldr         r0, [r5]
  00560	e2801040	 add         r1, r0, #0x40
  00564	eb000000	 bl          OEMMapMemAddr
  00568	e5903000	 ldr         r3, [r0]
  0056c	e59f215c	 ldr         r2, [pc, #0x15C]
  00570	e1530002	 cmp         r3, r2
  00574	1a000010	 bne         |$LN7@DownloadSi|

; 794  :     {
; 795  :         // Contain the kernel?
; 796  :         if (IsKernelRegion(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  00578	e5951004	 ldr         r1, [r5, #4]
  0057c	e5950000	 ldr         r0, [r5]
  00580	eb000000	 bl          IsKernelRegion
  00584	e3500000	 cmp         r0, #0
  00588	0a000014	 beq         |$LN4@DownloadSi|

; 797  :         {
; 798  :             *pdwImageStart  = pCurDownloadFile->dwRegionStart;
; 799  :             *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 800  :             *pdwLaunchAddr  = dwRecLen;
; 801  :         }

  0058c	ea00000d	 b           |$LN213@DownloadSi|
  00590		 |$LN20@DownloadSi|

; 650  :         {
; 651  :             KITLOutputDebugString ("ERROR: Failed to read .bin record header %d, ABORT!\r\n", dwPacketNum);

  00590	e59f0134	 ldr         r0, [pc, #0x134]
  00594	e1a01007	 mov         r1, r7
  00598	eb000000	 bl          KITLOutputDebugString

; 652  :             HALT (BLERR_CORRUPTED_DATA);

  0059c	e59f2108	 ldr         r2, [pc, #0x108]
  005a0	e5923000	 ldr         r3, [r2]
  005a4	e3530000	 cmp         r3, #0
  005a8	13a01000	 movne       r1, #0
  005ac	13e00003	 mvnne       r0, #3
  005b0	11a0e00f	 movne       lr, pc
  005b4	112fff13	 bxne        r3
  005b8		 |$LL66@DownloadSi|
  005b8	eafffffe	 b           |$LL66@DownloadSi|
  005bc		 |$LN7@DownloadSi|

; 802  :     }
; 803  :     // No TOC - not made by romimage.  
; 804  :     else if (g_DownloadManifest.dwNumRegions == 1)

  005bc	e5963090	 ldr         r3, [r6, #0x90]
  005c0	e3530001	 cmp         r3, #1
  005c4	1a000005	 bne         |$LN4@DownloadSi|
  005c8		 |$LN213@DownloadSi|

; 805  :     {
; 806  :         *pdwImageStart  = pCurDownloadFile->dwRegionStart;

  005c8	e5953000	 ldr         r3, [r5]

; 807  :         *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 808  :         *pdwLaunchAddr  = dwRecLen;

  005cc	e59d200c	 ldr         r2, [sp, #0xC]
  005d0	e58b3000	 str         r3, [r11]
  005d4	e5953004	 ldr         r3, [r5, #4]
  005d8	e58a3000	 str         r3, [r10]
  005dc	e5892000	 str         r2, [r9]
  005e0		 |$LN4@DownloadSi|

; 809  :     }
; 810  :     else
; 811  :     {
; 812  :         // If we're downloading more than one .bin file, it's probably 
; 813  :         // chain.bin which doesn't have a TOC (and which isn't
; 814  :         // going to be downloaded on its own) and we should ignore it.
; 815  :     }
; 816  : 
; 817  : 
; 818  :     KITLOutputDebugString("\r\n");

  005e0	e59f00d4	 ldr         r0, [pc, #0xD4]
  005e4	eb000000	 bl          KITLOutputDebugString

; 819  :     KITLOutputDebugString("            ******************************************************\r\n");

  005e8	e59f00d0	 ldr         r0, [pc, #0xD0]
  005ec	eb000000	 bl          KITLOutputDebugString

; 820  :     KITLOutputDebugString("            *                                                    *\r\n");

  005f0	e59f00cc	 ldr         r0, [pc, #0xCC]
  005f4	eb000000	 bl          KITLOutputDebugString

; 821  :     KITLOutputDebugString("            *   This image was signed with a valid private key   *\r\n");

  005f8	e59f00c8	 ldr         r0, [pc, #0xC8]
  005fc	eb000000	 bl          KITLOutputDebugString

; 822  :     KITLOutputDebugString("            *                                                    *\r\n");

  00600	e59f00bc	 ldr         r0, [pc, #0xBC]
  00604	eb000000	 bl          KITLOutputDebugString

; 823  :     KITLOutputDebugString("            ******************************************************\r\n");

  00608	e59f00b0	 ldr         r0, [pc, #0xB0]
  0060c	eb000000	 bl          KITLOutputDebugString

; 824  :     KITLOutputDebugString("\r\n");

  00610	e59f00a4	 ldr         r0, [pc, #0xA4]
  00614	eb000000	 bl          KITLOutputDebugString

; 825  : 
; 826  :     KITLOutputDebugString("Downloaded %d records\r\n", dwRecNum);

  00618	e59f0098	 ldr         r0, [pc, #0x98]
  0061c	e59d101c	 ldr         r1, [sp, #0x1C]
  00620	eb000000	 bl          KITLOutputDebugString

; 827  : 
; 828  :     if (fIsFlash)

  00624	e3540000	 cmp         r4, #0
  00628	0a00000a	 beq         |$LN1@DownloadSi|

; 829  :     {
; 830  :         // finish the flash erase
; 831  :         if (!OEMFinishEraseFlash())

  0062c	eb000000	 bl          OEMFinishEraseFlash
  00630	e3500000	 cmp         r0, #0
  00634	1a000007	 bne         |$LN1@DownloadSi|

; 832  :         {
; 833  :             HALT (BLERR_FLASH_ERASE);

  00638	e59f206c	 ldr         r2, [pc, #0x6C]
  0063c	e5923000	 ldr         r3, [r2]
  00640	e3530000	 cmp         r3, #0
  00644	13a01000	 movne       r1, #0
  00648	13e0000a	 mvnne       r0, #0xA
  0064c	11a0e00f	 movne       lr, pc
  00650	112fff13	 bxne        r3
  00654		 |$LL101@DownloadSi|
  00654	eafffffe	 b           |$LL101@DownloadSi|
  00658		 |$LN1@DownloadSi|

; 834  :             return (FALSE);
; 835  :         }
; 836  : 
; 837  :     }
; 838  : 
; 839  :     KITLOutputDebugString("ImageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x\r\n",
; 840  :         *pdwImageStart, *pdwImageLength, *pdwLaunchAddr);

  00658	e5993000	 ldr         r3, [r9]
  0065c	e59a2000	 ldr         r2, [r10]
  00660	e59b1000	 ldr         r1, [r11]
  00664	e59f0048	 ldr         r0, [pc, #0x48]
  00668	eb000000	 bl          KITLOutputDebugString

; 841  : 
; 842  : 
; 843  :     return TRUE;

  0066c	e59d0064	 ldr         r0, [sp, #0x64]
  00670	eb000000	 bl          __security_check_cookie
  00674	e3a00001	 mov         r0, #1

; 844  : }

  00678	e28dd068	 add         sp, sp, #0x68
  0067c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00680	e12fff1e	 bx          lr
  00684		 |$LN32@DownloadSi|

; 509  :     {
; 510  :         KITLOutputDebugString ("Unable to read image start/length\r\n");

  00684	e59f0024	 ldr         r0, [pc, #0x24]
  00688	eb000000	 bl          KITLOutputDebugString

; 511  :         HALT (BLERR_MAGIC);

  0068c	e59f2018	 ldr         r2, [pc, #0x18]
  00690	e5923000	 ldr         r3, [r2]
  00694	e3530000	 cmp         r3, #0
  00698	13a01000	 movne       r1, #0
  0069c	13e00007	 mvnne       r0, #7
  006a0	11a0e00f	 movne       lr, pc
  006a4	112fff13	 bxne        r3
  006a8		 |$LL41@DownloadSi|
  006a8	eafffffe	 b           |$LL41@DownloadSi|
  006ac		 |$LN217@DownloadSi|
  006ac		 |$LN218@DownloadSi|
  006ac	00000000	 DCD         |g_pOEMReportError|
  006b0		 |$LN219@DownloadSi|
  006b0	00000000	 DCD         |??_C@_0CE@NKAMCDHO@Unable?5to?5read?5image?5start?1lengt@|
  006b4		 |$LN220@DownloadSi|
  006b4	00000000	 DCD         |??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@|
  006b8		 |$LN221@DownloadSi|
  006b8	00000000	 DCD         |??_C@_0BI@KDBHNKIE@Downloaded?5?$CFd?5records?$AN?6?$AA@|
  006bc		 |$LN222@DownloadSi|
  006bc	00000000	 DCD         |??_C@_02PCIJFNDE@?$AN?6?$AA@|
  006c0		 |$LN223@DownloadSi|
  006c0	00000000	 DCD         |??_C@_0EF@KMGGNDPA@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@|
  006c4		 |$LN224@DownloadSi|
  006c4	00000000	 DCD         |??_C@_0EF@DMPBGGIN@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@|
  006c8		 |$LN225@DownloadSi|
  006c8	00000000	 DCD         |??_C@_0EF@CGJFHBCJ@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5This?5image?5was?5s@|
  006cc		 |$LN226@DownloadSi|
  006cc	00000000	 DCD         |??_C@_0DG@FCKPNIAC@ERROR?3?5Failed?5to?5read?5?4bin?5recor@|
  006d0		 |$LN227@DownloadSi|
  006d0	43454345	 DCD         0x43454345
  006d4		 |$LN228@DownloadSi|
  006d4	00000000	 DCD         |??_C@_0CK@MHLPBKBP@Reached?5last?5record?5of?5signed?5?4b@|
  006d8		 |$LN229@DownloadSi|
  006d8	00000000	 DCD         |??_C@_0CK@FKELKNBC@ERROR?3?5Data?5packet?5?$CFd?5corrupted?0@|
  006dc		 |$LN230@DownloadSi|
  006dc	00000000	 DCD         |??_C@_0DJ@LFHEGALA@ERROR?3?5Checksum?5failure?5?$CIexpecte@|
  006e0		 |$LN231@DownloadSi|
  006e0	00000000	 DCD         |??_C@_0DI@HDMNFPHA@ERROR?3?5Failed?5to?5read?5signature?5@|
  006e4		 |$LN232@DownloadSi|
  006e4	00000000	 DCD         |??_C@_0EL@FPJHPAOD@ERROR?3?5Signature?5validation?5fail@|
  006e8		 |$LN233@DownloadSi|
  006e8	00000000	 DCD         |??_C@_0BD@PHLGNLDI@rom_offset?$DN0x?$CFx?4?$AN?6?$AA@|
  006ec		 |$LN234@DownloadSi|
  006ec	00000000	 DCD         |g_dwROMOffset|
  006f0		 |$LN235@DownloadSi|
  006f0	00000000	 DCD         |??_C@_0DI@NMKBLNAC@ERROR?3?5Failed?5to?5read?5signed?5pac@|
  006f4		 |$LN236@DownloadSi|
  006f4	00000000	 DCD         |??_C@_0EB@CGKACAF@ERROR?3?5Failed?5to?5read?5random?5see@|
  006f8		 |$LN237@DownloadSi|
  006f8	00000000	 DCD         |??_C@_0BP@EOFEMPOO@Invalid?5flash?5address?1length?$AN?6?$AA@|
  006fc		 |$LN238@DownloadSi|
  006fc	00000000	 DCD         |??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@|
  00700		 |$LN239@DownloadSi|
  00700	00000000	 DCD         |g_pOEMVerifyMemory|
  00704		 |$LN240@DownloadSi|
  00704	00000000	 DCD         |g_pOEMMultiBINNotify|
  00708		 |$LN241@DownloadSi|
  00708	00000000	 DCD         |g_fOEMNotified|
  0070c		 |$LN242@DownloadSi|
  0070c	00000000	 DCD         |g_rgpbSignature|
  00710		 |$LN243@DownloadSi|
  00710	00000000	 DCD         |g_bBINDownload|
  00714		 |$LN244@DownloadSi|
  00714	00000000	 DCD         |__security_cookie|
  00718		 |$M41531|

			 ENDP  ; |DownloadSignedBin|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_0DJ@KBLPDGCA@Invalid?5flash?5address?1length?5or?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EJ@PDNPMPAK@Image?5size?5after?5stripping?5signe@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CB@EOPJODDD@ERROR?3?5bad?5bFlags?50x?$CFx?0?5ABORT?$CB?$AN?6@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DO@DKOHJKOF@ERROR?3?5Didn?8t?5find?5random?5seed?5a@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41672| DCD	|$LN94@DownloadSi@2|
	DCD	0xc0010702

  00000			 AREA	 |.xdata|, DATA
|$T41668| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DJ@KBLPDGCA@Invalid?5flash?5address?1length?5or?5@| DCB "Invalid "
	DCB	"flash address/length or flash operation failed", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EJ@PDNPMPAK@Image?5size?5after?5stripping?5signe@| DCB "Image siz"
	DCB	"e after stripping signed headers/footers for %d packets:"
	DCB	" 0x%x", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@| DCB "ERROR: "
	DCB	"failed when reading raw binary file.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CB@EOPJODDD@ERROR?3?5bad?5bFlags?50x?$CFx?0?5ABORT?$CB?$AN?6@| DCB "E"
	DCB	"RROR: bad bFlags 0x%x, ABORT!", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DO@DKOHJKOF@ERROR?3?5Didn?8t?5find?5random?5seed?5a@| DCB "ERROR:"
	DCB	" Didn't find random seed at start of signed .nb0 file", 0xd
	DCB	0xa, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41668|

  00008		 |DownloadSignedNB0| PROC

; 851  : {

  00008		 |$LN94@DownloadSi@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd044	 sub         sp, sp, #0x44
  00010		 |$M41669|
  00010	e1a08002	 mov         r8, r2
  00014	e1a0a001	 mov         r10, r1
  00018	e1a09000	 mov         r9, r0
  0001c	e59f33fc	 ldr         r3, [pc, #0x3FC]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3040	 str         r3, [sp, #0x40]

; 852  :     RegionInfo *pCurDownloadFile;
; 853  :     LPBYTE      lpDest = NULL;
; 854  :     DWORD       dwPacketNum = 1;
; 855  :     DWORD       dwSignedDataLength, dwSigLength;
; 856  :     BYTE        bFlags;
; 857  :     PACKETDATA  packetData;
; 858  :     HRESULT     hr;
; 859  :             
; 860  :     g_bBINDownload = FALSE;
; 861  :     
; 862  : 
; 863  :     // Provide the download manifest to the OEM.  This gives the OEM the
; 864  :     // opportunity to provide start addresses for the .nb0 files (which 
; 865  :     // don't contain placement information like .bin files do).
; 866  :     if (!g_fOEMNotified && g_pOEMMultiBINNotify)

  00028	e59f53ec	 ldr         r5, [pc, #0x3EC]
  0002c	e59f73e4	 ldr         r7, [pc, #0x3E4]
  00030	e3a02000	 mov         r2, #0
  00034	e5953000	 ldr         r3, [r5]
  00038	e59f43d4	 ldr         r4, [pc, #0x3D4]
  0003c	e3a06001	 mov         r6, #1
  00040	e3530000	 cmp         r3, #0
  00044	e5c72000	 strb        r2, [r7]
  00048	1a000008	 bne         |$LN14@DownloadSi@2|
  0004c	e59fe3bc	 ldr         lr, [pc, #0x3BC]
  00050	e59e3000	 ldr         r3, [lr]
  00054	e3530000	 cmp         r3, #0
  00058	0a000004	 beq         |$LN14@DownloadSi@2|

; 867  :     {
; 868  :         g_pOEMMultiBINNotify((PDownloadManifest)&g_DownloadManifest);

  0005c	e2840090	 add         r0, r4, #0x90
  00060	e1a0e00f	 mov         lr, pc
  00064	e12fff13	 bx          r3

; 869  :         g_fOEMNotified = TRUE;

  00068	e3a03001	 mov         r3, #1
  0006c	e5853000	 str         r3, [r5]
  00070		 |$LN14@DownloadSi@2|

; 870  :     }
; 871  : 
; 872  :     // Locate the current download manifest entry (current download file).
; 873  :     //
; 874  :     pCurDownloadFile = &g_DownloadManifest.Region[g_DownloadManifest.dwNumRegions - g_downloadFilesRemaining];
; 875  : 
; 876  :     // give the OEM a chance to verify memory
; 877  :     if (g_pOEMVerifyMemory && !g_pOEMVerifyMemory (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength))

  00070	e59fe394	 ldr         lr, [pc, #0x394]
  00074	e5940090	 ldr         r0, [r4, #0x90]
  00078	e5d72001	 ldrb        r2, [r7, #1]
  0007c	e59e1000	 ldr         r1, [lr]
  00080	e2843090	 add         r3, r4, #0x90
  00084	e0402002	 sub         r2, r0, r2
  00088	e3a00f43	 mov         r0, #0x43, 30
  0008c	e2833004	 add         r3, r3, #4
  00090	e3510000	 cmp         r1, #0
  00094	e0253092	 mla         r5, r2, r0, r3
  00098	0a000010	 beq         |$LN13@DownloadSi@2|
  0009c	e5951004	 ldr         r1, [r5, #4]
  000a0	e5950000	 ldr         r0, [r5]
  000a4	e59e3000	 ldr         r3, [lr]
  000a8	e1a0e00f	 mov         lr, pc
  000ac	e12fff13	 bx          r3
  000b0	e3500000	 cmp         r0, #0
  000b4	1a000009	 bne         |$LN13@DownloadSi@2|

; 878  :     {
; 879  :         KITLOutputDebugString ("!OEMVERIFYMEMORY: Invalid image\r\n");

  000b8	e59f0348	 ldr         r0, [pc, #0x348]
  000bc	eb000000	 bl          KITLOutputDebugString

; 880  :         HALT (BLERR_OEMVERIFY);

  000c0	e59f230c	 ldr         r2, [pc, #0x30C]
  000c4	e5923000	 ldr         r3, [r2]
  000c8	e3530000	 cmp         r3, #0
  000cc	13a01000	 movne       r1, #0
  000d0	13e00008	 mvnne       r0, #8
  000d4	11a0e00f	 movne       lr, pc
  000d8	112fff13	 bxne        r3
  000dc		 |$LL18@DownloadSi@2|
  000dc	eafffffe	 b           |$LL18@DownloadSi@2|
  000e0		 |$LN13@DownloadSi@2|

; 881  :         return (FALSE);
; 882  :     }
; 883  : 
; 884  : 
; 885  :     //------------------------------------------------------------------------
; 886  :     //  Signed files are prefixed with a 16-byte random seed, which
; 887  :     //  is included in the hash.
; 888  :     //------------------------------------------------------------------------
; 889  : 
; 890  :     if (!OEMReadData (RANDOM_SEED_LENGTH, (LPBYTE) &packetData.bRandomSeed))

  000e0	e28d1028	 add         r1, sp, #0x28
  000e4	e3a00010	 mov         r0, #0x10
  000e8	eb000000	 bl          OEMReadData
  000ec	e3500000	 cmp         r0, #0
  000f0	1a000009	 bne         |$LN12@DownloadSi@2|

; 891  :     {
; 892  :         KITLOutputDebugString ("ERROR: Didn't find random seed at start of signed .nb0 file\r\n");

  000f4	e59f0308	 ldr         r0, [pc, #0x308]
  000f8	eb000000	 bl          KITLOutputDebugString

; 893  :         HALT (BLERR_MAGIC);

  000fc	e59f22d0	 ldr         r2, [pc, #0x2D0]
  00100	e5923000	 ldr         r3, [r2]
  00104	e3530000	 cmp         r3, #0
  00108	13a01000	 movne       r1, #0
  0010c	13e00007	 mvnne       r0, #7
  00110	11a0e00f	 movne       lr, pc
  00114	112fff13	 bxne        r3
  00118		 |$LL23@DownloadSi@2|
  00118	eafffffe	 b           |$LL23@DownloadSi@2|
  0011c		 |$LN12@DownloadSi@2|

; 894  :         return (FALSE);
; 895  :     } else {
; 896  : #ifdef DEBUG
; 897  :         int i;
; 898  :         KITLOutputDebugString("\r\nSigned file random seed = ");
; 899  :         for (i = 0; i < RANDOM_SEED_LENGTH; i++) {
; 900  :             KITLOutputDebugString("%x ", packetData.bRandomSeed[i]);   
; 901  :         }
; 902  :         KITLOutputDebugString("\r\n\r\n");
; 903  : #endif        
; 904  :     }
; 905  : 
; 906  : 
; 907  :     //------------------------------------------------------------------------
; 908  :     //  Download signed packets of raw data (.nb0)
; 909  :     //------------------------------------------------------------------------
; 910  : 
; 911  :     lpDest = OEMMapMemAddr (pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionStart);

  0011c	e5950000	 ldr         r0, [r5]
  00120	e1a01000	 mov         r1, r0
  00124	eb000000	 bl          OEMMapMemAddr
  00128	e1a07000	 mov         r7, r0

; 912  : 
; 913  :     while ( OEMReadData (sizeof (DWORD), (LPBYTE) &dwSignedDataLength) &&
; 914  :             OEMReadData (sizeof (DWORD), (LPBYTE) &dwSigLength)        &&
; 915  :             OEMReadData (sizeof (BYTE),  (LPBYTE) &bFlags) )

  0012c	e3a00004	 mov         r0, #4
  00130	e28d1004	 add         r1, sp, #4
  00134	eb000000	 bl          OEMReadData
  00138	e3500000	 cmp         r0, #0
  0013c	0a000064	 beq         |$LN9@DownloadSi@2|
  00140	e3a0b000	 mov         r11, #0
  00144		 |$LL10@DownloadSi@2|
  00144	e28d1008	 add         r1, sp, #8
  00148	e3a00004	 mov         r0, #4
  0014c	eb000000	 bl          OEMReadData
  00150	e3500000	 cmp         r0, #0
  00154	0a00005e	 beq         |$LN9@DownloadSi@2|
  00158	e28d1000	 add         r1, sp, #0
  0015c	e3a00001	 mov         r0, #1
  00160	eb000000	 bl          OEMReadData
  00164	e3500000	 cmp         r0, #0
  00168	0a000059	 beq         |$LN9@DownloadSi@2|

; 916  :     {
; 917  : #ifdef DEBUG
; 918  :         KITLOutputDebugString("\r\n------------------------------------------------------------------------------\r\n");
; 919  :         KITLOutputDebugString(" <> Packet [ %d ] dwDataLen = 0x%x, dwSigLen = 0x%x, bFlags = 0x%x\r\n", 
; 920  :             dwPacketNum, dwSignedDataLength, dwSigLength, bFlags);
; 921  : #endif
; 922  : 
; 923  :         // check bFlags
; 924  :         if (bFlags & SBL_FLAG_END_FILE) 

  0016c	e5dd1000	 ldrb        r1, [sp]
  00170	e3110002	 tst         r1, #2
  00174	1a000053	 bne         |$LN62@DownloadSi@2|

; 930  :             break;
; 931  :         } 
; 932  :         else if (!(bFlags & SBL_FLAG_NORMAL)) 

  00178	e3110001	 tst         r1, #1
  0017c	0a000047	 beq         |$LN63@DownloadSi@2|

; 936  :             return (FALSE);
; 937  :         }
; 938  :         
; 939  :         // read packet data
; 940  :         if (!OEMReadData (dwSignedDataLength, lpDest))

  00180	e59d0004	 ldr         r0, [sp, #4]
  00184	e1a01007	 mov         r1, r7
  00188	eb000000	 bl          OEMReadData
  0018c	e3500000	 cmp         r0, #0
  00190	0a000038	 beq         |$LN64@DownloadSi@2|

; 944  :             return (FALSE);
; 945  :         }
; 946  :         
; 947  :         // read packet signature
; 948  :         ASSERT(dwSigLength <= sizeof(g_rgpbSignature));
; 949  :         if (!OEMReadData (dwSigLength, (LPBYTE) &g_rgpbSignature))

  00194	e59d0008	 ldr         r0, [sp, #8]
  00198	e1a01004	 mov         r1, r4
  0019c	eb000000	 bl          OEMReadData
  001a0	e3500000	 cmp         r0, #0
  001a4	0a000028	 beq         |$LN65@DownloadSi@2|

; 953  :             return (FALSE);
; 954  :         }
; 955  :     
; 956  :         //------------------------------------------------------------------------
; 957  :         //  Validate the signature for this packet
; 958  :         //------------------------------------------------------------------------
; 959  : 
; 960  :         packetData.pbData       = lpDest;               // data to verify               
; 961  :         packetData.dwDataLength = dwSignedDataLength;   // length of data in bytes              

  001a8	e59d3004	 ldr         r3, [sp, #4]

; 962  :         packetData.pbSig        = g_rgpbSignature;      // signature to verify               
; 963  :         packetData.dwSigLength  = dwSigLength;          // length of signature in bytes                
; 964  :         packetData.dwRecAddress = 0;                    // record address              
; 965  :         packetData.dwRecLength  = 0;                    // record length   
; 966  :         packetData.dwRecCheck   = 0;                    // record checksum  
; 967  :         packetData.dwSequenceNumber = dwPacketNum;      // packet sequence number           
; 968  :         packetData.bFlags       = bFlags;               // Flags

  001ac	e5dd1000	 ldrb        r1, [sp]
  001b0	e59d2008	 ldr         r2, [sp, #8]
  001b4	e58d3010	 str         r3, [sp, #0x10]

; 969  : 
; 970  :         PrintPacketData( packetData );
; 971  : 
; 972  :         hr = SBL_VerifyPacket( &packetData, &g_keyData );

  001b8	e3a03000	 mov         r3, #0
  001bc	e58d3020	 str         r3, [sp, #0x20]
  001c0	e3a03000	 mov         r3, #0
  001c4	e5cd103c	 strb        r1, [sp, #0x3C]
  001c8	e2841080	 add         r1, r4, #0x80
  001cc	e28d000c	 add         r0, sp, #0xC
  001d0	e58d3024	 str         r3, [sp, #0x24]
  001d4	e58d2018	 str         r2, [sp, #0x18]
  001d8	e58d700c	 str         r7, [sp, #0xC]
  001dc	e58d4014	 str         r4, [sp, #0x14]
  001e0	e58db01c	 str         r11, [sp, #0x1C]
  001e4	e58d6038	 str         r6, [sp, #0x38]
  001e8	eb000000	 bl          SBL_VerifyPacket
  001ec	e1b02000	 movs        r2, r0

; 973  : 
; 974  :         if (FAILED(hr)) {

  001f0	4a00000a	 bmi         |$LN66@DownloadSi@2|

; 977  :             return (FALSE);
; 978  :         }
; 979  : 
; 980  :         lpDest += dwSignedDataLength;

  001f4	e59d3004	 ldr         r3, [sp, #4]

; 981  :         
; 982  :         OEMShowProgress (dwPacketNum++);

  001f8	e1a00006	 mov         r0, r6
  001fc	e0877003	 add         r7, r7, r3
  00200	eb000000	 bl          OEMShowProgress
  00204	e28d1004	 add         r1, sp, #4
  00208	e3a00004	 mov         r0, #4
  0020c	e2866001	 add         r6, r6, #1
  00210	eb000000	 bl          OEMReadData
  00214	e3500000	 cmp         r0, #0
  00218	1affffc9	 bne         |$LL10@DownloadSi@2|

; 973  : 
; 974  :         if (FAILED(hr)) {

  0021c	ea00002c	 b           |$LN9@DownloadSi@2|
  00220		 |$LN66@DownloadSi@2|

; 975  :             KITLOutputDebugString("ERROR: Signature validation failed for packet %d with error 0x%x, ABORT!\r\n", dwPacketNum, hr);

  00220	e59f01d8	 ldr         r0, [pc, #0x1D8]
  00224	e1a01006	 mov         r1, r6
  00228	eb000000	 bl          KITLOutputDebugString

; 976  :             HALT (BLERR_SIGNATURE);

  0022c	e59f21a0	 ldr         r2, [pc, #0x1A0]
  00230	e5923000	 ldr         r3, [r2]
  00234	e3530000	 cmp         r3, #0
  00238	13a01000	 movne       r1, #0
  0023c	13e00004	 mvnne       r0, #4
  00240	11a0e00f	 movne       lr, pc
  00244	112fff13	 bxne        r3
  00248		 |$LL45@DownloadSi@2|
  00248	eafffffe	 b           |$LL45@DownloadSi@2|
  0024c		 |$LN65@DownloadSi@2|

; 950  :         {
; 951  :             KITLOutputDebugString ("ERROR: Failed to read signature for packet %d, ABORT!\r\n", dwPacketNum);

  0024c	e59f01a8	 ldr         r0, [pc, #0x1A8]
  00250	e1a01006	 mov         r1, r6
  00254	eb000000	 bl          KITLOutputDebugString

; 952  :             HALT (BLERR_SIGNATURE);

  00258	e59f2174	 ldr         r2, [pc, #0x174]
  0025c	e5923000	 ldr         r3, [r2]
  00260	e3530000	 cmp         r3, #0
  00264	13a01000	 movne       r1, #0
  00268	13e00004	 mvnne       r0, #4
  0026c	11a0e00f	 movne       lr, pc
  00270	112fff13	 bxne        r3
  00274		 |$LL38@DownloadSi@2|
  00274	eafffffe	 b           |$LL38@DownloadSi@2|
  00278		 |$LN64@DownloadSi@2|

; 941  :         {
; 942  :             KITLOutputDebugString ("ERROR: failed when reading raw binary file.\r\n");

  00278	e59f0178	 ldr         r0, [pc, #0x178]
  0027c	eb000000	 bl          KITLOutputDebugString

; 943  :             HALT (BLERR_CORRUPTED_DATA);

  00280	e59f214c	 ldr         r2, [pc, #0x14C]
  00284	e5923000	 ldr         r3, [r2]
  00288	e3530000	 cmp         r3, #0
  0028c	13a01000	 movne       r1, #0
  00290	13e00003	 mvnne       r0, #3
  00294	11a0e00f	 movne       lr, pc
  00298	112fff13	 bxne        r3
  0029c		 |$LL33@DownloadSi@2|
  0029c	eafffffe	 b           |$LL33@DownloadSi@2|
  002a0		 |$LN63@DownloadSi@2|

; 933  :         {
; 934  :             KITLOutputDebugString("ERROR: bad bFlags 0x%x, ABORT!\r\n", bFlags);

  002a0	e59f014c	 ldr         r0, [pc, #0x14C]
  002a4	eb000000	 bl          KITLOutputDebugString

; 935  :             HALT (BLERR_CORRUPTED_DATA);

  002a8	e59f2124	 ldr         r2, [pc, #0x124]
  002ac	e5923000	 ldr         r3, [r2]
  002b0	e3530000	 cmp         r3, #0
  002b4	13a01000	 movne       r1, #0
  002b8	13e00003	 mvnne       r0, #3
  002bc	11a0e00f	 movne       lr, pc
  002c0	112fff13	 bxne        r3
  002c4		 |$LL28@DownloadSi@2|
  002c4	eafffffe	 b           |$LL28@DownloadSi@2|
  002c8		 |$LN62@DownloadSi@2|

; 925  :         {
; 926  :             // last packet always has unused signature block, read it!
; 927  :             ASSERT(dwSignedDataLength == 0);
; 928  :             ASSERT(dwSigLength <= sizeof(g_rgpbSignature));
; 929  :             OEMReadData (dwSigLength, (LPBYTE) &g_rgpbSignature);

  002c8	e59d0008	 ldr         r0, [sp, #8]
  002cc	e1a01004	 mov         r1, r4
  002d0	eb000000	 bl          OEMReadData
  002d4		 |$LN9@DownloadSi@2|

; 983  : 
; 984  :     } // end while(packets remaining)
; 985  : 
; 986  : 
; 987  :     KITLOutputDebugString("\r\n");

  002d4	e59f0108	 ldr         r0, [pc, #0x108]
  002d8	eb000000	 bl          KITLOutputDebugString

; 988  :     KITLOutputDebugString("            ******************************************************\r\n");

  002dc	e59f0104	 ldr         r0, [pc, #0x104]
  002e0	eb000000	 bl          KITLOutputDebugString

; 989  :     KITLOutputDebugString("            *                                                    *\r\n");

  002e4	e59f0100	 ldr         r0, [pc, #0x100]
  002e8	eb000000	 bl          KITLOutputDebugString

; 990  :     KITLOutputDebugString("            *   This image was signed with a valid private key   *\r\n");

  002ec	e59f00fc	 ldr         r0, [pc, #0xFC]
  002f0	eb000000	 bl          KITLOutputDebugString

; 991  :     KITLOutputDebugString("            *                                                    *\r\n");

  002f4	e59f00f0	 ldr         r0, [pc, #0xF0]
  002f8	eb000000	 bl          KITLOutputDebugString

; 992  :     KITLOutputDebugString("            ******************************************************\r\n");

  002fc	e59f00e4	 ldr         r0, [pc, #0xE4]
  00300	eb000000	 bl          KITLOutputDebugString

; 993  :     KITLOutputDebugString("\r\n");

  00304	e59f00d8	 ldr         r0, [pc, #0xD8]
  00308	eb000000	 bl          KITLOutputDebugString

; 994  : 
; 995  :     //------------------------------------------------------------------------
; 996  :     // PB sends the file size for .nb0 files (headers and all).
; 997  :     // Subtract the overhead of headers/footers; this is the true image size.
; 998  :     //------------------------------------------------------------------------
; 999  : 
; 1000 :     pCurDownloadFile->dwRegionLength -= BL_HDRSIG_SIZE;
; 1001 :     pCurDownloadFile->dwRegionLength -= RANDOM_SEED_LENGTH;
; 1002 :     pCurDownloadFile->dwRegionLength -= (dwPacketNum) * SBL_PACKET_HEADER_SIZE;
; 1003 :     pCurDownloadFile->dwRegionLength -= (dwPacketNum) * dwSigLength;

  0030c	e59d3008	 ldr         r3, [sp, #8]

; 1004 : 
; 1005 :     KITLOutputDebugString("Image size after stripping signed headers/footers for %d packets: 0x%x\r\n",
; 1006 :         dwPacketNum,
; 1007 :         pCurDownloadFile->dwRegionLength);

  00310	e59f00c8	 ldr         r0, [pc, #0xC8]
  00314	e1a01006	 mov         r1, r6
  00318	e2833009	 add         r3, r3, #9
  0031c	e0020693	 mul         r2, r3, r6
  00320	e5953004	 ldr         r3, [r5, #4]
  00324	e0433002	 sub         r3, r3, r2
  00328	e2433017	 sub         r3, r3, #0x17
  0032c	e1a02003	 mov         r2, r3
  00330	e5853004	 str         r3, [r5, #4]
  00334	eb000000	 bl          KITLOutputDebugString

; 1008 : 
; 1009 : 
; 1010 :     //------------------------------------------------------------------------
; 1011 :     //  Determine the image entry point
; 1012 :     //------------------------------------------------------------------------
; 1013 : 
; 1014 :     *pdwImageStart  = pCurDownloadFile->dwRegionStart;

  00338	e5953000	 ldr         r3, [r5]

; 1015 :     *pdwLaunchAddr  = pCurDownloadFile->dwRegionStart;
; 1016 :     *pdwImageLength = pCurDownloadFile->dwRegionLength;
; 1017 : 
; 1018 :     KITLOutputDebugString("ImageStart = 0x%x, ImageLength = 0x%x, LaunchAddr = 0x%x\r\n",
; 1019 :         *pdwImageStart, *pdwImageLength, *pdwLaunchAddr);

  0033c	e59f0098	 ldr         r0, [pc, #0x98]
  00340	e5893000	 str         r3, [r9]
  00344	e5953000	 ldr         r3, [r5]
  00348	e5883000	 str         r3, [r8]
  0034c	e5952004	 ldr         r2, [r5, #4]
  00350	e58a2000	 str         r2, [r10]
  00354	e5983000	 ldr         r3, [r8]
  00358	e5991000	 ldr         r1, [r9]
  0035c	eb000000	 bl          KITLOutputDebugString

; 1020 : 
; 1021 : 
; 1022 :     //------------------------------------------------------------------------
; 1023 :     // If this is a flash image, erase flash.
; 1024 :     // For signed images, we don't do this until the entire image has been
; 1025 :     // validated.
; 1026 :     //------------------------------------------------------------------------
; 1027 :     if (OEMIsFlashAddr(pCurDownloadFile->dwRegionStart))

  00360	e5950000	 ldr         r0, [r5]
  00364	eb000000	 bl          OEMIsFlashAddr
  00368	e3500000	 cmp         r0, #0
  0036c	0a000012	 beq         |$LN1@DownloadSi@2|

; 1028 :     {
; 1029 :         BOOL rval = TRUE;
; 1030 : 
; 1031 :         rval &= OEMStartEraseFlash(pCurDownloadFile->dwRegionStart, pCurDownloadFile->dwRegionLength);

  00370	e5951004	 ldr         r1, [r5, #4]
  00374	e5950000	 ldr         r0, [r5]
  00378	eb000000	 bl          OEMStartEraseFlash
  0037c	e1a04000	 mov         r4, r0

; 1032 :                 OEMContinueEraseFlash();

  00380	eb000000	 bl          OEMContinueEraseFlash

; 1033 :         rval &= OEMFinishEraseFlash();

  00384	eb000000	 bl          OEMFinishEraseFlash
  00388	e0003004	 and         r3, r0, r4

; 1034 : 
; 1035 :         if (!rval)

  0038c	e3130001	 tst         r3, #1
  00390	1a000009	 bne         |$LN1@DownloadSi@2|

; 1036 :         {
; 1037 :             KITLOutputDebugString ("Invalid flash address/length or flash operation failed\r\n");

  00394	e59f003c	 ldr         r0, [pc, #0x3C]
  00398	eb000000	 bl          KITLOutputDebugString

; 1038 :             HALT (BLERR_FLASHADDR);

  0039c	e59f2030	 ldr         r2, [pc, #0x30]
  003a0	e5923000	 ldr         r3, [r2]
  003a4	e3530000	 cmp         r3, #0
  003a8	13a01000	 movne       r1, #0
  003ac	13e00009	 mvnne       r0, #9
  003b0	11a0e00f	 movne       lr, pc
  003b4	112fff13	 bxne        r3
  003b8		 |$LL50@DownloadSi@2|
  003b8	eafffffe	 b           |$LL50@DownloadSi@2|
  003bc		 |$LN1@DownloadSi@2|

; 1039 :             return (FALSE);
; 1040 :         }
; 1041 :     }
; 1042 :     
; 1043 :     return TRUE;

  003bc	e59d0040	 ldr         r0, [sp, #0x40]
  003c0	eb000000	 bl          __security_check_cookie
  003c4	e3a00001	 mov         r0, #1

; 1044 : }

  003c8	e28dd044	 add         sp, sp, #0x44
  003cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003d0	e12fff1e	 bx          lr
  003d4		 |$LN95@DownloadSi@2|
  003d4		 |$LN96@DownloadSi@2|
  003d4	00000000	 DCD         |g_pOEMReportError|
  003d8		 |$LN97@DownloadSi@2|
  003d8	00000000	 DCD         |??_C@_0DJ@KBLPDGCA@Invalid?5flash?5address?1length?5or?5@|
  003dc		 |$LN98@DownloadSi@2|
  003dc	00000000	 DCD         |??_C@_0DL@DCHMDHHD@ImageStart?5?$DN?50x?$CFx?0?5ImageLength?5?$DN@|
  003e0		 |$LN99@DownloadSi@2|
  003e0	00000000	 DCD         |??_C@_0EJ@PDNPMPAK@Image?5size?5after?5stripping?5signe@|
  003e4		 |$LN100@DownloadSi@2|
  003e4	00000000	 DCD         |??_C@_02PCIJFNDE@?$AN?6?$AA@|
  003e8		 |$LN101@DownloadSi@2|
  003e8	00000000	 DCD         |??_C@_0EF@KMGGNDPA@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@|
  003ec		 |$LN102@DownloadSi@2|
  003ec	00000000	 DCD         |??_C@_0EF@DMPBGGIN@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@|
  003f0		 |$LN103@DownloadSi@2|
  003f0	00000000	 DCD         |??_C@_0EF@CGJFHBCJ@?5?5?5?5?5?5?5?5?5?5?5?5?$CK?5?5?5This?5image?5was?5s@|
  003f4		 |$LN104@DownloadSi@2|
  003f4	00000000	 DCD         |??_C@_0CB@EOPJODDD@ERROR?3?5bad?5bFlags?50x?$CFx?0?5ABORT?$CB?$AN?6@|
  003f8		 |$LN105@DownloadSi@2|
  003f8	00000000	 DCD         |??_C@_0CO@PFLGIDFG@ERROR?3?5failed?5when?5reading?5raw?5b@|
  003fc		 |$LN106@DownloadSi@2|
  003fc	00000000	 DCD         |??_C@_0DI@HDMNFPHA@ERROR?3?5Failed?5to?5read?5signature?5@|
  00400		 |$LN107@DownloadSi@2|
  00400	00000000	 DCD         |??_C@_0EL@FPJHPAOD@ERROR?3?5Signature?5validation?5fail@|
  00404		 |$LN108@DownloadSi@2|
  00404	00000000	 DCD         |??_C@_0DO@DKOHJKOF@ERROR?3?5Didn?8t?5find?5random?5seed?5a@|
  00408		 |$LN109@DownloadSi@2|
  00408	00000000	 DCD         |??_C@_0CC@DNECAMLM@?$CBOEMVERIFYMEMORY?3?5Invalid?5image?$AN@|
  0040c		 |$LN110@DownloadSi@2|
  0040c	00000000	 DCD         |g_pOEMVerifyMemory|
  00410		 |$LN111@DownloadSi@2|
  00410	00000000	 DCD         |g_pOEMMultiBINNotify|
  00414		 |$LN112@DownloadSi@2|
  00414	00000000	 DCD         |g_rgpbSignature|
  00418		 |$LN113@DownloadSi@2|
  00418	00000000	 DCD         |g_bBINDownload|
  0041c		 |$LN114@DownloadSi@2|
  0041c	00000000	 DCD         |g_fOEMNotified|
  00420		 |$LN115@DownloadSi@2|
  00420	00000000	 DCD         |__security_cookie|
  00424		 |$M41670|

			 ENDP  ; |DownloadSignedNB0|

	EXPORT	|??_C@_0EE@IODHDMIJ@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@| [ DATA ] ; `string'
	EXPORT	|??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@| [ DATA ] ; `string'
	EXPORT	|??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DO@LEKCKELG@?$CK?$CK?5ERROR?3?5Unrecognized?5image?5typ@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DP@EIBIBKOO@?$CK?$CK?5?5?5?5?5?5?5?5This?5boot?5loader?5does?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EA@GKNACHAG@?$CK?$CK?5?5?5?5?5?5?5?5Image?5must?5be?5signed?5w@| [ DATA ] ; `string'
	EXPORT	|??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41758| DCD	|$LN63@DownloadIm|
	DCD	0x40008b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EE@IODHDMIJ@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@| DCB "*"
	DCB	"* ERROR: This boot loader does not support unsigned .bin"
	DCB	" images.", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@| DCB "*"
	DCB	"* ERROR: The X000FF packet is an old-style multi-bin dow"
	DCB	"nload manifest and it's no longer supported.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@| DCB "**"
	DCB	" Please update your Platform Builder installation in you"
	DCB	" want to download multiple files.", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@| DCB 0xd, 0xa, "**", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DO@LEKCKELG@?$CK?$CK?5ERROR?3?5Unrecognized?5image?5typ@| DCB "**"
	DCB	" ERROR: Unrecognized image type (possibly unsigned .nb0)"
	DCB	".", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DP@EIBIBKOO@?$CK?$CK?5?5?5?5?5?5?5?5This?5boot?5loader?5does?5@| DCB "*"
	DCB	"*        This boot loader does not support unsigned imag"
	DCB	"es.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EA@GKNACHAG@?$CK?$CK?5?5?5?5?5?5?5?5Image?5must?5be?5signed?5w@| DCB "*"
	DCB	"*        Image must be signed with a recognized private "
	DCB	"key.", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@| DCB "**", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DownloadImage| PROC

; 360  : {

  00000		 |$LN63@DownloadIm|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M41755|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a08000	 mov         r8, r0

; 361  :     BOOL        rval = TRUE;
; 362  :     DWORD       dwImageType;
; 363  : 
; 364  :     *pdwImageStart = *pdwImageLength = *pdwLaunchAddr = 0;
; 365  : 
; 366  : #ifdef SECURE_BOOTLOADER
; 367  :     InitSecureBootLoader();

  00010	e59f3210	 ldr         r3, [pc, #0x210]
  00014	e3a02000	 mov         r2, #0
  00018	e5862000	 str         r2, [r6]
  0001c	e5872000	 str         r2, [r7]
  00020	e5882000	 str         r2, [r8]
  00024	e1d310b0	 ldrh        r1, [r3]
  00028	e59f31f4	 ldr         r3, [pc, #0x1F4]
  0002c	e59f91ec	 ldr         r9, [pc, #0x1EC]
  00030	e59fe1e4	 ldr         lr, [pc, #0x1E4]
  00034	e59f01dc	 ldr         r0, [pc, #0x1DC]
  00038	e2814cff	 add         r4, r1, #0xFF, 24
  0003c	e8894008	 stmia       r9, {r3, lr}
  00040	e3a02000	 mov         r2, #0
  00044	e28430ff	 add         r3, r4, #0xFF
  00048	e3a04001	 mov         r4, #1
  0004c	e1c910b8	 strh        r1, [r9, #8]
  00050	e1c920ba	 strh        r2, [r9, #0xA]
  00054	e1c930bc	 strh        r3, [r9, #0xC]
  00058	eb000000	 bl          KITLOutputDebugString
  0005c	e59f51b0	 ldr         r5, [pc, #0x1B0]
  00060		 |$LL13@DownloadIm|

; 368  : #endif
; 369  : 
; 370  : 
; 371  :     //
; 372  :     // Download each region (multiple can be sent)
; 373  :     //
; 374  :     do
; 375  :     {
; 376  :         dwImageType = GetImageType();

  00060	eb000000	 bl          GetImageType
  00064	e3500000	 cmp         r0, #0

; 377  :         
; 378  :         switch(dwImageType) 

  00068	0a000011	 beq         |$LN8@DownloadIm|
  0006c	e3500001	 cmp         r0, #1
  00070	0a000046	 beq         |$LN6@DownloadIm|
  00074	e3500003	 cmp         r0, #3
  00078	0a000007	 beq         |$LN5@DownloadIm|
  0007c	e3500004	 cmp         r0, #4
  00080	1a00001a	 bne         |$LN45@DownloadIm|

; 405  : 
; 406  :             case BL_IMAGE_TYPE_SIGNED_NB0:
; 407  :                 rval &= DownloadSignedNB0( pdwImageStart, pdwImageLength, pdwLaunchAddr );

  00084	e1a02006	 mov         r2, r6
  00088	e1a01007	 mov         r1, r7
  0008c	e1a00008	 mov         r0, r8
  00090	eb000000	 bl          DownloadSignedNB0
  00094	e0004004	 and         r4, r0, r4
  00098	ea00000b	 b           |$LN12@DownloadIm|
  0009c		 |$LN5@DownloadIm|

; 400  :                 return (FALSE);
; 401  : 
; 402  :             case BL_IMAGE_TYPE_SIGNED_BIN:
; 403  :                 rval &= DownloadSignedBin( pdwImageStart, pdwImageLength, pdwLaunchAddr );

  0009c	e1a02006	 mov         r2, r6
  000a0	e1a01007	 mov         r1, r7
  000a4	e1a00008	 mov         r0, r8
  000a8	eb000000	 bl          DownloadSignedBin
  000ac	e0004004	 and         r4, r0, r4

; 404  :                 break;

  000b0	ea000005	 b           |$LN12@DownloadIm|
  000b4		 |$LN8@DownloadIm|

; 379  :         {
; 380  :             case BL_IMAGE_TYPE_MANIFEST:
; 381  :                 // Platform Builder sends a manifest to indicate the following 
; 382  :                 // data consists of multiple .bin files /OR/ one .nb0 file.
; 383  :                 if (!CheckImageManifest()) {

  000b4	eb000000	 bl          CheckImageManifest
  000b8	e3500000	 cmp         r0, #0
  000bc	0a000043	 beq         |$LN47@DownloadIm|

; 385  :                     return (FALSE);   
; 386  :                 }
; 387  : 
; 388  :                 // Continue with download of next file
; 389  :                 // +1 to account for the manifest
; 390  :                 g_downloadFilesRemaining = (BYTE)(g_DownloadManifest.dwNumRegions + 1);

  000c0	e5993010	 ldr         r3, [r9, #0x10]
  000c4	e2833001	 add         r3, r3, #1
  000c8	e5c53000	 strb        r3, [r5]
  000cc		 |$LN12@DownloadIm|

; 408  :                 break;

  000cc	e5d53000	 ldrb        r3, [r5]

; 457  :                 
; 458  :         }
; 459  :     }
; 460  :     while (--g_downloadFilesRemaining);

  000d0	e28330ff	 add         r3, r3, #0xFF
  000d4	e21330ff	 ands        r3, r3, #0xFF
  000d8	e5c53000	 strb        r3, [r5]
  000dc	1affffdf	 bne         |$LL13@DownloadIm|

; 461  : 
; 462  :     ComputeChecksum();
; 463  :     rval &= WriteImageToFlash();

  000e0	eb000000	 bl          WriteImageToFlash
  000e4	e0000004	 and         r0, r0, r4

; 464  : 
; 465  :     return rval;
; 466  : }

  000e8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN45@DownloadIm|

; 377  :         
; 378  :         switch(dwImageType) 

  000f0	e3500005	 cmp         r0, #5
  000f4	0a000015	 beq         |$LN3@DownloadIm|
  000f8	e3500006	 cmp         r0, #6

; 447  :                 return (FALSE);
; 448  : #else
; 449  :                 // Assume files without a "type" header (e.g. raw data) are unsigned .nb0
; 450  :                 rval &= DownloadNB0( pdwImageStart, pdwImageLength, pdwLaunchAddr );
; 451  :                 break;
; 452  : #endif                
; 453  : 
; 454  :             default:
; 455  :                 // should never get here
; 456  :                 return (FALSE);

  000fc	13a00000	 movne       r0, #0

; 464  : 
; 465  :     return rval;
; 466  : }

  00100	18bd43f0	 ldmneia     sp!, {r4 - r9, lr}
  00104	112fff1e	 bxne        lr

; 437  :                 return (FALSE);
; 438  : 
; 439  :             case BL_IMAGE_TYPE_UNKNOWN:
; 440  : #ifdef SECURE_BOOTLOADER
; 441  :                 KITLOutputDebugString("\r\n**\r\n");

  00108	e59f00f0	 ldr         r0, [pc, #0xF0]
  0010c	eb000000	 bl          KITLOutputDebugString

; 442  :                 KITLOutputDebugString("** ERROR: Unrecognized image type (possibly unsigned .nb0).\r\n");

  00110	e59f00f8	 ldr         r0, [pc, #0xF8]
  00114	eb000000	 bl          KITLOutputDebugString

; 443  :                 KITLOutputDebugString("**        This boot loader does not support unsigned images.\r\n");

  00118	e59f00ec	 ldr         r0, [pc, #0xEC]
  0011c	eb000000	 bl          KITLOutputDebugString

; 444  :                 KITLOutputDebugString("**        Image must be signed with a recognized private key.\r\n");

  00120	e59f00d0	 ldr         r0, [pc, #0xD0]
  00124	eb000000	 bl          KITLOutputDebugString

; 445  :                 KITLOutputDebugString("**\r\n");

  00128	e59f00c4	 ldr         r0, [pc, #0xC4]
  0012c	eb000000	 bl          KITLOutputDebugString

; 446  :                 HALT (BLERR_MAGIC);

  00130	e59f20b8	 ldr         r2, [pc, #0xB8]
  00134	e5923000	 ldr         r3, [r2]
  00138	e3530000	 cmp         r3, #0
  0013c	13a01000	 movne       r1, #0
  00140	13e00007	 mvnne       r0, #7
  00144	11a0e00f	 movne       lr, pc
  00148	112fff13	 bxne        r3
  0014c		 |$LL34@DownloadIm|
  0014c	eafffffe	 b           |$LL34@DownloadIm|
  00150		 |$LN3@DownloadIm|

; 409  : 
; 410  : #else // not SECURE_BOOTLOADER
; 411  : 
; 412  :             case BL_IMAGE_TYPE_BIN:
; 413  :                 rval &= DownloadBin( pdwImageStart, pdwImageLength, pdwLaunchAddr );
; 414  :                 break;
; 415  : 
; 416  :             case BL_IMAGE_TYPE_SIGNED_BIN:
; 417  :                 KITLOutputDebugString("\r\n**\r\n");
; 418  :                 KITLOutputDebugString("** ERROR: This boot loader does not support signed .bin images.\r\n");
; 419  :                 KITLOutputDebugString("**\r\n");
; 420  :                 HALT (BLERR_SIGNATURE);
; 421  :                 return (FALSE);
; 422  : 
; 423  :             case BL_IMAGE_TYPE_SIGNED_NB0:
; 424  :                 KITLOutputDebugString("\r\n**\r\n");
; 425  :                 KITLOutputDebugString("** ERROR: This boot loader does not support signed .nb0 images.\r\n");
; 426  :                 KITLOutputDebugString("**\r\n");
; 427  :                 HALT (BLERR_SIGNATURE);
; 428  :                 return (FALSE);
; 429  : #endif // SECURE_BOOTLOADER
; 430  : 
; 431  :             case BL_IMAGE_TYPE_MULTIXIP:
; 432  :                 KITLOutputDebugString("\r\n**\r\n");

  00150	e59f00a8	 ldr         r0, [pc, #0xA8]
  00154	eb000000	 bl          KITLOutputDebugString

; 433  :                 KITLOutputDebugString("** ERROR: The X000FF packet is an old-style multi-bin download manifest and it's no longer supported.\r\n");

  00158	e59f00a8	 ldr         r0, [pc, #0xA8]
  0015c	eb000000	 bl          KITLOutputDebugString

; 434  :                 KITLOutputDebugString("** Please update your Platform Builder installation in you want to download multiple files.\r\n");

  00160	e59f009c	 ldr         r0, [pc, #0x9C]
  00164	eb000000	 bl          KITLOutputDebugString

; 435  :                 KITLOutputDebugString("**\r\n");

  00168	e59f0084	 ldr         r0, [pc, #0x84]
  0016c	eb000000	 bl          KITLOutputDebugString

; 436  :                 HALT (BLERR_MAGIC);

  00170	e59f2078	 ldr         r2, [pc, #0x78]
  00174	e5923000	 ldr         r3, [r2]
  00178	e3530000	 cmp         r3, #0
  0017c	13a01000	 movne       r1, #0
  00180	13e00007	 mvnne       r0, #7
  00184	11a0e00f	 movne       lr, pc
  00188	112fff13	 bxne        r3
  0018c		 |$LL29@DownloadIm|
  0018c	eafffffe	 b           |$LL29@DownloadIm|
  00190		 |$LN6@DownloadIm|

; 391  :                 continue;
; 392  : 
; 393  : #ifdef SECURE_BOOTLOADER
; 394  :             case BL_IMAGE_TYPE_BIN:
; 395  :                 KITLOutputDebugString("\r\n**\r\n");

  00190	e59f0068	 ldr         r0, [pc, #0x68]
  00194	eb000000	 bl          KITLOutputDebugString

; 396  :                 KITLOutputDebugString("** ERROR: This boot loader does not support unsigned .bin images.\r\n");

  00198	e59f005c	 ldr         r0, [pc, #0x5C]
  0019c	eb000000	 bl          KITLOutputDebugString

; 397  :                 KITLOutputDebugString("**        Image must be signed with a recognized private key.\r\n");

  001a0	e59f0050	 ldr         r0, [pc, #0x50]
  001a4	eb000000	 bl          KITLOutputDebugString

; 398  :                 KITLOutputDebugString("**\r\n");

  001a8	e59f0044	 ldr         r0, [pc, #0x44]
  001ac	eb000000	 bl          KITLOutputDebugString

; 399  :                 HALT (BLERR_SIGNATURE);

  001b0	e59f2038	 ldr         r2, [pc, #0x38]
  001b4	e5923000	 ldr         r3, [r2]
  001b8	e3530000	 cmp         r3, #0
  001bc	13a01000	 movne       r1, #0
  001c0	13e00004	 mvnne       r0, #4
  001c4	11a0e00f	 movne       lr, pc
  001c8	112fff13	 bxne        r3
  001cc		 |$LL24@DownloadIm|
  001cc	eafffffe	 b           |$LL24@DownloadIm|
  001d0		 |$LN47@DownloadIm|

; 384  :                     HALT (BLERR_MAGIC);

  001d0	e59f2018	 ldr         r2, [pc, #0x18]
  001d4	e5923000	 ldr         r3, [r2]
  001d8	e3530000	 cmp         r3, #0
  001dc	13a01000	 movne       r1, #0
  001e0	13e00007	 mvnne       r0, #7
  001e4	11a0e00f	 movne       lr, pc
  001e8	112fff13	 bxne        r3
  001ec		 |$LL19@DownloadIm|
  001ec	eafffffe	 b           |$LL19@DownloadIm|
  001f0		 |$LN64@DownloadIm|
  001f0		 |$LN65@DownloadIm|
  001f0	00000000	 DCD         |g_pOEMReportError|
  001f4		 |$LN66@DownloadIm|
  001f4	00000000	 DCD         |??_C@_04IPBEALME@?$CK?$CK?$AN?6?$AA@|
  001f8		 |$LN67@DownloadIm|
  001f8	00000000	 DCD         |??_C@_0EA@GKNACHAG@?$CK?$CK?5?5?5?5?5?5?5?5Image?5must?5be?5signed?5w@|
  001fc		 |$LN68@DownloadIm|
  001fc	00000000	 DCD         |??_C@_0EE@IODHDMIJ@?$CK?$CK?5ERROR?3?5This?5boot?5loader?5does?5@|
  00200		 |$LN69@DownloadIm|
  00200	00000000	 DCD         |??_C@_06BEBGGBAB@?$AN?6?$CK?$CK?$AN?6?$AA@|
  00204		 |$LN70@DownloadIm|
  00204	00000000	 DCD         |??_C@_0FO@KDFAPMNM@?$CK?$CK?5Please?5update?5your?5Platform?5B@|
  00208		 |$LN71@DownloadIm|
  00208	00000000	 DCD         |??_C@_0GI@NIAHKKOO@?$CK?$CK?5ERROR?3?5The?5X000FF?5packet?5is?5a@|
  0020c		 |$LN72@DownloadIm|
  0020c	00000000	 DCD         |??_C@_0DP@EIBIBKOO@?$CK?$CK?5?5?5?5?5?5?5?5This?5boot?5loader?5does?5@|
  00210		 |$LN73@DownloadIm|
  00210	00000000	 DCD         |??_C@_0DO@LEKCKELG@?$CK?$CK?5ERROR?3?5Unrecognized?5image?5typ@|
  00214		 |$LN74@DownloadIm|
  00214	00000000	 DCD         |g_downloadFilesRemaining|
  00218		 |$LN75@DownloadIm|
  00218	00000000	 DCD         |??_C@_0CN@MMIJIGEN@Secure?5Boot?5Loader?5includes?5?$CFd?5p@|
  0021c		 |$LN76@DownloadIm|
  0021c	00000000	 DCD         |g_rgdwKeyLengths|
  00220		 |$LN77@DownloadIm|
  00220	00000000	 DCD         |g_keyData|
  00224		 |$LN78@DownloadIm|
  00224	00000000	 DCD         |g_rgpbPublicKeys|
  00228		 |$LN79@DownloadIm|
  00228	00000000	 DCD         |g_wNumPublicKeys|
  0022c		 |$M41756|

			 ENDP  ; |DownloadImage|

	EXPORT	|BootloaderMain|
	EXPORT	|??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@| [ DATA ] ; `string'
	IMPORT	|OEMLaunch|
	IMPORT	|OEMPreDownload|
	IMPORT	|OEMPlatformInit|
	IMPORT	|OEMDebugInit|

  00000			 AREA	 |.pdata|, PDATA
|$T41868| DCD	|$LN87@Bootloader|
	DCD	0x4000a402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@| DCB "ROMHDR a"
	DCB	"t Address %Xh", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@| DCB "Sys"
	DCB	"tem ready!", 0xd, 0xa, "Preparing for download...", 0xd, 0xa
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BootloaderMain| PROC

; 155  : {

  00000		 |$LN87@Bootloader|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M41865|

; 156  :     DWORD dwAction;   
; 157  :     DWORD dwpToc = 0;
; 158  :     DWORD dwImageStart = 0, dwImageLength = 0, dwLaunchAddr = 0;
; 159  :     BOOL bDownloaded = FALSE;
; 160  : 
; 161  :     // relocate globals to RAM
; 162  :     if (!KernelRelocate (pTOC))

  00008	e59fb27c	 ldr         r11, [pc, #0x27C]
  0000c	e3a05000	 mov         r5, #0
  00010	e3a0a000	 mov         r10, #0
  00014	e59b6000	 ldr         r6, [r11]
  00018	e3a08000	 mov         r8, #0
  0001c	e58d5008	 str         r5, [sp, #8]
  00020	e3760001	 cmn         r6, #1
  00024	e58da000	 str         r10, [sp]
  00028	e58d8004	 str         r8, [sp, #4]
  0002c	e3a07000	 mov         r7, #0
  00030	0a000086	 beq         |$LN58@Bootloader|
  00034	e5963020	 ldr         r3, [r6, #0x20]
  00038	e3a09000	 mov         r9, #0
  0003c	e3530000	 cmp         r3, #0
  00040	9a000017	 bls         |$LN14@Bootloader|
  00044	e3a07000	 mov         r7, #0
  00048		 |$LL21@Bootloader|
  00048	e5963024	 ldr         r3, [r6, #0x24]
  0004c	e0834007	 add         r4, r3, r7
  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e3530000	 cmp         r3, #0
  00058	15941000	 ldrne       r1, [r4]
  0005c	15940004	 ldrne       r0, [r4, #4]
  00060	11a02003	 movne       r2, r3
  00064	1b000000	 blne        memcpy
  00068	e594200c	 ldr         r2, [r4, #0xC]
  0006c	e5943008	 ldr         r3, [r4, #8]
  00070	e1530002	 cmp         r3, r2
  00074	11a00003	 movne       r0, r3
  00078	15943004	 ldrne       r3, [r4, #4]
  0007c	10422000	 subne       r2, r2, r0
  00080	13a01000	 movne       r1, #0
  00084	10800003	 addne       r0, r0, r3
  00088	1b000000	 blne        memset
  0008c	e5963020	 ldr         r3, [r6, #0x20]
  00090	e2899001	 add         r9, r9, #1
  00094	e2877010	 add         r7, r7, #0x10
  00098	e1590003	 cmp         r9, r3
  0009c	3affffe9	 bcc         |$LL21@Bootloader|
  000a0	e3a07000	 mov         r7, #0
  000a4		 |$LN14@Bootloader|

; 166  :     }
; 167  : 
; 168  :     // (1) Init debug support. We can use OEMWriteDebugString afterward.
; 169  :     if (!OEMDebugInit ())

  000a4	eb000000	 bl          OEMDebugInit
  000a8	e3500000	 cmp         r0, #0
  000ac	1a000007	 bne         |$LN13@Bootloader|

; 170  :     {
; 171  :         // spin forever
; 172  :         HALT (BLERR_DBGINIT);

  000b0	e59f21b8	 ldr         r2, [pc, #0x1B8]
  000b4	e5923000	 ldr         r3, [r2]
  000b8	e3530000	 cmp         r3, #0
  000bc	13a01000	 movne       r1, #0
  000c0	13e00001	 mvnne       r0, #1
  000c4	11a0e00f	 movne       lr, pc
  000c8	112fff13	 bxne        r3
  000cc		 |$LL31@Bootloader|
  000cc	eafffffe	 b           |$LL31@Bootloader|
  000d0		 |$LN13@Bootloader|

; 173  :     }
; 174  : 
; 175  :     // output banner
; 176  :     KITLOutputDebugString (NKSignon, CURRENT_VERSION_MAJOR, CURRENT_VERSION_MINOR);

  000d0	e3a02004	 mov         r2, #4
  000d4	e3a01001	 mov         r1, #1
  000d8	e28b0008	 add         r0, r11, #8
  000dc	eb000000	 bl          KITLOutputDebugString

; 177  : 
; 178  :     // (3) initialize platform (clock, drivers, transports, etc)
; 179  :     if (!OEMPlatformInit ())

  000e0	eb000000	 bl          OEMPlatformInit
  000e4	e3500000	 cmp         r0, #0
  000e8	1a000007	 bne         |$LN12@Bootloader|

; 180  :     {
; 181  :         // spin forever
; 182  :         HALT (BLERR_PLATINIT);

  000ec	e59f217c	 ldr         r2, [pc, #0x17C]
  000f0	e5923000	 ldr         r3, [r2]
  000f4	e3530000	 cmp         r3, #0
  000f8	13a01000	 movne       r1, #0
  000fc	13e00002	 mvnne       r0, #2
  00100	11a0e00f	 movne       lr, pc
  00104	112fff13	 bxne        r3
  00108		 |$LL36@Bootloader|
  00108	eafffffe	 b           |$LL36@Bootloader|
  0010c		 |$LN12@Bootloader|

; 183  :     }
; 184  : 
; 185  :     // system ready, preparing for download
; 186  :     KITLOutputDebugString ("System ready!\r\nPreparing for download...\r\n");

  0010c	e59f0174	 ldr         r0, [pc, #0x174]
  00110	eb000000	 bl          KITLOutputDebugString

; 187  : 
; 188  :     // (4) call OEM specific pre-download function
; 189  :     switch (dwAction = OEMPreDownload ())

  00114	eb000000	 bl          OEMPreDownload
  00118	e59f4164	 ldr         r4, [pc, #0x164]
  0011c	e3500000	 cmp         r0, #0
  00120	0a000002	 beq         |$LN9@Bootloader|
  00124	e3500001	 cmp         r0, #1
  00128	0a000021	 beq         |$LN84@Bootloader|
  0012c	ea00003f	 b           |$LN1@Bootloader|
  00130		 |$LN9@Bootloader|

; 190  :     {
; 191  :     case BL_DOWNLOAD:
; 192  :         // (5) download image
; 193  :         if (!DownloadImage (&dwImageStart, &dwImageLength, &dwLaunchAddr))

  00130	e28d2004	 add         r2, sp, #4
  00134	e28d1000	 add         r1, sp, #0
  00138	e28d0008	 add         r0, sp, #8
  0013c	eb000000	 bl          DownloadImage
  00140	e3500000	 cmp         r0, #0
  00144	1a000000	 bne         |$LN6@Bootloader|
  00148		 |$LL7@Bootloader|

; 194  :         {
; 195  :             // error already reported in DownloadImage
; 196  :             SPIN_FOREVER;

  00148	eafffffe	 b           |$LL7@Bootloader|
  0014c		 |$LN6@Bootloader|

; 197  :         }
; 198  :         bDownloaded = TRUE;
; 199  : 
; 200  :         // Check for pTOC signature ("CECE") here, after image in place
; 201  :         if (*(LPDWORD) OEMMapMemAddr (dwImageStart, dwImageStart + ROM_SIGNATURE_OFFSET) == ROM_SIGNATURE)

  0014c	e59d5008	 ldr         r5, [sp, #8]
  00150	e3a07001	 mov         r7, #1
  00154	e2851040	 add         r1, r5, #0x40
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          OEMMapMemAddr
  00160	e5902000	 ldr         r2, [r0]
  00164	e59f3114	 ldr         r3, [pc, #0x114]
  00168	e1520003	 cmp         r2, r3
  0016c	1a00000e	 bne         |$LN71@Bootloader|

; 202  :         {
; 203  :             dwpToc = *(LPDWORD) OEMMapMemAddr (dwImageStart, dwImageStart + ROM_SIGNATURE_OFFSET + sizeof(ULONG));

  00170	e2851044	 add         r1, r5, #0x44
  00174	e1a00005	 mov         r0, r5
  00178	eb000000	 bl          OEMMapMemAddr
  0017c	e5902000	 ldr         r2, [r0]

; 204  :             // need to map the content again since the pointer is going to be in a fixup address
; 205  :             dwpToc = (DWORD) OEMMapMemAddr (dwImageStart, dwpToc + g_dwROMOffset);

  00180	e5943000	 ldr         r3, [r4]
  00184	e1a00005	 mov         r0, r5
  00188	e0831002	 add         r1, r3, r2
  0018c	eb000000	 bl          OEMMapMemAddr
  00190	e1a06000	 mov         r6, r0

; 206  : 
; 207  :             KITLOutputDebugString ("ROMHDR at Address %Xh\r\n", dwImageStart + ROM_SIGNATURE_OFFSET + sizeof (DWORD)); // right after signature

  00194	e59f00e0	 ldr         r0, [pc, #0xE0]
  00198	e2851044	 add         r1, r5, #0x44
  0019c	eb000000	 bl          KITLOutputDebugString
  001a0	e59da000	 ldr         r10, [sp]
  001a4	e59d8004	 ldr         r8, [sp, #4]
  001a8	ea000002	 b           |$LN5@Bootloader|
  001ac		 |$LN71@Bootloader|
  001ac	e59da000	 ldr         r10, [sp]
  001b0	e59d8004	 ldr         r8, [sp, #4]
  001b4		 |$LN84@Bootloader|
  001b4	e3a06000	 mov         r6, #0
  001b8		 |$LN5@Bootloader|

; 208  :         }
; 209  : 
; 210  :         // fall through
; 211  :     case BL_JUMP:
; 212  :         // Before jumping to the image, optionally check the image signature.
; 213  :         // NOTE: if we haven't downloaded the image by now, we assume that it'll be loaded from local storage in OEMLaunch (or it
; 214  :         // already resides in RAM from an earlier download), and in this case, the image start address might be 0.  This means 
; 215  :         // that the image signature routine will need to find the image in storage or in RAM to validate it.  Since the OEM"s 
; 216  :         // OEMLaunch function will need to do this anyways, we trust that it's within their abilities to do it here.
; 217  :         //
; 218  :         if (g_bBINDownload && g_pOEMCheckSignature)

  001b8	e59f20b8	 ldr         r2, [pc, #0xB8]
  001bc	e5d22000	 ldrb        r2, [r2]
  001c0	e3520000	 cmp         r2, #0
  001c4	0a000014	 beq         |$LN2@Bootloader|
  001c8	e59f00a4	 ldr         r0, [pc, #0xA4]
  001cc	e5902000	 ldr         r2, [r0]
  001d0	e3520000	 cmp         r2, #0
  001d4	0a000010	 beq         |$LN2@Bootloader|

; 219  :         {
; 220  :             if (!g_pOEMCheckSignature(dwImageStart, g_dwROMOffset, dwLaunchAddr, bDownloaded))

  001d8	e5941000	 ldr         r1, [r4]
  001dc	e1a04002	 mov         r4, r2
  001e0	e1a02008	 mov         r2, r8
  001e4	e1a03007	 mov         r3, r7
  001e8	e1a00005	 mov         r0, r5
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff14	 bx          r4
  001f4	e3500000	 cmp         r0, #0
  001f8	1a000007	 bne         |$LN2@Bootloader|

; 221  :                 HALT(BLERR_CAT_SIGNATURE);

  001fc	e59f206c	 ldr         r2, [pc, #0x6C]
  00200	e5923000	 ldr         r3, [r2]
  00204	e3530000	 cmp         r3, #0
  00208	13a01000	 movne       r1, #0
  0020c	13e0000c	 mvnne       r0, #0xC
  00210	11a0e00f	 movne       lr, pc
  00214	112fff13	 bxne        r3
  00218		 |$LL41@Bootloader|
  00218	eafffffe	 b           |$LL41@Bootloader|
  0021c		 |$LN2@Bootloader|

; 222  :         }
; 223  :         // (5) final call to launch the image. never returned
; 224  :         OEMLaunch (dwImageStart, dwImageLength, dwLaunchAddr, (const ROMHDR *)dwpToc);

  0021c	e1a03006	 mov         r3, r6
  00220	e1a02008	 mov         r2, r8
  00224	e1a0100a	 mov         r1, r10
  00228	e1a00005	 mov         r0, r5
  0022c	eb000000	 bl          OEMLaunch
  00230		 |$LN1@Bootloader|

; 225  :         // should never return
; 226  :         // fall through
; 227  :     default:
; 228  :         // ERROR! spin forever
; 229  :         HALT (BLERR_INVALIDCMD);

  00230	e59f2038	 ldr         r2, [pc, #0x38]
  00234	e5923000	 ldr         r3, [r2]
  00238	e3530000	 cmp         r3, #0
  0023c	13a01000	 movne       r1, #0
  00240	13e00005	 mvnne       r0, #5
  00244	11a0e00f	 movne       lr, pc
  00248	112fff13	 bxne        r3
  0024c		 |$LL46@Bootloader|
  0024c	eafffffe	 b           |$LL46@Bootloader|
  00250		 |$LN58@Bootloader|

; 163  :     {
; 164  :         // spin forever
; 165  :         HALT (BLERR_KERNELRELOCATE);

  00250	e59f2018	 ldr         r2, [pc, #0x18]
  00254	e5923000	 ldr         r3, [r2]
  00258	e3530000	 cmp         r3, #0
  0025c	13a01000	 movne       r1, #0
  00260	13e00000	 mvnne       r0, #0
  00264	11a0e00f	 movne       lr, pc
  00268	112fff13	 bxne        r3
  0026c		 |$LL26@Bootloader|
  0026c	eafffffe	 b           |$LL26@Bootloader|
  00270		 |$LN88@Bootloader|
  00270		 |$LN89@Bootloader|
  00270	00000000	 DCD         |g_pOEMReportError|
  00274		 |$LN90@Bootloader|
  00274	00000000	 DCD         |g_pOEMCheckSignature|
  00278		 |$LN91@Bootloader|
  00278	00000000	 DCD         |g_bBINDownload|
  0027c		 |$LN92@Bootloader|
  0027c	00000000	 DCD         |??_C@_0BI@OCFAEGPK@ROMHDR?5at?5Address?5?$CFXh?$AN?6?$AA@|
  00280		 |$LN93@Bootloader|
  00280	43454345	 DCD         0x43454345
  00284		 |$LN94@Bootloader|
  00284	00000000	 DCD         |g_dwROMOffset|
  00288		 |$LN95@Bootloader|
  00288	00000000	 DCD         |??_C@_0CL@NOFKHKJC@System?5ready?$CB?$AN?6Preparing?5for?5dow@|
  0028c		 |$LN96@Bootloader|
  0028c	00000000	 DCD         |pTOC|
  00290		 |$M41866|

			 ENDP  ; |BootloaderMain|

	END
